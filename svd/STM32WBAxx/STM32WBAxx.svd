<?xml version="1.0" encoding="utf-8" standalone="no"?>
<!--
Copyright (c) 2022 STMicroelectronics.

 SPDX-License-Identifier: Apache-2.0

 Licensed under the Apache License, Version 2.0 (the "License");
 you may not use this file except in compliance with the License.
 You may obtain a copy of the License at

 http://www.apache.org/licenses/LICENSE-2.0

 Unless required by applicable law or agreed to in writing, software
 distributed under the License is distributed on an "AS IS" BASIS,
 WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 See the License for the specific language governing permissions and
 limitations under the License.
-->
<device xmlns:xs="http://www.w3.org/2001/XMLSchema-instance" schemaVersion="1.1" xs:noNamespaceSchemaLocation="CMSIS-SVD_Schema_1_1.xsd">
  <name>STM32WBAxx</name>
  <version>0.2</version>
  <description>STM32WBAxx</description>
  <addressUnitBits>8</addressUnitBits>
  <width>32</width>
  <size>0x20</size>
  <resetValue>0x0</resetValue>
  <resetMask>0xFFFFFFFF</resetMask>
  <peripherals>
    <peripheral>
        <name>CRC</name>
        <description>Cyclic redundancy check calculation unit</description>
		<groupName>CRC</groupName>
        <baseAddress>0x40023000</baseAddress>
        <addressBlock>
          <offset>0x0</offset>
          <size>0x400</size>
          <usage>registers</usage>
        </addressBlock>
        <registers>
          <register>
            <name>CRC_DR</name>
            <displayName>CRC_DR</displayName>
            <description>CRC data register</description>
            <addressOffset>0x00</addressOffset>
            <size>0x20</size>
            <resetValue>0xFFFFFFFF</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>DR</name>
                <description>Data register bits
This register is used to write new data to the CRC calculator.
It holds the previous CRC calculation result when it is read.
If the data size is less than 32 bits, the least significant bits are used to write/read the correct value.</description>
                <bitOffset>0</bitOffset>
                <bitWidth>32</bitWidth>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>CRC_IDR</name>
            <displayName>CRC_IDR</displayName>
            <description>CRC independent data register</description>
            <addressOffset>0x04</addressOffset>
            <size>0x20</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>IDR</name>
                <description>General-purpose 32-bit data register bits
These bits can be used as a temporary storage location for four bytes.
This register is not affected by CRC resets generated by the RESET bit in the CRC_CR register</description>
                <bitOffset>0</bitOffset>
                <bitWidth>32</bitWidth>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>CRC_CR</name>
            <displayName>CRC_CR</displayName>
            <description>CRC control register</description>
            <addressOffset>0x08</addressOffset>
            <size>0x20</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>RESET</name>
                <description>RESET bit
This bit is set by software to reset the CRC calculation unit and set the data register to the value stored in the CRC_INIT register. This bit can only be set, it is automatically cleared by hardware</description>
                <bitOffset>0</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>POLYSIZE</name>
                <description>Polynomial size
These bits control the size of the polynomial.</description>
                <bitOffset>3</bitOffset>
                <bitWidth>2</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>32 bit polynomial</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>16 bit polynomial</description>
                    <value>0x1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x2</name>
                    <description>8 bit polynomial</description>
                    <value>0x2</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x3</name>
                    <description>7 bit polynomial</description>
                    <value>0x3</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>REV_IN</name>
                <description>Reverse input data
These bits control the reversal of the bit order of the input data</description>
                <bitOffset>5</bitOffset>
                <bitWidth>2</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Bit order not affected</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Bit reversal done by byte</description>
                    <value>0x1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x2</name>
                    <description>Bit reversal done by half-word</description>
                    <value>0x2</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x3</name>
                    <description>Bit reversal done by word</description>
                    <value>0x3</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>REV_OUT</name>
                <description>Reverse output data
This bit controls the reversal of the bit order of the output data.</description>
                <bitOffset>7</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Bit order not affected</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Bit-reversed output format</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
            </fields>
          </register>
          <register>
            <name>CRC_INIT</name>
            <displayName>CRC_INIT</displayName>
            <description>CRC initial value</description>
            <addressOffset>0x10</addressOffset>
            <size>0x20</size>
            <resetValue>0xFFFFFFFF</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>CRC_INIT</name>
                <description>Programmable initial CRC value
This register is used to write the CRC initial value.</description>
                <bitOffset>0</bitOffset>
                <bitWidth>32</bitWidth>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>CRC_POL</name>
            <displayName>CRC_POL</displayName>
            <description>CRC polynomial</description>
            <addressOffset>0x14</addressOffset>
            <size>0x20</size>
            <resetValue>0x04C11DB7</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>POL</name>
                <description>Programmable polynomial 
This register is used to write the coefficients of the polynomial to be used for CRC calculation.
If the polynomial size is less than 32 bits, the least significant bits have to be used to program the correct value.</description>
                <bitOffset>0</bitOffset>
                <bitWidth>32</bitWidth>
                <access>read-write</access>
              </field>
            </fields>
          </register>
        </registers>
    </peripheral>
	<peripheral derivedFrom="CRC">
        <name>SEC_CRC</name>
        <baseAddress>0x50023000</baseAddress>
    </peripheral>
    <peripheral>
        <name>EXTI</name>
        <description>External interrupt/event controller</description>
        <groupName>EXTI</groupName>
        <baseAddress>0x46022000</baseAddress>
        <addressBlock>
          <offset>0x0</offset>
          <size>0x400</size>
          <usage>registers</usage>
        </addressBlock>
        <interrupt>
          <name>PDV</name>
          <description>Power voltage monitor</description>
		  <value>001</value>
	    </interrupt>
		<interrupt>
		  <name>EXTI0</name>
		  <description>EXTI line0 interrupt</description>
		  <value>011</value>
	    </interrupt>
	    <interrupt>
		  <name>EXTI1</name>
		  <description>EXTI line1 interrupt</description>
		  <value>012</value>
		</interrupt>
	    <interrupt>
		  <name>EXTI2</name>
		  <description>EXTI line2 interrupt</description>
		  <value>013</value>
		</interrupt>
		<interrupt>
		  <name>EXTI3</name>
		  <description>EXTI line3 interrupt</description>
		  <value>014</value>
	    </interrupt>
	    <interrupt>
		  <name>EXTI4</name>
		  <description>EXTI line4 interrupt</description>
		  <value>015</value>
	    </interrupt>
		<interrupt>
	  	  <name>EXTI5</name>
		  <description>EXTI line5 interrupt</description>
		  <value>016</value>
		</interrupt>
	    <interrupt>
		  <name>EXTI6</name>
		  <description>EXTI line6 interrupt</description>
		  <value>017</value>
		</interrupt>
	    <interrupt>
		  <name>EXTI7</name>
		  <description>EXTI line7 interrupt</description>
		  <value>018</value>
		</interrupt>
	    <interrupt>
		  <name>EXTI8</name>
		  <description>EXTI line8 interrupt</description>
		  <value>019</value>
		</interrupt>
	    <interrupt>
		  <name>EXTI9</name>
		  <description>EXTI line9 interrupt</description>
		  <value>020</value>
		</interrupt>
		<interrupt>
		  <name>EXTI10</name>
		  <description>EXTI line10 interrupt</description>
		  <value>021</value>
		</interrupt>
		<interrupt>
		  <name>EXTI11</name>
		  <description>EXTI line11 interrupt</description>
		  <value>022</value>
		</interrupt>
		<interrupt>
		  <name>EXTI12</name>
		  <description>EXTI line12 interrupt</description>
		  <value>023</value>
		</interrupt>
		<interrupt>
		  <name>EXTI13</name>
		  <description>EXTI line13 interrupt</description>
		  <value>024</value>
		</interrupt>
		<interrupt>
		  <name>EXTI14</name>
		  <description>EXTI line14 interrupt</description>
		  <value>025</value>
		</interrupt>
		<interrupt>
		  <name>EXTI15</name>
		  <description>EXTI line15 interrupt</description>
	      <value>026</value>
		</interrupt>
        <registers>
          <register>
            <name>EXTI_RTSR1</name>
            <displayName>EXTI_RTSR1</displayName>
            <description>EXTI rising trigger selection register</description>
            <addressOffset>0x000</addressOffset>
            <size>0x20</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>RT0</name>
                <description>Rising trigger event configuration bit of configurable event input x
When EXTI_SECCFGR.SECx is disabled, RTx can be accessed with non-secure and secure access.
When EXTI_SECCFGR.SECx is enabled, RTx can only be accessed with secure access. Non-secure write to this bit x is discarded and non-secure read returns 0.
When EXTI_PRIVCFGR.PRIVx is disabled, RTx can be accessed with unprivileged and privileged access.
When EXTI_PRIVCFGR.PRIVx is enabled, RTx can only be accessed with privileged access. Unprivileged write to this bit x is discarded, unprivileged read returns 0.</description>
                <bitOffset>0</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Rising trigger disabled (for event and interrupt) for input line</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Rising trigger enabled (for event and interrupt) for input line</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>RT1</name>
                <description>Rising trigger event configuration bit of configurable event input x
When EXTI_SECCFGR.SECx is disabled, RTx can be accessed with non-secure and secure access.
When EXTI_SECCFGR.SECx is enabled, RTx can only be accessed with secure access. Non-secure write to this bit x is discarded and non-secure read returns 0.
When EXTI_PRIVCFGR.PRIVx is disabled, RTx can be accessed with unprivileged and privileged access.
When EXTI_PRIVCFGR.PRIVx is enabled, RTx can only be accessed with privileged access. Unprivileged write to this bit x is discarded, unprivileged read returns 0.</description>
                <bitOffset>1</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Rising trigger disabled (for event and interrupt) for input line</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Rising trigger enabled (for event and interrupt) for input line</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>RT2</name>
                <description>Rising trigger event configuration bit of configurable event input x
When EXTI_SECCFGR.SECx is disabled, RTx can be accessed with non-secure and secure access.
When EXTI_SECCFGR.SECx is enabled, RTx can only be accessed with secure access. Non-secure write to this bit x is discarded and non-secure read returns 0.
When EXTI_PRIVCFGR.PRIVx is disabled, RTx can be accessed with unprivileged and privileged access.
When EXTI_PRIVCFGR.PRIVx is enabled, RTx can only be accessed with privileged access. Unprivileged write to this bit x is discarded, unprivileged read returns 0.</description>
                <bitOffset>2</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Rising trigger disabled (for event and interrupt) for input line</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Rising trigger enabled (for event and interrupt) for input line</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>RT3</name>
                <description>Rising trigger event configuration bit of configurable event input x
When EXTI_SECCFGR.SECx is disabled, RTx can be accessed with non-secure and secure access.
When EXTI_SECCFGR.SECx is enabled, RTx can only be accessed with secure access. Non-secure write to this bit x is discarded and non-secure read returns 0.
When EXTI_PRIVCFGR.PRIVx is disabled, RTx can be accessed with unprivileged and privileged access.
When EXTI_PRIVCFGR.PRIVx is enabled, RTx can only be accessed with privileged access. Unprivileged write to this bit x is discarded, unprivileged read returns 0.</description>
                <bitOffset>3</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Rising trigger disabled (for event and interrupt) for input line</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Rising trigger enabled (for event and interrupt) for input line</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>RT4</name>
                <description>Rising trigger event configuration bit of configurable event input x
When EXTI_SECCFGR.SECx is disabled, RTx can be accessed with non-secure and secure access.
When EXTI_SECCFGR.SECx is enabled, RTx can only be accessed with secure access. Non-secure write to this bit x is discarded and non-secure read returns 0.
When EXTI_PRIVCFGR.PRIVx is disabled, RTx can be accessed with unprivileged and privileged access.
When EXTI_PRIVCFGR.PRIVx is enabled, RTx can only be accessed with privileged access. Unprivileged write to this bit x is discarded, unprivileged read returns 0.</description>
                <bitOffset>4</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Rising trigger disabled (for event and interrupt) for input line</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Rising trigger enabled (for event and interrupt) for input line</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>RT5</name>
                <description>Rising trigger event configuration bit of configurable event input x
When EXTI_SECCFGR.SECx is disabled, RTx can be accessed with non-secure and secure access.
When EXTI_SECCFGR.SECx is enabled, RTx can only be accessed with secure access. Non-secure write to this bit x is discarded and non-secure read returns 0.
When EXTI_PRIVCFGR.PRIVx is disabled, RTx can be accessed with unprivileged and privileged access.
When EXTI_PRIVCFGR.PRIVx is enabled, RTx can only be accessed with privileged access. Unprivileged write to this bit x is discarded, unprivileged read returns 0.</description>
                <bitOffset>5</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Rising trigger disabled (for event and interrupt) for input line</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Rising trigger enabled (for event and interrupt) for input line</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>RT6</name>
                <description>Rising trigger event configuration bit of configurable event input x
When EXTI_SECCFGR.SECx is disabled, RTx can be accessed with non-secure and secure access.
When EXTI_SECCFGR.SECx is enabled, RTx can only be accessed with secure access. Non-secure write to this bit x is discarded and non-secure read returns 0.
When EXTI_PRIVCFGR.PRIVx is disabled, RTx can be accessed with unprivileged and privileged access.
When EXTI_PRIVCFGR.PRIVx is enabled, RTx can only be accessed with privileged access. Unprivileged write to this bit x is discarded, unprivileged read returns 0.</description>
                <bitOffset>6</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Rising trigger disabled (for event and interrupt) for input line</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Rising trigger enabled (for event and interrupt) for input line</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>RT7</name>
                <description>Rising trigger event configuration bit of configurable event input x
When EXTI_SECCFGR.SECx is disabled, RTx can be accessed with non-secure and secure access.
When EXTI_SECCFGR.SECx is enabled, RTx can only be accessed with secure access. Non-secure write to this bit x is discarded and non-secure read returns 0.
When EXTI_PRIVCFGR.PRIVx is disabled, RTx can be accessed with unprivileged and privileged access.
When EXTI_PRIVCFGR.PRIVx is enabled, RTx can only be accessed with privileged access. Unprivileged write to this bit x is discarded, unprivileged read returns 0.</description>
                <bitOffset>7</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Rising trigger disabled (for event and interrupt) for input line</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Rising trigger enabled (for event and interrupt) for input line</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>RT8</name>
                <description>Rising trigger event configuration bit of configurable event input x
When EXTI_SECCFGR.SECx is disabled, RTx can be accessed with non-secure and secure access.
When EXTI_SECCFGR.SECx is enabled, RTx can only be accessed with secure access. Non-secure write to this bit x is discarded and non-secure read returns 0.
When EXTI_PRIVCFGR.PRIVx is disabled, RTx can be accessed with unprivileged and privileged access.
When EXTI_PRIVCFGR.PRIVx is enabled, RTx can only be accessed with privileged access. Unprivileged write to this bit x is discarded, unprivileged read returns 0.</description>
                <bitOffset>8</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Rising trigger disabled (for event and interrupt) for input line</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Rising trigger enabled (for event and interrupt) for input line</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>RT9</name>
                <description>Rising trigger event configuration bit of configurable event input x
When EXTI_SECCFGR.SECx is disabled, RTx can be accessed with non-secure and secure access.
When EXTI_SECCFGR.SECx is enabled, RTx can only be accessed with secure access. Non-secure write to this bit x is discarded and non-secure read returns 0.
When EXTI_PRIVCFGR.PRIVx is disabled, RTx can be accessed with unprivileged and privileged access.
When EXTI_PRIVCFGR.PRIVx is enabled, RTx can only be accessed with privileged access. Unprivileged write to this bit x is discarded, unprivileged read returns 0.</description>
                <bitOffset>9</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Rising trigger disabled (for event and interrupt) for input line</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Rising trigger enabled (for event and interrupt) for input line</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>RT10</name>
                <description>Rising trigger event configuration bit of configurable event input x
When EXTI_SECCFGR.SECx is disabled, RTx can be accessed with non-secure and secure access.
When EXTI_SECCFGR.SECx is enabled, RTx can only be accessed with secure access. Non-secure write to this bit x is discarded and non-secure read returns 0.
When EXTI_PRIVCFGR.PRIVx is disabled, RTx can be accessed with unprivileged and privileged access.
When EXTI_PRIVCFGR.PRIVx is enabled, RTx can only be accessed with privileged access. Unprivileged write to this bit x is discarded, unprivileged read returns 0.</description>
                <bitOffset>10</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Rising trigger disabled (for event and interrupt) for input line</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Rising trigger enabled (for event and interrupt) for input line</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>RT11</name>
                <description>Rising trigger event configuration bit of configurable event input x
When EXTI_SECCFGR.SECx is disabled, RTx can be accessed with non-secure and secure access.
When EXTI_SECCFGR.SECx is enabled, RTx can only be accessed with secure access. Non-secure write to this bit x is discarded and non-secure read returns 0.
When EXTI_PRIVCFGR.PRIVx is disabled, RTx can be accessed with unprivileged and privileged access.
When EXTI_PRIVCFGR.PRIVx is enabled, RTx can only be accessed with privileged access. Unprivileged write to this bit x is discarded, unprivileged read returns 0.</description>
                <bitOffset>11</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Rising trigger disabled (for event and interrupt) for input line</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Rising trigger enabled (for event and interrupt) for input line</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>RT12</name>
                <description>Rising trigger event configuration bit of configurable event input x
When EXTI_SECCFGR.SECx is disabled, RTx can be accessed with non-secure and secure access.
When EXTI_SECCFGR.SECx is enabled, RTx can only be accessed with secure access. Non-secure write to this bit x is discarded and non-secure read returns 0.
When EXTI_PRIVCFGR.PRIVx is disabled, RTx can be accessed with unprivileged and privileged access.
When EXTI_PRIVCFGR.PRIVx is enabled, RTx can only be accessed with privileged access. Unprivileged write to this bit x is discarded, unprivileged read returns 0.</description>
                <bitOffset>12</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Rising trigger disabled (for event and interrupt) for input line</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Rising trigger enabled (for event and interrupt) for input line</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>RT13</name>
                <description>Rising trigger event configuration bit of configurable event input x
When EXTI_SECCFGR.SECx is disabled, RTx can be accessed with non-secure and secure access.
When EXTI_SECCFGR.SECx is enabled, RTx can only be accessed with secure access. Non-secure write to this bit x is discarded and non-secure read returns 0.
When EXTI_PRIVCFGR.PRIVx is disabled, RTx can be accessed with unprivileged and privileged access.
When EXTI_PRIVCFGR.PRIVx is enabled, RTx can only be accessed with privileged access. Unprivileged write to this bit x is discarded, unprivileged read returns 0.</description>
                <bitOffset>13</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Rising trigger disabled (for event and interrupt) for input line</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Rising trigger enabled (for event and interrupt) for input line</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>RT14</name>
                <description>Rising trigger event configuration bit of configurable event input x
When EXTI_SECCFGR.SECx is disabled, RTx can be accessed with non-secure and secure access.
When EXTI_SECCFGR.SECx is enabled, RTx can only be accessed with secure access. Non-secure write to this bit x is discarded and non-secure read returns 0.
When EXTI_PRIVCFGR.PRIVx is disabled, RTx can be accessed with unprivileged and privileged access.
When EXTI_PRIVCFGR.PRIVx is enabled, RTx can only be accessed with privileged access. Unprivileged write to this bit x is discarded, unprivileged read returns 0.</description>
                <bitOffset>14</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Rising trigger disabled (for event and interrupt) for input line</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Rising trigger enabled (for event and interrupt) for input line</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>RT15</name>
                <description>Rising trigger event configuration bit of configurable event input x
When EXTI_SECCFGR.SECx is disabled, RTx can be accessed with non-secure and secure access.
When EXTI_SECCFGR.SECx is enabled, RTx can only be accessed with secure access. Non-secure write to this bit x is discarded and non-secure read returns 0.
When EXTI_PRIVCFGR.PRIVx is disabled, RTx can be accessed with unprivileged and privileged access.
When EXTI_PRIVCFGR.PRIVx is enabled, RTx can only be accessed with privileged access. Unprivileged write to this bit x is discarded, unprivileged read returns 0.</description>
                <bitOffset>15</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Rising trigger disabled (for event and interrupt) for input line</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Rising trigger enabled (for event and interrupt) for input line</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>RT16</name>
                <description>Rising trigger event configuration bit of configurable event input x
When EXTI_SECCFGR.SECx is disabled, RTx can be accessed with non-secure and secure access.
When EXTI_SECCFGR.SECx is enabled, RTx can only be accessed with secure access. Non-secure write to this bit x is discarded and non-secure read returns 0.
When EXTI_PRIVCFGR.PRIVx is disabled, RTx can be accessed with unprivileged and privileged access.
When EXTI_PRIVCFGR.PRIVx is enabled, RTx can only be accessed with privileged access. Unprivileged write to this bit x is discarded, unprivileged read returns 0.</description>
                <bitOffset>16</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Rising trigger disabled (for event and interrupt) for input line</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Rising trigger enabled (for event and interrupt) for input line</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
            </fields>
          </register>
          <register>
            <name>EXTI_FTSR1</name>
            <displayName>EXTI_FTSR1</displayName>
            <description>EXTI falling trigger selection register</description>
            <addressOffset>0x004</addressOffset>
            <size>0x20</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>FT0</name>
                <description>Falling trigger event configuration bit of configurable event input x
When EXTI_SECCFGR.SECx is disabled, FTx can be accessed with non-secure and secure access.
When EXTI_SECCFGR.SECx is enabled, FTx can only be accessed with secure access. Non-secure write to this FTx is discarded, non-secure read returns 0.
When EXTI_PRIVCFGR.PRIVx is disabled, FTx can be accessed with unprivileged and privileged access.
When EXTI_PRIVCFGR.PRIVx is enabled, FTx can only be accessed with privileged access. Unprivileged write to this FTx is discarded, unprivileged read returns 0.</description>
                <bitOffset>0</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Falling trigger disabled (for event and Interrupt) for input line</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Falling trigger enabled (for event and Interrupt) for input line.</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>FT1</name>
                <description>Falling trigger event configuration bit of configurable event input x
When EXTI_SECCFGR.SECx is disabled, FTx can be accessed with non-secure and secure access.
When EXTI_SECCFGR.SECx is enabled, FTx can only be accessed with secure access. Non-secure write to this FTx is discarded, non-secure read returns 0.
When EXTI_PRIVCFGR.PRIVx is disabled, FTx can be accessed with unprivileged and privileged access.
When EXTI_PRIVCFGR.PRIVx is enabled, FTx can only be accessed with privileged access. Unprivileged write to this FTx is discarded, unprivileged read returns 0.</description>
                <bitOffset>1</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Falling trigger disabled (for event and Interrupt) for input line</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Falling trigger enabled (for event and Interrupt) for input line.</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>FT2</name>
                <description>Falling trigger event configuration bit of configurable event input x
When EXTI_SECCFGR.SECx is disabled, FTx can be accessed with non-secure and secure access.
When EXTI_SECCFGR.SECx is enabled, FTx can only be accessed with secure access. Non-secure write to this FTx is discarded, non-secure read returns 0.
When EXTI_PRIVCFGR.PRIVx is disabled, FTx can be accessed with unprivileged and privileged access.
When EXTI_PRIVCFGR.PRIVx is enabled, FTx can only be accessed with privileged access. Unprivileged write to this FTx is discarded, unprivileged read returns 0.</description>
                <bitOffset>2</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Falling trigger disabled (for event and Interrupt) for input line</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Falling trigger enabled (for event and Interrupt) for input line.</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>FT3</name>
                <description>Falling trigger event configuration bit of configurable event input x
When EXTI_SECCFGR.SECx is disabled, FTx can be accessed with non-secure and secure access.
When EXTI_SECCFGR.SECx is enabled, FTx can only be accessed with secure access. Non-secure write to this FTx is discarded, non-secure read returns 0.
When EXTI_PRIVCFGR.PRIVx is disabled, FTx can be accessed with unprivileged and privileged access.
When EXTI_PRIVCFGR.PRIVx is enabled, FTx can only be accessed with privileged access. Unprivileged write to this FTx is discarded, unprivileged read returns 0.</description>
                <bitOffset>3</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Falling trigger disabled (for event and Interrupt) for input line</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Falling trigger enabled (for event and Interrupt) for input line.</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>FT4</name>
                <description>Falling trigger event configuration bit of configurable event input x
When EXTI_SECCFGR.SECx is disabled, FTx can be accessed with non-secure and secure access.
When EXTI_SECCFGR.SECx is enabled, FTx can only be accessed with secure access. Non-secure write to this FTx is discarded, non-secure read returns 0.
When EXTI_PRIVCFGR.PRIVx is disabled, FTx can be accessed with unprivileged and privileged access.
When EXTI_PRIVCFGR.PRIVx is enabled, FTx can only be accessed with privileged access. Unprivileged write to this FTx is discarded, unprivileged read returns 0.</description>
                <bitOffset>4</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Falling trigger disabled (for event and Interrupt) for input line</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Falling trigger enabled (for event and Interrupt) for input line.</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>FT5</name>
                <description>Falling trigger event configuration bit of configurable event input x
When EXTI_SECCFGR.SECx is disabled, FTx can be accessed with non-secure and secure access.
When EXTI_SECCFGR.SECx is enabled, FTx can only be accessed with secure access. Non-secure write to this FTx is discarded, non-secure read returns 0.
When EXTI_PRIVCFGR.PRIVx is disabled, FTx can be accessed with unprivileged and privileged access.
When EXTI_PRIVCFGR.PRIVx is enabled, FTx can only be accessed with privileged access. Unprivileged write to this FTx is discarded, unprivileged read returns 0.</description>
                <bitOffset>5</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Falling trigger disabled (for event and Interrupt) for input line</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Falling trigger enabled (for event and Interrupt) for input line.</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>FT6</name>
                <description>Falling trigger event configuration bit of configurable event input x
When EXTI_SECCFGR.SECx is disabled, FTx can be accessed with non-secure and secure access.
When EXTI_SECCFGR.SECx is enabled, FTx can only be accessed with secure access. Non-secure write to this FTx is discarded, non-secure read returns 0.
When EXTI_PRIVCFGR.PRIVx is disabled, FTx can be accessed with unprivileged and privileged access.
When EXTI_PRIVCFGR.PRIVx is enabled, FTx can only be accessed with privileged access. Unprivileged write to this FTx is discarded, unprivileged read returns 0.</description>
                <bitOffset>6</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Falling trigger disabled (for event and Interrupt) for input line</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Falling trigger enabled (for event and Interrupt) for input line.</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>FT7</name>
                <description>Falling trigger event configuration bit of configurable event input x
When EXTI_SECCFGR.SECx is disabled, FTx can be accessed with non-secure and secure access.
When EXTI_SECCFGR.SECx is enabled, FTx can only be accessed with secure access. Non-secure write to this FTx is discarded, non-secure read returns 0.
When EXTI_PRIVCFGR.PRIVx is disabled, FTx can be accessed with unprivileged and privileged access.
When EXTI_PRIVCFGR.PRIVx is enabled, FTx can only be accessed with privileged access. Unprivileged write to this FTx is discarded, unprivileged read returns 0.</description>
                <bitOffset>7</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Falling trigger disabled (for event and Interrupt) for input line</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Falling trigger enabled (for event and Interrupt) for input line.</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>FT8</name>
                <description>Falling trigger event configuration bit of configurable event input x
When EXTI_SECCFGR.SECx is disabled, FTx can be accessed with non-secure and secure access.
When EXTI_SECCFGR.SECx is enabled, FTx can only be accessed with secure access. Non-secure write to this FTx is discarded, non-secure read returns 0.
When EXTI_PRIVCFGR.PRIVx is disabled, FTx can be accessed with unprivileged and privileged access.
When EXTI_PRIVCFGR.PRIVx is enabled, FTx can only be accessed with privileged access. Unprivileged write to this FTx is discarded, unprivileged read returns 0.</description>
                <bitOffset>8</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Falling trigger disabled (for event and Interrupt) for input line</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Falling trigger enabled (for event and Interrupt) for input line.</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>FT9</name>
                <description>Falling trigger event configuration bit of configurable event input x
When EXTI_SECCFGR.SECx is disabled, FTx can be accessed with non-secure and secure access.
When EXTI_SECCFGR.SECx is enabled, FTx can only be accessed with secure access. Non-secure write to this FTx is discarded, non-secure read returns 0.
When EXTI_PRIVCFGR.PRIVx is disabled, FTx can be accessed with unprivileged and privileged access.
When EXTI_PRIVCFGR.PRIVx is enabled, FTx can only be accessed with privileged access. Unprivileged write to this FTx is discarded, unprivileged read returns 0.</description>
                <bitOffset>9</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Falling trigger disabled (for event and Interrupt) for input line</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Falling trigger enabled (for event and Interrupt) for input line.</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>FT10</name>
                <description>Falling trigger event configuration bit of configurable event input x
When EXTI_SECCFGR.SECx is disabled, FTx can be accessed with non-secure and secure access.
When EXTI_SECCFGR.SECx is enabled, FTx can only be accessed with secure access. Non-secure write to this FTx is discarded, non-secure read returns 0.
When EXTI_PRIVCFGR.PRIVx is disabled, FTx can be accessed with unprivileged and privileged access.
When EXTI_PRIVCFGR.PRIVx is enabled, FTx can only be accessed with privileged access. Unprivileged write to this FTx is discarded, unprivileged read returns 0.</description>
                <bitOffset>10</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Falling trigger disabled (for event and Interrupt) for input line</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Falling trigger enabled (for event and Interrupt) for input line.</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>FT11</name>
                <description>Falling trigger event configuration bit of configurable event input x
When EXTI_SECCFGR.SECx is disabled, FTx can be accessed with non-secure and secure access.
When EXTI_SECCFGR.SECx is enabled, FTx can only be accessed with secure access. Non-secure write to this FTx is discarded, non-secure read returns 0.
When EXTI_PRIVCFGR.PRIVx is disabled, FTx can be accessed with unprivileged and privileged access.
When EXTI_PRIVCFGR.PRIVx is enabled, FTx can only be accessed with privileged access. Unprivileged write to this FTx is discarded, unprivileged read returns 0.</description>
                <bitOffset>11</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Falling trigger disabled (for event and Interrupt) for input line</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Falling trigger enabled (for event and Interrupt) for input line.</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>FT12</name>
                <description>Falling trigger event configuration bit of configurable event input x
When EXTI_SECCFGR.SECx is disabled, FTx can be accessed with non-secure and secure access.
When EXTI_SECCFGR.SECx is enabled, FTx can only be accessed with secure access. Non-secure write to this FTx is discarded, non-secure read returns 0.
When EXTI_PRIVCFGR.PRIVx is disabled, FTx can be accessed with unprivileged and privileged access.
When EXTI_PRIVCFGR.PRIVx is enabled, FTx can only be accessed with privileged access. Unprivileged write to this FTx is discarded, unprivileged read returns 0.</description>
                <bitOffset>12</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Falling trigger disabled (for event and Interrupt) for input line</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Falling trigger enabled (for event and Interrupt) for input line.</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>FT13</name>
                <description>Falling trigger event configuration bit of configurable event input x
When EXTI_SECCFGR.SECx is disabled, FTx can be accessed with non-secure and secure access.
When EXTI_SECCFGR.SECx is enabled, FTx can only be accessed with secure access. Non-secure write to this FTx is discarded, non-secure read returns 0.
When EXTI_PRIVCFGR.PRIVx is disabled, FTx can be accessed with unprivileged and privileged access.
When EXTI_PRIVCFGR.PRIVx is enabled, FTx can only be accessed with privileged access. Unprivileged write to this FTx is discarded, unprivileged read returns 0.</description>
                <bitOffset>13</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Falling trigger disabled (for event and Interrupt) for input line</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Falling trigger enabled (for event and Interrupt) for input line.</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>FT14</name>
                <description>Falling trigger event configuration bit of configurable event input x
When EXTI_SECCFGR.SECx is disabled, FTx can be accessed with non-secure and secure access.
When EXTI_SECCFGR.SECx is enabled, FTx can only be accessed with secure access. Non-secure write to this FTx is discarded, non-secure read returns 0.
When EXTI_PRIVCFGR.PRIVx is disabled, FTx can be accessed with unprivileged and privileged access.
When EXTI_PRIVCFGR.PRIVx is enabled, FTx can only be accessed with privileged access. Unprivileged write to this FTx is discarded, unprivileged read returns 0.</description>
                <bitOffset>14</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Falling trigger disabled (for event and Interrupt) for input line</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Falling trigger enabled (for event and Interrupt) for input line.</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>FT15</name>
                <description>Falling trigger event configuration bit of configurable event input x
When EXTI_SECCFGR.SECx is disabled, FTx can be accessed with non-secure and secure access.
When EXTI_SECCFGR.SECx is enabled, FTx can only be accessed with secure access. Non-secure write to this FTx is discarded, non-secure read returns 0.
When EXTI_PRIVCFGR.PRIVx is disabled, FTx can be accessed with unprivileged and privileged access.
When EXTI_PRIVCFGR.PRIVx is enabled, FTx can only be accessed with privileged access. Unprivileged write to this FTx is discarded, unprivileged read returns 0.</description>
                <bitOffset>15</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Falling trigger disabled (for event and Interrupt) for input line</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Falling trigger enabled (for event and Interrupt) for input line.</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>FT16</name>
                <description>Falling trigger event configuration bit of configurable event input x
When EXTI_SECCFGR.SECx is disabled, FTx can be accessed with non-secure and secure access.
When EXTI_SECCFGR.SECx is enabled, FTx can only be accessed with secure access. Non-secure write to this FTx is discarded, non-secure read returns 0.
When EXTI_PRIVCFGR.PRIVx is disabled, FTx can be accessed with unprivileged and privileged access.
When EXTI_PRIVCFGR.PRIVx is enabled, FTx can only be accessed with privileged access. Unprivileged write to this FTx is discarded, unprivileged read returns 0.</description>
                <bitOffset>16</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Falling trigger disabled (for event and Interrupt) for input line</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Falling trigger enabled (for event and Interrupt) for input line.</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
            </fields>
          </register>
          <register>
            <name>EXTI_SWIER1</name>
            <displayName>EXTI_SWIER1</displayName>
            <description>EXTI software interrupt event register</description>
            <addressOffset>0x008</addressOffset>
            <size>0x20</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>SWI0</name>
                <description>Software interrupt on event x
When EXTI_SECFGR.SECx is disabled, SWIx can be accessed with non-secure and secure access.
When EXTI_SECCFGR.SECx is enabled, SWIx can only be accessed with secure access. Non-secure write to this SWI x is discarded, non-secure read returns 0.
When EXTI_PRIVCFGR.PRIVx is disabled, SWIx can be accessed with unprivileged and privileged access.
When EXTI_PRIVCFGR.PRIVx is enabled, SWIx can only be accessed with privileged access. Unprivileged write to this SWIx is discarded, unprivileged read returns 0.
A software interrupt is generated independently from the setting in EXTI_RTSR and EXTI_FTSR. It always returns 0 when read.</description>
                <bitOffset>0</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Writing 0 has no effect.</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Writing 1 triggers a rising edge event on event x. This bit is auto cleared by hardware.</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>SWI1</name>
                <description>Software interrupt on event x
When EXTI_SECFGR.SECx is disabled, SWIx can be accessed with non-secure and secure access.
When EXTI_SECCFGR.SECx is enabled, SWIx can only be accessed with secure access. Non-secure write to this SWI x is discarded, non-secure read returns 0.
When EXTI_PRIVCFGR.PRIVx is disabled, SWIx can be accessed with unprivileged and privileged access.
When EXTI_PRIVCFGR.PRIVx is enabled, SWIx can only be accessed with privileged access. Unprivileged write to this SWIx is discarded, unprivileged read returns 0.
A software interrupt is generated independently from the setting in EXTI_RTSR and EXTI_FTSR. It always returns 0 when read.</description>
                <bitOffset>1</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Writing 0 has no effect.</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Writing 1 triggers a rising edge event on event x. This bit is auto cleared by hardware.</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>SWI2</name>
                <description>Software interrupt on event x
When EXTI_SECFGR.SECx is disabled, SWIx can be accessed with non-secure and secure access.
When EXTI_SECCFGR.SECx is enabled, SWIx can only be accessed with secure access. Non-secure write to this SWI x is discarded, non-secure read returns 0.
When EXTI_PRIVCFGR.PRIVx is disabled, SWIx can be accessed with unprivileged and privileged access.
When EXTI_PRIVCFGR.PRIVx is enabled, SWIx can only be accessed with privileged access. Unprivileged write to this SWIx is discarded, unprivileged read returns 0.
A software interrupt is generated independently from the setting in EXTI_RTSR and EXTI_FTSR. It always returns 0 when read.</description>
                <bitOffset>2</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Writing 0 has no effect.</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Writing 1 triggers a rising edge event on event x. This bit is auto cleared by hardware.</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>SWI3</name>
                <description>Software interrupt on event x
When EXTI_SECFGR.SECx is disabled, SWIx can be accessed with non-secure and secure access.
When EXTI_SECCFGR.SECx is enabled, SWIx can only be accessed with secure access. Non-secure write to this SWI x is discarded, non-secure read returns 0.
When EXTI_PRIVCFGR.PRIVx is disabled, SWIx can be accessed with unprivileged and privileged access.
When EXTI_PRIVCFGR.PRIVx is enabled, SWIx can only be accessed with privileged access. Unprivileged write to this SWIx is discarded, unprivileged read returns 0.
A software interrupt is generated independently from the setting in EXTI_RTSR and EXTI_FTSR. It always returns 0 when read.</description>
                <bitOffset>3</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Writing 0 has no effect.</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Writing 1 triggers a rising edge event on event x. This bit is auto cleared by hardware.</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>SWI4</name>
                <description>Software interrupt on event x
When EXTI_SECFGR.SECx is disabled, SWIx can be accessed with non-secure and secure access.
When EXTI_SECCFGR.SECx is enabled, SWIx can only be accessed with secure access. Non-secure write to this SWI x is discarded, non-secure read returns 0.
When EXTI_PRIVCFGR.PRIVx is disabled, SWIx can be accessed with unprivileged and privileged access.
When EXTI_PRIVCFGR.PRIVx is enabled, SWIx can only be accessed with privileged access. Unprivileged write to this SWIx is discarded, unprivileged read returns 0.
A software interrupt is generated independently from the setting in EXTI_RTSR and EXTI_FTSR. It always returns 0 when read.</description>
                <bitOffset>4</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Writing 0 has no effect.</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Writing 1 triggers a rising edge event on event x. This bit is auto cleared by hardware.</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>SWI5</name>
                <description>Software interrupt on event x
When EXTI_SECFGR.SECx is disabled, SWIx can be accessed with non-secure and secure access.
When EXTI_SECCFGR.SECx is enabled, SWIx can only be accessed with secure access. Non-secure write to this SWI x is discarded, non-secure read returns 0.
When EXTI_PRIVCFGR.PRIVx is disabled, SWIx can be accessed with unprivileged and privileged access.
When EXTI_PRIVCFGR.PRIVx is enabled, SWIx can only be accessed with privileged access. Unprivileged write to this SWIx is discarded, unprivileged read returns 0.
A software interrupt is generated independently from the setting in EXTI_RTSR and EXTI_FTSR. It always returns 0 when read.</description>
                <bitOffset>5</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Writing 0 has no effect.</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Writing 1 triggers a rising edge event on event x. This bit is auto cleared by hardware.</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>SWI6</name>
                <description>Software interrupt on event x
When EXTI_SECFGR.SECx is disabled, SWIx can be accessed with non-secure and secure access.
When EXTI_SECCFGR.SECx is enabled, SWIx can only be accessed with secure access. Non-secure write to this SWI x is discarded, non-secure read returns 0.
When EXTI_PRIVCFGR.PRIVx is disabled, SWIx can be accessed with unprivileged and privileged access.
When EXTI_PRIVCFGR.PRIVx is enabled, SWIx can only be accessed with privileged access. Unprivileged write to this SWIx is discarded, unprivileged read returns 0.
A software interrupt is generated independently from the setting in EXTI_RTSR and EXTI_FTSR. It always returns 0 when read.</description>
                <bitOffset>6</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Writing 0 has no effect.</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Writing 1 triggers a rising edge event on event x. This bit is auto cleared by hardware.</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>SWI7</name>
                <description>Software interrupt on event x
When EXTI_SECFGR.SECx is disabled, SWIx can be accessed with non-secure and secure access.
When EXTI_SECCFGR.SECx is enabled, SWIx can only be accessed with secure access. Non-secure write to this SWI x is discarded, non-secure read returns 0.
When EXTI_PRIVCFGR.PRIVx is disabled, SWIx can be accessed with unprivileged and privileged access.
When EXTI_PRIVCFGR.PRIVx is enabled, SWIx can only be accessed with privileged access. Unprivileged write to this SWIx is discarded, unprivileged read returns 0.
A software interrupt is generated independently from the setting in EXTI_RTSR and EXTI_FTSR. It always returns 0 when read.</description>
                <bitOffset>7</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Writing 0 has no effect.</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Writing 1 triggers a rising edge event on event x. This bit is auto cleared by hardware.</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>SWI8</name>
                <description>Software interrupt on event x
When EXTI_SECFGR.SECx is disabled, SWIx can be accessed with non-secure and secure access.
When EXTI_SECCFGR.SECx is enabled, SWIx can only be accessed with secure access. Non-secure write to this SWI x is discarded, non-secure read returns 0.
When EXTI_PRIVCFGR.PRIVx is disabled, SWIx can be accessed with unprivileged and privileged access.
When EXTI_PRIVCFGR.PRIVx is enabled, SWIx can only be accessed with privileged access. Unprivileged write to this SWIx is discarded, unprivileged read returns 0.
A software interrupt is generated independently from the setting in EXTI_RTSR and EXTI_FTSR. It always returns 0 when read.</description>
                <bitOffset>8</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Writing 0 has no effect.</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Writing 1 triggers a rising edge event on event x. This bit is auto cleared by hardware.</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>SWI9</name>
                <description>Software interrupt on event x
When EXTI_SECFGR.SECx is disabled, SWIx can be accessed with non-secure and secure access.
When EXTI_SECCFGR.SECx is enabled, SWIx can only be accessed with secure access. Non-secure write to this SWI x is discarded, non-secure read returns 0.
When EXTI_PRIVCFGR.PRIVx is disabled, SWIx can be accessed with unprivileged and privileged access.
When EXTI_PRIVCFGR.PRIVx is enabled, SWIx can only be accessed with privileged access. Unprivileged write to this SWIx is discarded, unprivileged read returns 0.
A software interrupt is generated independently from the setting in EXTI_RTSR and EXTI_FTSR. It always returns 0 when read.</description>
                <bitOffset>9</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Writing 0 has no effect.</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Writing 1 triggers a rising edge event on event x. This bit is auto cleared by hardware.</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>SWI10</name>
                <description>Software interrupt on event x
When EXTI_SECFGR.SECx is disabled, SWIx can be accessed with non-secure and secure access.
When EXTI_SECCFGR.SECx is enabled, SWIx can only be accessed with secure access. Non-secure write to this SWI x is discarded, non-secure read returns 0.
When EXTI_PRIVCFGR.PRIVx is disabled, SWIx can be accessed with unprivileged and privileged access.
When EXTI_PRIVCFGR.PRIVx is enabled, SWIx can only be accessed with privileged access. Unprivileged write to this SWIx is discarded, unprivileged read returns 0.
A software interrupt is generated independently from the setting in EXTI_RTSR and EXTI_FTSR. It always returns 0 when read.</description>
                <bitOffset>10</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Writing 0 has no effect.</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Writing 1 triggers a rising edge event on event x. This bit is auto cleared by hardware.</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>SWI11</name>
                <description>Software interrupt on event x
When EXTI_SECFGR.SECx is disabled, SWIx can be accessed with non-secure and secure access.
When EXTI_SECCFGR.SECx is enabled, SWIx can only be accessed with secure access. Non-secure write to this SWI x is discarded, non-secure read returns 0.
When EXTI_PRIVCFGR.PRIVx is disabled, SWIx can be accessed with unprivileged and privileged access.
When EXTI_PRIVCFGR.PRIVx is enabled, SWIx can only be accessed with privileged access. Unprivileged write to this SWIx is discarded, unprivileged read returns 0.
A software interrupt is generated independently from the setting in EXTI_RTSR and EXTI_FTSR. It always returns 0 when read.</description>
                <bitOffset>11</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Writing 0 has no effect.</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Writing 1 triggers a rising edge event on event x. This bit is auto cleared by hardware.</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>SWI12</name>
                <description>Software interrupt on event x
When EXTI_SECFGR.SECx is disabled, SWIx can be accessed with non-secure and secure access.
When EXTI_SECCFGR.SECx is enabled, SWIx can only be accessed with secure access. Non-secure write to this SWI x is discarded, non-secure read returns 0.
When EXTI_PRIVCFGR.PRIVx is disabled, SWIx can be accessed with unprivileged and privileged access.
When EXTI_PRIVCFGR.PRIVx is enabled, SWIx can only be accessed with privileged access. Unprivileged write to this SWIx is discarded, unprivileged read returns 0.
A software interrupt is generated independently from the setting in EXTI_RTSR and EXTI_FTSR. It always returns 0 when read.</description>
                <bitOffset>12</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Writing 0 has no effect.</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Writing 1 triggers a rising edge event on event x. This bit is auto cleared by hardware.</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>SWI13</name>
                <description>Software interrupt on event x
When EXTI_SECFGR.SECx is disabled, SWIx can be accessed with non-secure and secure access.
When EXTI_SECCFGR.SECx is enabled, SWIx can only be accessed with secure access. Non-secure write to this SWI x is discarded, non-secure read returns 0.
When EXTI_PRIVCFGR.PRIVx is disabled, SWIx can be accessed with unprivileged and privileged access.
When EXTI_PRIVCFGR.PRIVx is enabled, SWIx can only be accessed with privileged access. Unprivileged write to this SWIx is discarded, unprivileged read returns 0.
A software interrupt is generated independently from the setting in EXTI_RTSR and EXTI_FTSR. It always returns 0 when read.</description>
                <bitOffset>13</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Writing 0 has no effect.</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Writing 1 triggers a rising edge event on event x. This bit is auto cleared by hardware.</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>SWI14</name>
                <description>Software interrupt on event x
When EXTI_SECFGR.SECx is disabled, SWIx can be accessed with non-secure and secure access.
When EXTI_SECCFGR.SECx is enabled, SWIx can only be accessed with secure access. Non-secure write to this SWI x is discarded, non-secure read returns 0.
When EXTI_PRIVCFGR.PRIVx is disabled, SWIx can be accessed with unprivileged and privileged access.
When EXTI_PRIVCFGR.PRIVx is enabled, SWIx can only be accessed with privileged access. Unprivileged write to this SWIx is discarded, unprivileged read returns 0.
A software interrupt is generated independently from the setting in EXTI_RTSR and EXTI_FTSR. It always returns 0 when read.</description>
                <bitOffset>14</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Writing 0 has no effect.</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Writing 1 triggers a rising edge event on event x. This bit is auto cleared by hardware.</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>SWI15</name>
                <description>Software interrupt on event x
When EXTI_SECFGR.SECx is disabled, SWIx can be accessed with non-secure and secure access.
When EXTI_SECCFGR.SECx is enabled, SWIx can only be accessed with secure access. Non-secure write to this SWI x is discarded, non-secure read returns 0.
When EXTI_PRIVCFGR.PRIVx is disabled, SWIx can be accessed with unprivileged and privileged access.
When EXTI_PRIVCFGR.PRIVx is enabled, SWIx can only be accessed with privileged access. Unprivileged write to this SWIx is discarded, unprivileged read returns 0.
A software interrupt is generated independently from the setting in EXTI_RTSR and EXTI_FTSR. It always returns 0 when read.</description>
                <bitOffset>15</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Writing 0 has no effect.</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Writing 1 triggers a rising edge event on event x. This bit is auto cleared by hardware.</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>SWI16</name>
                <description>Software interrupt on event x
When EXTI_SECFGR.SECx is disabled, SWIx can be accessed with non-secure and secure access.
When EXTI_SECCFGR.SECx is enabled, SWIx can only be accessed with secure access. Non-secure write to this SWI x is discarded, non-secure read returns 0.
When EXTI_PRIVCFGR.PRIVx is disabled, SWIx can be accessed with unprivileged and privileged access.
When EXTI_PRIVCFGR.PRIVx is enabled, SWIx can only be accessed with privileged access. Unprivileged write to this SWIx is discarded, unprivileged read returns 0.
A software interrupt is generated independently from the setting in EXTI_RTSR and EXTI_FTSR. It always returns 0 when read.</description>
                <bitOffset>16</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Writing 0 has no effect.</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Writing 1 triggers a rising edge event on event x. This bit is auto cleared by hardware.</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
            </fields>
          </register>
          <register>
            <name>EXTI_RPR1</name>
            <displayName>EXTI_RPR1</displayName>
            <description>EXTI rising edge pending register</description>
            <addressOffset>0x00C</addressOffset>
            <size>0x20</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>RPIF0</name>
                <description>configurable event inputs x rising edge pending bit
When EXTI_SECCFGR.SECx is disabled, RPIFx can be accessed with non-secure and secure access.
When EXTI_SECCFGR.SECx is enabled, RPIFx can only be accessed with secure access. Non-secure write to this RPIFx is discarded, non-secure read returns 0.
When EXTI_PRIVCFGR.PRIVx is disabled, RPIFx can be accessed with unprivileged and privileged access.
When EXTI_PRIVCFGR.PRIVx is enabled, RPIFx can only be accessed with privileged access. Unprivileged write to this RPIFx is discarded, unprivileged read returns 0.
This bit is set when the rising edge event or an EXTI_SWIER software trigger arrives on the configurable event line. This bit is cleared by writing 1 to it.</description>
                <bitOffset>0</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>No rising edge trigger request occurred</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Rising edge trigger request occurred</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>RPIF1</name>
                <description>configurable event inputs x rising edge pending bit
When EXTI_SECCFGR.SECx is disabled, RPIFx can be accessed with non-secure and secure access.
When EXTI_SECCFGR.SECx is enabled, RPIFx can only be accessed with secure access. Non-secure write to this RPIFx is discarded, non-secure read returns 0.
When EXTI_PRIVCFGR.PRIVx is disabled, RPIFx can be accessed with unprivileged and privileged access.
When EXTI_PRIVCFGR.PRIVx is enabled, RPIFx can only be accessed with privileged access. Unprivileged write to this RPIFx is discarded, unprivileged read returns 0.
This bit is set when the rising edge event or an EXTI_SWIER software trigger arrives on the configurable event line. This bit is cleared by writing 1 to it.</description>
                <bitOffset>1</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>No rising edge trigger request occurred</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Rising edge trigger request occurred</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>RPIF2</name>
                <description>configurable event inputs x rising edge pending bit
When EXTI_SECCFGR.SECx is disabled, RPIFx can be accessed with non-secure and secure access.
When EXTI_SECCFGR.SECx is enabled, RPIFx can only be accessed with secure access. Non-secure write to this RPIFx is discarded, non-secure read returns 0.
When EXTI_PRIVCFGR.PRIVx is disabled, RPIFx can be accessed with unprivileged and privileged access.
When EXTI_PRIVCFGR.PRIVx is enabled, RPIFx can only be accessed with privileged access. Unprivileged write to this RPIFx is discarded, unprivileged read returns 0.
This bit is set when the rising edge event or an EXTI_SWIER software trigger arrives on the configurable event line. This bit is cleared by writing 1 to it.</description>
                <bitOffset>2</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>No rising edge trigger request occurred</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Rising edge trigger request occurred</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>RPIF3</name>
                <description>configurable event inputs x rising edge pending bit
When EXTI_SECCFGR.SECx is disabled, RPIFx can be accessed with non-secure and secure access.
When EXTI_SECCFGR.SECx is enabled, RPIFx can only be accessed with secure access. Non-secure write to this RPIFx is discarded, non-secure read returns 0.
When EXTI_PRIVCFGR.PRIVx is disabled, RPIFx can be accessed with unprivileged and privileged access.
When EXTI_PRIVCFGR.PRIVx is enabled, RPIFx can only be accessed with privileged access. Unprivileged write to this RPIFx is discarded, unprivileged read returns 0.
This bit is set when the rising edge event or an EXTI_SWIER software trigger arrives on the configurable event line. This bit is cleared by writing 1 to it.</description>
                <bitOffset>3</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>No rising edge trigger request occurred</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Rising edge trigger request occurred</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>RPIF4</name>
                <description>configurable event inputs x rising edge pending bit
When EXTI_SECCFGR.SECx is disabled, RPIFx can be accessed with non-secure and secure access.
When EXTI_SECCFGR.SECx is enabled, RPIFx can only be accessed with secure access. Non-secure write to this RPIFx is discarded, non-secure read returns 0.
When EXTI_PRIVCFGR.PRIVx is disabled, RPIFx can be accessed with unprivileged and privileged access.
When EXTI_PRIVCFGR.PRIVx is enabled, RPIFx can only be accessed with privileged access. Unprivileged write to this RPIFx is discarded, unprivileged read returns 0.
This bit is set when the rising edge event or an EXTI_SWIER software trigger arrives on the configurable event line. This bit is cleared by writing 1 to it.</description>
                <bitOffset>4</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>No rising edge trigger request occurred</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Rising edge trigger request occurred</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>RPIF5</name>
                <description>configurable event inputs x rising edge pending bit
When EXTI_SECCFGR.SECx is disabled, RPIFx can be accessed with non-secure and secure access.
When EXTI_SECCFGR.SECx is enabled, RPIFx can only be accessed with secure access. Non-secure write to this RPIFx is discarded, non-secure read returns 0.
When EXTI_PRIVCFGR.PRIVx is disabled, RPIFx can be accessed with unprivileged and privileged access.
When EXTI_PRIVCFGR.PRIVx is enabled, RPIFx can only be accessed with privileged access. Unprivileged write to this RPIFx is discarded, unprivileged read returns 0.
This bit is set when the rising edge event or an EXTI_SWIER software trigger arrives on the configurable event line. This bit is cleared by writing 1 to it.</description>
                <bitOffset>5</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>No rising edge trigger request occurred</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Rising edge trigger request occurred</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>RPIF6</name>
                <description>configurable event inputs x rising edge pending bit
When EXTI_SECCFGR.SECx is disabled, RPIFx can be accessed with non-secure and secure access.
When EXTI_SECCFGR.SECx is enabled, RPIFx can only be accessed with secure access. Non-secure write to this RPIFx is discarded, non-secure read returns 0.
When EXTI_PRIVCFGR.PRIVx is disabled, RPIFx can be accessed with unprivileged and privileged access.
When EXTI_PRIVCFGR.PRIVx is enabled, RPIFx can only be accessed with privileged access. Unprivileged write to this RPIFx is discarded, unprivileged read returns 0.
This bit is set when the rising edge event or an EXTI_SWIER software trigger arrives on the configurable event line. This bit is cleared by writing 1 to it.</description>
                <bitOffset>6</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>No rising edge trigger request occurred</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Rising edge trigger request occurred</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>RPIF7</name>
                <description>configurable event inputs x rising edge pending bit
When EXTI_SECCFGR.SECx is disabled, RPIFx can be accessed with non-secure and secure access.
When EXTI_SECCFGR.SECx is enabled, RPIFx can only be accessed with secure access. Non-secure write to this RPIFx is discarded, non-secure read returns 0.
When EXTI_PRIVCFGR.PRIVx is disabled, RPIFx can be accessed with unprivileged and privileged access.
When EXTI_PRIVCFGR.PRIVx is enabled, RPIFx can only be accessed with privileged access. Unprivileged write to this RPIFx is discarded, unprivileged read returns 0.
This bit is set when the rising edge event or an EXTI_SWIER software trigger arrives on the configurable event line. This bit is cleared by writing 1 to it.</description>
                <bitOffset>7</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>No rising edge trigger request occurred</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Rising edge trigger request occurred</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>RPIF8</name>
                <description>configurable event inputs x rising edge pending bit
When EXTI_SECCFGR.SECx is disabled, RPIFx can be accessed with non-secure and secure access.
When EXTI_SECCFGR.SECx is enabled, RPIFx can only be accessed with secure access. Non-secure write to this RPIFx is discarded, non-secure read returns 0.
When EXTI_PRIVCFGR.PRIVx is disabled, RPIFx can be accessed with unprivileged and privileged access.
When EXTI_PRIVCFGR.PRIVx is enabled, RPIFx can only be accessed with privileged access. Unprivileged write to this RPIFx is discarded, unprivileged read returns 0.
This bit is set when the rising edge event or an EXTI_SWIER software trigger arrives on the configurable event line. This bit is cleared by writing 1 to it.</description>
                <bitOffset>8</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>No rising edge trigger request occurred</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Rising edge trigger request occurred</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>RPIF9</name>
                <description>configurable event inputs x rising edge pending bit
When EXTI_SECCFGR.SECx is disabled, RPIFx can be accessed with non-secure and secure access.
When EXTI_SECCFGR.SECx is enabled, RPIFx can only be accessed with secure access. Non-secure write to this RPIFx is discarded, non-secure read returns 0.
When EXTI_PRIVCFGR.PRIVx is disabled, RPIFx can be accessed with unprivileged and privileged access.
When EXTI_PRIVCFGR.PRIVx is enabled, RPIFx can only be accessed with privileged access. Unprivileged write to this RPIFx is discarded, unprivileged read returns 0.
This bit is set when the rising edge event or an EXTI_SWIER software trigger arrives on the configurable event line. This bit is cleared by writing 1 to it.</description>
                <bitOffset>9</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>No rising edge trigger request occurred</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Rising edge trigger request occurred</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>RPIF10</name>
                <description>configurable event inputs x rising edge pending bit
When EXTI_SECCFGR.SECx is disabled, RPIFx can be accessed with non-secure and secure access.
When EXTI_SECCFGR.SECx is enabled, RPIFx can only be accessed with secure access. Non-secure write to this RPIFx is discarded, non-secure read returns 0.
When EXTI_PRIVCFGR.PRIVx is disabled, RPIFx can be accessed with unprivileged and privileged access.
When EXTI_PRIVCFGR.PRIVx is enabled, RPIFx can only be accessed with privileged access. Unprivileged write to this RPIFx is discarded, unprivileged read returns 0.
This bit is set when the rising edge event or an EXTI_SWIER software trigger arrives on the configurable event line. This bit is cleared by writing 1 to it.</description>
                <bitOffset>10</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>No rising edge trigger request occurred</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Rising edge trigger request occurred</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>RPIF11</name>
                <description>configurable event inputs x rising edge pending bit
When EXTI_SECCFGR.SECx is disabled, RPIFx can be accessed with non-secure and secure access.
When EXTI_SECCFGR.SECx is enabled, RPIFx can only be accessed with secure access. Non-secure write to this RPIFx is discarded, non-secure read returns 0.
When EXTI_PRIVCFGR.PRIVx is disabled, RPIFx can be accessed with unprivileged and privileged access.
When EXTI_PRIVCFGR.PRIVx is enabled, RPIFx can only be accessed with privileged access. Unprivileged write to this RPIFx is discarded, unprivileged read returns 0.
This bit is set when the rising edge event or an EXTI_SWIER software trigger arrives on the configurable event line. This bit is cleared by writing 1 to it.</description>
                <bitOffset>11</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>No rising edge trigger request occurred</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Rising edge trigger request occurred</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>RPIF12</name>
                <description>configurable event inputs x rising edge pending bit
When EXTI_SECCFGR.SECx is disabled, RPIFx can be accessed with non-secure and secure access.
When EXTI_SECCFGR.SECx is enabled, RPIFx can only be accessed with secure access. Non-secure write to this RPIFx is discarded, non-secure read returns 0.
When EXTI_PRIVCFGR.PRIVx is disabled, RPIFx can be accessed with unprivileged and privileged access.
When EXTI_PRIVCFGR.PRIVx is enabled, RPIFx can only be accessed with privileged access. Unprivileged write to this RPIFx is discarded, unprivileged read returns 0.
This bit is set when the rising edge event or an EXTI_SWIER software trigger arrives on the configurable event line. This bit is cleared by writing 1 to it.</description>
                <bitOffset>12</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>No rising edge trigger request occurred</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Rising edge trigger request occurred</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>RPIF13</name>
                <description>configurable event inputs x rising edge pending bit
When EXTI_SECCFGR.SECx is disabled, RPIFx can be accessed with non-secure and secure access.
When EXTI_SECCFGR.SECx is enabled, RPIFx can only be accessed with secure access. Non-secure write to this RPIFx is discarded, non-secure read returns 0.
When EXTI_PRIVCFGR.PRIVx is disabled, RPIFx can be accessed with unprivileged and privileged access.
When EXTI_PRIVCFGR.PRIVx is enabled, RPIFx can only be accessed with privileged access. Unprivileged write to this RPIFx is discarded, unprivileged read returns 0.
This bit is set when the rising edge event or an EXTI_SWIER software trigger arrives on the configurable event line. This bit is cleared by writing 1 to it.</description>
                <bitOffset>13</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>No rising edge trigger request occurred</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Rising edge trigger request occurred</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>RPIF14</name>
                <description>configurable event inputs x rising edge pending bit
When EXTI_SECCFGR.SECx is disabled, RPIFx can be accessed with non-secure and secure access.
When EXTI_SECCFGR.SECx is enabled, RPIFx can only be accessed with secure access. Non-secure write to this RPIFx is discarded, non-secure read returns 0.
When EXTI_PRIVCFGR.PRIVx is disabled, RPIFx can be accessed with unprivileged and privileged access.
When EXTI_PRIVCFGR.PRIVx is enabled, RPIFx can only be accessed with privileged access. Unprivileged write to this RPIFx is discarded, unprivileged read returns 0.
This bit is set when the rising edge event or an EXTI_SWIER software trigger arrives on the configurable event line. This bit is cleared by writing 1 to it.</description>
                <bitOffset>14</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>No rising edge trigger request occurred</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Rising edge trigger request occurred</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>RPIF15</name>
                <description>configurable event inputs x rising edge pending bit
When EXTI_SECCFGR.SECx is disabled, RPIFx can be accessed with non-secure and secure access.
When EXTI_SECCFGR.SECx is enabled, RPIFx can only be accessed with secure access. Non-secure write to this RPIFx is discarded, non-secure read returns 0.
When EXTI_PRIVCFGR.PRIVx is disabled, RPIFx can be accessed with unprivileged and privileged access.
When EXTI_PRIVCFGR.PRIVx is enabled, RPIFx can only be accessed with privileged access. Unprivileged write to this RPIFx is discarded, unprivileged read returns 0.
This bit is set when the rising edge event or an EXTI_SWIER software trigger arrives on the configurable event line. This bit is cleared by writing 1 to it.</description>
                <bitOffset>15</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>No rising edge trigger request occurred</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Rising edge trigger request occurred</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>RPIF16</name>
                <description>configurable event inputs x rising edge pending bit
When EXTI_SECCFGR.SECx is disabled, RPIFx can be accessed with non-secure and secure access.
When EXTI_SECCFGR.SECx is enabled, RPIFx can only be accessed with secure access. Non-secure write to this RPIFx is discarded, non-secure read returns 0.
When EXTI_PRIVCFGR.PRIVx is disabled, RPIFx can be accessed with unprivileged and privileged access.
When EXTI_PRIVCFGR.PRIVx is enabled, RPIFx can only be accessed with privileged access. Unprivileged write to this RPIFx is discarded, unprivileged read returns 0.
This bit is set when the rising edge event or an EXTI_SWIER software trigger arrives on the configurable event line. This bit is cleared by writing 1 to it.</description>
                <bitOffset>16</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>No rising edge trigger request occurred</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Rising edge trigger request occurred</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
            </fields>
          </register>
          <register>
            <name>EXTI_FPR1</name>
            <displayName>EXTI_FPR1</displayName>
            <description>EXTI falling edge pending register</description>
            <addressOffset>0x010</addressOffset>
            <size>0x20</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>FPIF0</name>
                <description>configurable event inputs x falling edge pending bit
When EXTI_SECCFGR.SECx is disabled, FPIFx can be accessed with non-secure and secure access.
When EXTI_SECCFGR.SECx is enabled, FPIFx can only be accessed with secure access. Non-secure write to this FPIFx is discarded, non-secure read returns 0.
When EXTI_PRIVCFGR.PRIVx is disabled, FPIFx can be accessed with unprivileged and privileged access.
When EXTI_PRIVCFGR.PRIVx is enabled, FPIFx can only be accessed with privileged access. Unprivileged write to this FPIFx is discarded, unprivileged read returns 0.
This bit is set when the falling edge event arrives on the configurable event line. This bit is cleared by writing 1 to it.</description>
                <bitOffset>0</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>No falling edge trigger request occurred</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Falling edge trigger request occurred</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>FPIF1</name>
                <description>configurable event inputs x falling edge pending bit
When EXTI_SECCFGR.SECx is disabled, FPIFx can be accessed with non-secure and secure access.
When EXTI_SECCFGR.SECx is enabled, FPIFx can only be accessed with secure access. Non-secure write to this FPIFx is discarded, non-secure read returns 0.
When EXTI_PRIVCFGR.PRIVx is disabled, FPIFx can be accessed with unprivileged and privileged access.
When EXTI_PRIVCFGR.PRIVx is enabled, FPIFx can only be accessed with privileged access. Unprivileged write to this FPIFx is discarded, unprivileged read returns 0.
This bit is set when the falling edge event arrives on the configurable event line. This bit is cleared by writing 1 to it.</description>
                <bitOffset>1</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>No falling edge trigger request occurred</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Falling edge trigger request occurred</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>FPIF2</name>
                <description>configurable event inputs x falling edge pending bit
When EXTI_SECCFGR.SECx is disabled, FPIFx can be accessed with non-secure and secure access.
When EXTI_SECCFGR.SECx is enabled, FPIFx can only be accessed with secure access. Non-secure write to this FPIFx is discarded, non-secure read returns 0.
When EXTI_PRIVCFGR.PRIVx is disabled, FPIFx can be accessed with unprivileged and privileged access.
When EXTI_PRIVCFGR.PRIVx is enabled, FPIFx can only be accessed with privileged access. Unprivileged write to this FPIFx is discarded, unprivileged read returns 0.
This bit is set when the falling edge event arrives on the configurable event line. This bit is cleared by writing 1 to it.</description>
                <bitOffset>2</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>No falling edge trigger request occurred</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Falling edge trigger request occurred</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>FPIF3</name>
                <description>configurable event inputs x falling edge pending bit
When EXTI_SECCFGR.SECx is disabled, FPIFx can be accessed with non-secure and secure access.
When EXTI_SECCFGR.SECx is enabled, FPIFx can only be accessed with secure access. Non-secure write to this FPIFx is discarded, non-secure read returns 0.
When EXTI_PRIVCFGR.PRIVx is disabled, FPIFx can be accessed with unprivileged and privileged access.
When EXTI_PRIVCFGR.PRIVx is enabled, FPIFx can only be accessed with privileged access. Unprivileged write to this FPIFx is discarded, unprivileged read returns 0.
This bit is set when the falling edge event arrives on the configurable event line. This bit is cleared by writing 1 to it.</description>
                <bitOffset>3</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>No falling edge trigger request occurred</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Falling edge trigger request occurred</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>FPIF4</name>
                <description>configurable event inputs x falling edge pending bit
When EXTI_SECCFGR.SECx is disabled, FPIFx can be accessed with non-secure and secure access.
When EXTI_SECCFGR.SECx is enabled, FPIFx can only be accessed with secure access. Non-secure write to this FPIFx is discarded, non-secure read returns 0.
When EXTI_PRIVCFGR.PRIVx is disabled, FPIFx can be accessed with unprivileged and privileged access.
When EXTI_PRIVCFGR.PRIVx is enabled, FPIFx can only be accessed with privileged access. Unprivileged write to this FPIFx is discarded, unprivileged read returns 0.
This bit is set when the falling edge event arrives on the configurable event line. This bit is cleared by writing 1 to it.</description>
                <bitOffset>4</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>No falling edge trigger request occurred</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Falling edge trigger request occurred</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>FPIF5</name>
                <description>configurable event inputs x falling edge pending bit
When EXTI_SECCFGR.SECx is disabled, FPIFx can be accessed with non-secure and secure access.
When EXTI_SECCFGR.SECx is enabled, FPIFx can only be accessed with secure access. Non-secure write to this FPIFx is discarded, non-secure read returns 0.
When EXTI_PRIVCFGR.PRIVx is disabled, FPIFx can be accessed with unprivileged and privileged access.
When EXTI_PRIVCFGR.PRIVx is enabled, FPIFx can only be accessed with privileged access. Unprivileged write to this FPIFx is discarded, unprivileged read returns 0.
This bit is set when the falling edge event arrives on the configurable event line. This bit is cleared by writing 1 to it.</description>
                <bitOffset>5</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>No falling edge trigger request occurred</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Falling edge trigger request occurred</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>FPIF6</name>
                <description>configurable event inputs x falling edge pending bit
When EXTI_SECCFGR.SECx is disabled, FPIFx can be accessed with non-secure and secure access.
When EXTI_SECCFGR.SECx is enabled, FPIFx can only be accessed with secure access. Non-secure write to this FPIFx is discarded, non-secure read returns 0.
When EXTI_PRIVCFGR.PRIVx is disabled, FPIFx can be accessed with unprivileged and privileged access.
When EXTI_PRIVCFGR.PRIVx is enabled, FPIFx can only be accessed with privileged access. Unprivileged write to this FPIFx is discarded, unprivileged read returns 0.
This bit is set when the falling edge event arrives on the configurable event line. This bit is cleared by writing 1 to it.</description>
                <bitOffset>6</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>No falling edge trigger request occurred</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Falling edge trigger request occurred</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>FPIF7</name>
                <description>configurable event inputs x falling edge pending bit
When EXTI_SECCFGR.SECx is disabled, FPIFx can be accessed with non-secure and secure access.
When EXTI_SECCFGR.SECx is enabled, FPIFx can only be accessed with secure access. Non-secure write to this FPIFx is discarded, non-secure read returns 0.
When EXTI_PRIVCFGR.PRIVx is disabled, FPIFx can be accessed with unprivileged and privileged access.
When EXTI_PRIVCFGR.PRIVx is enabled, FPIFx can only be accessed with privileged access. Unprivileged write to this FPIFx is discarded, unprivileged read returns 0.
This bit is set when the falling edge event arrives on the configurable event line. This bit is cleared by writing 1 to it.</description>
                <bitOffset>7</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>No falling edge trigger request occurred</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Falling edge trigger request occurred</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>FPIF8</name>
                <description>configurable event inputs x falling edge pending bit
When EXTI_SECCFGR.SECx is disabled, FPIFx can be accessed with non-secure and secure access.
When EXTI_SECCFGR.SECx is enabled, FPIFx can only be accessed with secure access. Non-secure write to this FPIFx is discarded, non-secure read returns 0.
When EXTI_PRIVCFGR.PRIVx is disabled, FPIFx can be accessed with unprivileged and privileged access.
When EXTI_PRIVCFGR.PRIVx is enabled, FPIFx can only be accessed with privileged access. Unprivileged write to this FPIFx is discarded, unprivileged read returns 0.
This bit is set when the falling edge event arrives on the configurable event line. This bit is cleared by writing 1 to it.</description>
                <bitOffset>8</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>No falling edge trigger request occurred</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Falling edge trigger request occurred</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>FPIF9</name>
                <description>configurable event inputs x falling edge pending bit
When EXTI_SECCFGR.SECx is disabled, FPIFx can be accessed with non-secure and secure access.
When EXTI_SECCFGR.SECx is enabled, FPIFx can only be accessed with secure access. Non-secure write to this FPIFx is discarded, non-secure read returns 0.
When EXTI_PRIVCFGR.PRIVx is disabled, FPIFx can be accessed with unprivileged and privileged access.
When EXTI_PRIVCFGR.PRIVx is enabled, FPIFx can only be accessed with privileged access. Unprivileged write to this FPIFx is discarded, unprivileged read returns 0.
This bit is set when the falling edge event arrives on the configurable event line. This bit is cleared by writing 1 to it.</description>
                <bitOffset>9</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>No falling edge trigger request occurred</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Falling edge trigger request occurred</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>FPIF10</name>
                <description>configurable event inputs x falling edge pending bit
When EXTI_SECCFGR.SECx is disabled, FPIFx can be accessed with non-secure and secure access.
When EXTI_SECCFGR.SECx is enabled, FPIFx can only be accessed with secure access. Non-secure write to this FPIFx is discarded, non-secure read returns 0.
When EXTI_PRIVCFGR.PRIVx is disabled, FPIFx can be accessed with unprivileged and privileged access.
When EXTI_PRIVCFGR.PRIVx is enabled, FPIFx can only be accessed with privileged access. Unprivileged write to this FPIFx is discarded, unprivileged read returns 0.
This bit is set when the falling edge event arrives on the configurable event line. This bit is cleared by writing 1 to it.</description>
                <bitOffset>10</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>No falling edge trigger request occurred</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Falling edge trigger request occurred</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>FPIF11</name>
                <description>configurable event inputs x falling edge pending bit
When EXTI_SECCFGR.SECx is disabled, FPIFx can be accessed with non-secure and secure access.
When EXTI_SECCFGR.SECx is enabled, FPIFx can only be accessed with secure access. Non-secure write to this FPIFx is discarded, non-secure read returns 0.
When EXTI_PRIVCFGR.PRIVx is disabled, FPIFx can be accessed with unprivileged and privileged access.
When EXTI_PRIVCFGR.PRIVx is enabled, FPIFx can only be accessed with privileged access. Unprivileged write to this FPIFx is discarded, unprivileged read returns 0.
This bit is set when the falling edge event arrives on the configurable event line. This bit is cleared by writing 1 to it.</description>
                <bitOffset>11</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>No falling edge trigger request occurred</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Falling edge trigger request occurred</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>FPIF12</name>
                <description>configurable event inputs x falling edge pending bit
When EXTI_SECCFGR.SECx is disabled, FPIFx can be accessed with non-secure and secure access.
When EXTI_SECCFGR.SECx is enabled, FPIFx can only be accessed with secure access. Non-secure write to this FPIFx is discarded, non-secure read returns 0.
When EXTI_PRIVCFGR.PRIVx is disabled, FPIFx can be accessed with unprivileged and privileged access.
When EXTI_PRIVCFGR.PRIVx is enabled, FPIFx can only be accessed with privileged access. Unprivileged write to this FPIFx is discarded, unprivileged read returns 0.
This bit is set when the falling edge event arrives on the configurable event line. This bit is cleared by writing 1 to it.</description>
                <bitOffset>12</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>No falling edge trigger request occurred</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Falling edge trigger request occurred</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>FPIF13</name>
                <description>configurable event inputs x falling edge pending bit
When EXTI_SECCFGR.SECx is disabled, FPIFx can be accessed with non-secure and secure access.
When EXTI_SECCFGR.SECx is enabled, FPIFx can only be accessed with secure access. Non-secure write to this FPIFx is discarded, non-secure read returns 0.
When EXTI_PRIVCFGR.PRIVx is disabled, FPIFx can be accessed with unprivileged and privileged access.
When EXTI_PRIVCFGR.PRIVx is enabled, FPIFx can only be accessed with privileged access. Unprivileged write to this FPIFx is discarded, unprivileged read returns 0.
This bit is set when the falling edge event arrives on the configurable event line. This bit is cleared by writing 1 to it.</description>
                <bitOffset>13</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>No falling edge trigger request occurred</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Falling edge trigger request occurred</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>FPIF14</name>
                <description>configurable event inputs x falling edge pending bit
When EXTI_SECCFGR.SECx is disabled, FPIFx can be accessed with non-secure and secure access.
When EXTI_SECCFGR.SECx is enabled, FPIFx can only be accessed with secure access. Non-secure write to this FPIFx is discarded, non-secure read returns 0.
When EXTI_PRIVCFGR.PRIVx is disabled, FPIFx can be accessed with unprivileged and privileged access.
When EXTI_PRIVCFGR.PRIVx is enabled, FPIFx can only be accessed with privileged access. Unprivileged write to this FPIFx is discarded, unprivileged read returns 0.
This bit is set when the falling edge event arrives on the configurable event line. This bit is cleared by writing 1 to it.</description>
                <bitOffset>14</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>No falling edge trigger request occurred</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Falling edge trigger request occurred</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>FPIF15</name>
                <description>configurable event inputs x falling edge pending bit
When EXTI_SECCFGR.SECx is disabled, FPIFx can be accessed with non-secure and secure access.
When EXTI_SECCFGR.SECx is enabled, FPIFx can only be accessed with secure access. Non-secure write to this FPIFx is discarded, non-secure read returns 0.
When EXTI_PRIVCFGR.PRIVx is disabled, FPIFx can be accessed with unprivileged and privileged access.
When EXTI_PRIVCFGR.PRIVx is enabled, FPIFx can only be accessed with privileged access. Unprivileged write to this FPIFx is discarded, unprivileged read returns 0.
This bit is set when the falling edge event arrives on the configurable event line. This bit is cleared by writing 1 to it.</description>
                <bitOffset>15</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>No falling edge trigger request occurred</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Falling edge trigger request occurred</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>FPIF16</name>
                <description>configurable event inputs x falling edge pending bit
When EXTI_SECCFGR.SECx is disabled, FPIFx can be accessed with non-secure and secure access.
When EXTI_SECCFGR.SECx is enabled, FPIFx can only be accessed with secure access. Non-secure write to this FPIFx is discarded, non-secure read returns 0.
When EXTI_PRIVCFGR.PRIVx is disabled, FPIFx can be accessed with unprivileged and privileged access.
When EXTI_PRIVCFGR.PRIVx is enabled, FPIFx can only be accessed with privileged access. Unprivileged write to this FPIFx is discarded, unprivileged read returns 0.
This bit is set when the falling edge event arrives on the configurable event line. This bit is cleared by writing 1 to it.</description>
                <bitOffset>16</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>No falling edge trigger request occurred</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Falling edge trigger request occurred</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
            </fields>
          </register>
          <register>
            <name>EXTI_SECCFGR1</name>
            <displayName>EXTI_SECCFGR1</displayName>
            <description>EXTI security configuration register</description>
            <addressOffset>0x014</addressOffset>
            <size>0x20</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>SEC0</name>
                <description>Security enable on event input x
When EXTI_PRIVCFGR.PRIVx is disabled, SECx can be accessed with privileged and unprivileged access.
When EXTI_PRIVCFGR.PRIVx is enabled, SECx can only be written with privileged access. Unprivileged write to this SECx is discarded.</description>
                <bitOffset>0</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Event security disabled (non-secure)</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Event security enabled (secure)</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>SEC1</name>
                <description>Security enable on event input x
When EXTI_PRIVCFGR.PRIVx is disabled, SECx can be accessed with privileged and unprivileged access.
When EXTI_PRIVCFGR.PRIVx is enabled, SECx can only be written with privileged access. Unprivileged write to this SECx is discarded.</description>
                <bitOffset>1</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Event security disabled (non-secure)</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Event security enabled (secure)</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>SEC2</name>
                <description>Security enable on event input x
When EXTI_PRIVCFGR.PRIVx is disabled, SECx can be accessed with privileged and unprivileged access.
When EXTI_PRIVCFGR.PRIVx is enabled, SECx can only be written with privileged access. Unprivileged write to this SECx is discarded.</description>
                <bitOffset>2</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Event security disabled (non-secure)</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Event security enabled (secure)</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>SEC3</name>
                <description>Security enable on event input x
When EXTI_PRIVCFGR.PRIVx is disabled, SECx can be accessed with privileged and unprivileged access.
When EXTI_PRIVCFGR.PRIVx is enabled, SECx can only be written with privileged access. Unprivileged write to this SECx is discarded.</description>
                <bitOffset>3</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Event security disabled (non-secure)</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Event security enabled (secure)</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>SEC4</name>
                <description>Security enable on event input x
When EXTI_PRIVCFGR.PRIVx is disabled, SECx can be accessed with privileged and unprivileged access.
When EXTI_PRIVCFGR.PRIVx is enabled, SECx can only be written with privileged access. Unprivileged write to this SECx is discarded.</description>
                <bitOffset>4</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Event security disabled (non-secure)</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Event security enabled (secure)</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>SEC5</name>
                <description>Security enable on event input x
When EXTI_PRIVCFGR.PRIVx is disabled, SECx can be accessed with privileged and unprivileged access.
When EXTI_PRIVCFGR.PRIVx is enabled, SECx can only be written with privileged access. Unprivileged write to this SECx is discarded.</description>
                <bitOffset>5</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Event security disabled (non-secure)</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Event security enabled (secure)</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>SEC6</name>
                <description>Security enable on event input x
When EXTI_PRIVCFGR.PRIVx is disabled, SECx can be accessed with privileged and unprivileged access.
When EXTI_PRIVCFGR.PRIVx is enabled, SECx can only be written with privileged access. Unprivileged write to this SECx is discarded.</description>
                <bitOffset>6</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Event security disabled (non-secure)</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Event security enabled (secure)</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>SEC7</name>
                <description>Security enable on event input x
When EXTI_PRIVCFGR.PRIVx is disabled, SECx can be accessed with privileged and unprivileged access.
When EXTI_PRIVCFGR.PRIVx is enabled, SECx can only be written with privileged access. Unprivileged write to this SECx is discarded.</description>
                <bitOffset>7</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Event security disabled (non-secure)</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Event security enabled (secure)</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>SEC8</name>
                <description>Security enable on event input x
When EXTI_PRIVCFGR.PRIVx is disabled, SECx can be accessed with privileged and unprivileged access.
When EXTI_PRIVCFGR.PRIVx is enabled, SECx can only be written with privileged access. Unprivileged write to this SECx is discarded.</description>
                <bitOffset>8</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Event security disabled (non-secure)</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Event security enabled (secure)</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>SEC9</name>
                <description>Security enable on event input x
When EXTI_PRIVCFGR.PRIVx is disabled, SECx can be accessed with privileged and unprivileged access.
When EXTI_PRIVCFGR.PRIVx is enabled, SECx can only be written with privileged access. Unprivileged write to this SECx is discarded.</description>
                <bitOffset>9</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Event security disabled (non-secure)</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Event security enabled (secure)</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>SEC10</name>
                <description>Security enable on event input x
When EXTI_PRIVCFGR.PRIVx is disabled, SECx can be accessed with privileged and unprivileged access.
When EXTI_PRIVCFGR.PRIVx is enabled, SECx can only be written with privileged access. Unprivileged write to this SECx is discarded.</description>
                <bitOffset>10</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Event security disabled (non-secure)</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Event security enabled (secure)</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>SEC11</name>
                <description>Security enable on event input x
When EXTI_PRIVCFGR.PRIVx is disabled, SECx can be accessed with privileged and unprivileged access.
When EXTI_PRIVCFGR.PRIVx is enabled, SECx can only be written with privileged access. Unprivileged write to this SECx is discarded.</description>
                <bitOffset>11</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Event security disabled (non-secure)</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Event security enabled (secure)</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>SEC12</name>
                <description>Security enable on event input x
When EXTI_PRIVCFGR.PRIVx is disabled, SECx can be accessed with privileged and unprivileged access.
When EXTI_PRIVCFGR.PRIVx is enabled, SECx can only be written with privileged access. Unprivileged write to this SECx is discarded.</description>
                <bitOffset>12</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Event security disabled (non-secure)</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Event security enabled (secure)</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>SEC13</name>
                <description>Security enable on event input x
When EXTI_PRIVCFGR.PRIVx is disabled, SECx can be accessed with privileged and unprivileged access.
When EXTI_PRIVCFGR.PRIVx is enabled, SECx can only be written with privileged access. Unprivileged write to this SECx is discarded.</description>
                <bitOffset>13</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Event security disabled (non-secure)</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Event security enabled (secure)</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>SEC14</name>
                <description>Security enable on event input x
When EXTI_PRIVCFGR.PRIVx is disabled, SECx can be accessed with privileged and unprivileged access.
When EXTI_PRIVCFGR.PRIVx is enabled, SECx can only be written with privileged access. Unprivileged write to this SECx is discarded.</description>
                <bitOffset>14</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Event security disabled (non-secure)</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Event security enabled (secure)</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>SEC15</name>
                <description>Security enable on event input x
When EXTI_PRIVCFGR.PRIVx is disabled, SECx can be accessed with privileged and unprivileged access.
When EXTI_PRIVCFGR.PRIVx is enabled, SECx can only be written with privileged access. Unprivileged write to this SECx is discarded.</description>
                <bitOffset>15</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Event security disabled (non-secure)</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Event security enabled (secure)</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>SEC16</name>
                <description>Security enable on event input x
When EXTI_PRIVCFGR.PRIVx is disabled, SECx can be accessed with privileged and unprivileged access.
When EXTI_PRIVCFGR.PRIVx is enabled, SECx can only be written with privileged access. Unprivileged write to this SECx is discarded.</description>
                <bitOffset>16</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Event security disabled (non-secure)</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Event security enabled (secure)</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
            </fields>
          </register>
          <register>
            <name>EXTI_PRIVCFGR1</name>
            <displayName>EXTI_PRIVCFGR1</displayName>
            <description>EXTI privilege configuration register</description>
            <addressOffset>0x018</addressOffset>
            <size>0x20</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>PRIV0</name>
                <description>Security enable on event input x
When EXTI_SECCFGR.SECx is disabled, PRIVx can be accessed with secure and non-secure access.
When EXTI_SECCFGR.SECx is enabled, PRIVx can only be written with secure access. Non-secure write to this PRIVx is discarded.</description>
                <bitOffset>0</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Event privilege disabled (unprivileged)</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Event privilege enabled (privileged)</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>PRIV1</name>
                <description>Security enable on event input x
When EXTI_SECCFGR.SECx is disabled, PRIVx can be accessed with secure and non-secure access.
When EXTI_SECCFGR.SECx is enabled, PRIVx can only be written with secure access. Non-secure write to this PRIVx is discarded.</description>
                <bitOffset>1</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Event privilege disabled (unprivileged)</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Event privilege enabled (privileged)</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>PRIV2</name>
                <description>Security enable on event input x
When EXTI_SECCFGR.SECx is disabled, PRIVx can be accessed with secure and non-secure access.
When EXTI_SECCFGR.SECx is enabled, PRIVx can only be written with secure access. Non-secure write to this PRIVx is discarded.</description>
                <bitOffset>2</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Event privilege disabled (unprivileged)</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Event privilege enabled (privileged)</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>PRIV3</name>
                <description>Security enable on event input x
When EXTI_SECCFGR.SECx is disabled, PRIVx can be accessed with secure and non-secure access.
When EXTI_SECCFGR.SECx is enabled, PRIVx can only be written with secure access. Non-secure write to this PRIVx is discarded.</description>
                <bitOffset>3</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Event privilege disabled (unprivileged)</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Event privilege enabled (privileged)</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>PRIV4</name>
                <description>Security enable on event input x
When EXTI_SECCFGR.SECx is disabled, PRIVx can be accessed with secure and non-secure access.
When EXTI_SECCFGR.SECx is enabled, PRIVx can only be written with secure access. Non-secure write to this PRIVx is discarded.</description>
                <bitOffset>4</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Event privilege disabled (unprivileged)</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Event privilege enabled (privileged)</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>PRIV5</name>
                <description>Security enable on event input x
When EXTI_SECCFGR.SECx is disabled, PRIVx can be accessed with secure and non-secure access.
When EXTI_SECCFGR.SECx is enabled, PRIVx can only be written with secure access. Non-secure write to this PRIVx is discarded.</description>
                <bitOffset>5</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Event privilege disabled (unprivileged)</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Event privilege enabled (privileged)</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>PRIV6</name>
                <description>Security enable on event input x
When EXTI_SECCFGR.SECx is disabled, PRIVx can be accessed with secure and non-secure access.
When EXTI_SECCFGR.SECx is enabled, PRIVx can only be written with secure access. Non-secure write to this PRIVx is discarded.</description>
                <bitOffset>6</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Event privilege disabled (unprivileged)</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Event privilege enabled (privileged)</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>PRIV7</name>
                <description>Security enable on event input x
When EXTI_SECCFGR.SECx is disabled, PRIVx can be accessed with secure and non-secure access.
When EXTI_SECCFGR.SECx is enabled, PRIVx can only be written with secure access. Non-secure write to this PRIVx is discarded.</description>
                <bitOffset>7</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Event privilege disabled (unprivileged)</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Event privilege enabled (privileged)</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>PRIV8</name>
                <description>Security enable on event input x
When EXTI_SECCFGR.SECx is disabled, PRIVx can be accessed with secure and non-secure access.
When EXTI_SECCFGR.SECx is enabled, PRIVx can only be written with secure access. Non-secure write to this PRIVx is discarded.</description>
                <bitOffset>8</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Event privilege disabled (unprivileged)</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Event privilege enabled (privileged)</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>PRIV9</name>
                <description>Security enable on event input x
When EXTI_SECCFGR.SECx is disabled, PRIVx can be accessed with secure and non-secure access.
When EXTI_SECCFGR.SECx is enabled, PRIVx can only be written with secure access. Non-secure write to this PRIVx is discarded.</description>
                <bitOffset>9</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Event privilege disabled (unprivileged)</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Event privilege enabled (privileged)</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>PRIV10</name>
                <description>Security enable on event input x
When EXTI_SECCFGR.SECx is disabled, PRIVx can be accessed with secure and non-secure access.
When EXTI_SECCFGR.SECx is enabled, PRIVx can only be written with secure access. Non-secure write to this PRIVx is discarded.</description>
                <bitOffset>10</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Event privilege disabled (unprivileged)</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Event privilege enabled (privileged)</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>PRIV11</name>
                <description>Security enable on event input x
When EXTI_SECCFGR.SECx is disabled, PRIVx can be accessed with secure and non-secure access.
When EXTI_SECCFGR.SECx is enabled, PRIVx can only be written with secure access. Non-secure write to this PRIVx is discarded.</description>
                <bitOffset>11</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Event privilege disabled (unprivileged)</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Event privilege enabled (privileged)</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>PRIV12</name>
                <description>Security enable on event input x
When EXTI_SECCFGR.SECx is disabled, PRIVx can be accessed with secure and non-secure access.
When EXTI_SECCFGR.SECx is enabled, PRIVx can only be written with secure access. Non-secure write to this PRIVx is discarded.</description>
                <bitOffset>12</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Event privilege disabled (unprivileged)</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Event privilege enabled (privileged)</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>PRIV13</name>
                <description>Security enable on event input x
When EXTI_SECCFGR.SECx is disabled, PRIVx can be accessed with secure and non-secure access.
When EXTI_SECCFGR.SECx is enabled, PRIVx can only be written with secure access. Non-secure write to this PRIVx is discarded.</description>
                <bitOffset>13</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Event privilege disabled (unprivileged)</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Event privilege enabled (privileged)</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>PRIV14</name>
                <description>Security enable on event input x
When EXTI_SECCFGR.SECx is disabled, PRIVx can be accessed with secure and non-secure access.
When EXTI_SECCFGR.SECx is enabled, PRIVx can only be written with secure access. Non-secure write to this PRIVx is discarded.</description>
                <bitOffset>14</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Event privilege disabled (unprivileged)</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Event privilege enabled (privileged)</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>PRIV15</name>
                <description>Security enable on event input x
When EXTI_SECCFGR.SECx is disabled, PRIVx can be accessed with secure and non-secure access.
When EXTI_SECCFGR.SECx is enabled, PRIVx can only be written with secure access. Non-secure write to this PRIVx is discarded.</description>
                <bitOffset>15</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Event privilege disabled (unprivileged)</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Event privilege enabled (privileged)</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>PRIV16</name>
                <description>Security enable on event input x
When EXTI_SECCFGR.SECx is disabled, PRIVx can be accessed with secure and non-secure access.
When EXTI_SECCFGR.SECx is enabled, PRIVx can only be written with secure access. Non-secure write to this PRIVx is discarded.</description>
                <bitOffset>16</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Event privilege disabled (unprivileged)</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Event privilege enabled (privileged)</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
            </fields>
          </register>
          <register>
            <name>EXTI_EXTICR1</name>
            <displayName>EXTI_EXTICR1</displayName>
            <description>EXTI external interrupt selection register</description>
            <addressOffset>0x060</addressOffset>
            <size>0x20</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>EXTI0</name>
                <description>EXTI0 GPIO port selection
These bits are written by software to select the source input for EXTI0 external interrupt.
When EXTI_SECCFGR.SEC0 is disabled, EXTI0 can be accessed with non-secure and secure access.
When EXTI_SECCFGR.SEC0 is enabled, EXTI0 can only be accessed with secure access. Non-secure write is discarded and non-secure read returns 0.
When EXTI_PRIVCFGR.PRIV0 is disabled, EXTI0 can be accessed with privileged and unprivileged access.
When EXTI_PRIVCFGR.PRIV0 is enabled, EXTI0 can only be accessed with privileged access. Unprivileged write to this bit is discarded.
Others: reserved</description>
                <bitOffset>0</bitOffset>
                <bitWidth>8</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x00</name>
                    <description>PA0 pin</description>
                    <value>0x00</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x01</name>
                    <description>PB0 pin</description>
                    <value>0x01</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>EXTI1</name>
                <description>EXTI1 GPIO port selection
These bits are written by software to select the source input for EXTI1 external interrupt.
When EXTI_SECCFGR.SEC1 is disabled, EXTI1 can be accessed with
non-secure and secure access.
When EXTI_SECCFGR.SEC1 is enabled, EXTI1 can only be accessed with secure access. Non-secure write is discarded and non-secure read returns 0.
When EXTI_PRIVCFGR.PRIV1 is disabled, EXTI1 can be accessed with privileged and unprivileged access.
When EXTI_PRIVCFGR.PRIV1 is enabled, EXTI1 can only be accessed with privileged access. Unprivileged write to this bit is discarded.
Others: reserved</description>
                <bitOffset>8</bitOffset>
                <bitWidth>8</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x00</name>
                    <description>PA1 pin</description>
                    <value>0x00</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x01</name>
                    <description>PB1 pin</description>
                    <value>0x01</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>EXTI2</name>
                <description>EXTI2 GPIO port selection 
These bits are written by software to select the source input for EXTI2 external interrupt.
When EXTI_SECCFGR.SEC2 is disabled, EXTI2 can be accessed with
non-secure and secure access.
When EXTI_SECCFGR.SEC2 is enabled, EXTI2 can only be accessed with secure access. Non-secure write is discarded and non-secure read returns 0.
When EXTI_PRIVCFGR.PRIV2 is disabled, EXTI2 can be accessed with privileged and unprivileged access.
When EXTI_PRIVCFGR.PRIV2 is enabled, EXTI2 can only be accessed with privileged access. Unprivileged write to this bit is discarded.
Others: reserved</description>
                <bitOffset>16</bitOffset>
                <bitWidth>8</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x00</name>
                    <description>PA2 pin</description>
                    <value>0x00</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x01</name>
                    <description>PB2 pin</description>
                    <value>0x01</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>EXTI3</name>
                <description>EXTI3 GPIO port selection
These bits are written by software to select the source input for EXTI3 external interrupt.
When EXTI_SECCFGR.SEC3 is disabled, EXTI3 can be accessed with 
non-secure and secure access.
When EXTI_SECCFGR.SEC3 is enabled, EXTI3 can only be accessed with secure access. Non-secure write is discarded and non-secure read returns 0.
When EXTI_PRIVCFGR.PRIV3 is disabled, EXTI3 can be accessed with privileged and unprivileged access.
When EXTI_PRIVCFGR.PRIV3 is enabled, EXTI3 can only be accessed with privileged access. Unprivileged write to this bit is discarded.
Others: reserved</description>
                <bitOffset>24</bitOffset>
                <bitWidth>8</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x00</name>
                    <description>PA3 pin</description>
                    <value>0x00</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x01</name>
                    <description>PB3 pin</description>
                    <value>0x01</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x07</name>
                    <description>PH3 pin</description>
                    <value>0x07</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
            </fields>
          </register>
          <register>
            <name>EXTI_EXTICR2</name>
            <displayName>EXTI_EXTICR2</displayName>
            <description>EXTI external interrupt selection register</description>
            <addressOffset>0x064</addressOffset>
            <size>0x20</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>EXTI4</name>
                <description>EXTI4 GPIO port selection
These bits are written by software to select the source input for EXTI4 external interrupt.
When EXTI_SECCFGR.SEC4 is disabled, EXTI4 can be accessed with non-secure and secure access.
When EXTI_SECCFGR.SEC4 is enabled, EXTI4 can only be accessed with secure access. Non-secure write is discarded and non-secure read returns 0.
When EXTI_PRIVCFGR.PRIV4 is disabled, EXTI4 can be accessed with privileged and unprivileged access.
When EXTI_PRIVCFGR.PRIV4 is enabled, EXTI4 can only be accessed with privileged access. Unprivileged write to this bit is discarded.
Others: reserved</description>
                <bitOffset>0</bitOffset>
                <bitWidth>8</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x00</name>
                    <description>No port pin selected</description>
                    <value>0x00</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x01</name>
                    <description>PB4 pin</description>
                    <value>0x01</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>EXTI5</name>
                <description>EXTI5 GPIO port selection
These bits are written by software to select the source input for EXTI5 external interrupt.
When EXTI_SECCFGR.SEC5 is disabled, EXTI5 can be accessed with non-secure and secure access.
When EXTI_SECCFGR.SEC5 is enabled, EXTI5 can only be accessed with secure access. Non-secure write is discarded and non-secure read returns 0.
When EXTI_PRIVCFGR.PRIV5 is disabled, EXTI5 can be accessed with privileged and unprivileged access.
When EXTI_PRIVCFGR.PRIV5 is enabled, EXTI5 can only be accessed with privileged access. Unprivileged write to this bit is discarded.
Others: reserved</description>
                <bitOffset>8</bitOffset>
                <bitWidth>8</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x00</name>
                    <description>PA5 pin</description>
                    <value>0x00</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x01</name>
                    <description>PB5 pin</description>
                    <value>0x01</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>EXTI6</name>
                <description>EXTI6 GPIO port selection 
These bits are written by software to select the source input for EXTI6 external interrupt.
When EXTI_SECCFGR.SEC6 is disabled, EXTI6 can be accessed with non-secure and secure access.
When EXTI_SECCFGR.SEC6 is enabled, EXTI6 can only be accessed with secure access. Non-secure write is discarded and non-secure read returns 0.
When EXTI_PRIVCFGR.PRIV6 is disabled, EXTI6 can be accessed with privileged and unprivileged access.
When EXTI_PRIVCFGR.PRIV6 is enabled, EXTI6 can only be accessed with privileged access. Unprivileged write to this bit is discarded.
Others: reserved</description>
                <bitOffset>16</bitOffset>
                <bitWidth>8</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x00</name>
                    <description>PA6 pin</description>
                    <value>0x00</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x01</name>
                    <description>PB6 pin</description>
                    <value>0x01</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>EXTI7</name>
                <description>EXTI7 GPIO port selection
These bits are written by software to select the source input for EXTI7 external interrupt.
When EXTI_SECCFGR.SEC7 is disabled, EXTI7 can be accessed with non-secure and secure access.
When EXTI_SECCFGR.SEC7 is enabled, EXTI7 can only be accessed with secure access. Non-secure write is discarded and non-secure read returns 0.
When EXTI_PRIVCFGR.PRIV7 is disabled, EXTI7 can be accessed with privileged and unprivileged access.
When EXTI_PRIVCFGR.PRIV7 is enabled, EXTI7 can only be accessed with privileged access. Unprivileged write to this bit is discarded.
Others: reserved</description>
                <bitOffset>24</bitOffset>
                <bitWidth>8</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x00</name>
                    <description>PA7 pin</description>
                    <value>0x00</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x01</name>
                    <description>PB7 pin</description>
                    <value>0x01</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
            </fields>
          </register>
          <register>
            <name>EXTI_EXTICR3</name>
            <displayName>EXTI_EXTICR3</displayName>
            <description>EXTI external interrupt selection register</description>
            <addressOffset>0x068</addressOffset>
            <size>0x20</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>EXTI8</name>
                <description>EXTI8 GPIO port selection
These bits are written by software to select the source input for EXTI8 external interrupt.
When EXTI_SECCFGR.SEC8 is disabled, EXTI8 can be accessed with non-secure and secure access.
When EXTI_SECCFGR.SEC8 is enabled, EXTI8 can only be accessed with secure access. Non-secure write is discarded and non-secure read returns 0.
When EXTI_PRIVCFGR.PRIV8 is disabled, EXTI8 can be accessed with privileged and unprivileged access.
When EXTI_PRIVCFGR.PRIV8 is enabled, EXTI8 can only be accessed with privileged access. Unprivileged write to this bit is discarded.
Others: reserved</description>
                <bitOffset>0</bitOffset>
                <bitWidth>8</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x00</name>
                    <description>PA8 pin</description>
                    <value>0x00</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x01</name>
                    <description>PB8 pin</description>
                    <value>0x01</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>EXTI9</name>
                <description>EXTI9 GPIO port selection
These bits are written by software to select the source input for EXTI9 external interrupt.
When EXTI_SECCFGR.SEC9 is disabled, EXTI9 can be accessed with non-secure and secure access.
When EXTI_SECCFGR.SEC9 is enabled, EXTI9 can only be accessed with secure access. Non-secure write is discarded and non-secure read returns 0.
When EXTI_PRIVCFGR.PRIV9 is disabled, EXTI9 can be accessed with privileged and unprivileged access.
When EXTI_PRIVCFGR.PRIV9 is enabled, EXTI9 can only be accessed with privileged access. Unprivileged write to this bit is discarded.
Others: reserved</description>
                <bitOffset>8</bitOffset>
                <bitWidth>8</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x00</name>
                    <description>PA9 pin</description>
                    <value>0x00</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x01</name>
                    <description>PB9 pin</description>
                    <value>0x01</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>EXTI10</name>
                <description>EXTI10 GPIO port selection 
These bits are written by software to select the source input for EXTI10 external interrupt.
When EXTI_SECCFGR.SEC10 is disabled, EXTI10 can be accessed with non-secure and secure access.
When EXTI_SECCFGR.SEC10 is enabled, EXTI10 can only be accessed with secure access. Non-secure write is discarded and non-secure read returns 0.
When EXTI_PRIVCFGR.PRIV10 is disabled, EXTI10 can be accessed with privileged and unprivileged access.
When EXTI_PRIVCFGR.PRIV10 is enabled, EXTI10 can only be accessed with privileged access. Unprivileged write to this bit is discarded.
Others: reserved</description>
                <bitOffset>16</bitOffset>
                <bitWidth>8</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x00</name>
                    <description>PA10 pin</description>
                    <value>0x00</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x01</name>
                    <description>PB10 pin (reserved on STM32WBA55xx devices)</description>
                    <value>0x01</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>EXTI11</name>
                <description>EXTI11 GPIO port selection
These bits are written by software to select the source input for EXTI11 external interrupt.
When EXTI_SECCFGR.SEC11 is disabled, EXTI11 can be accessed with non-secure and secure access.
When EXTI_SECCFGR.SEC11 is enabled, EXTI11 can only be accessed with secure access. Non-secure write is discarded and non-secure read returns 0.
When EXTI_PRIVCFGR.PRIV11 is disabled, EXTI11 can be accessed with privileged and unprivileged access.
When EXTI_PRIVCFGR.PRIV11 is enabled, EXTI11 can only be accessed with privileged access. Unprivileged write to this bit is discarded.
Others: reserved</description>
                <bitOffset>24</bitOffset>
                <bitWidth>8</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x00</name>
                    <description>PA11 pin</description>
                    <value>0x00</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x01</name>
                    <description>PB11 pin</description>
                    <value>0x01</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
            </fields>
          </register>
          <register>
            <name>EXTI_EXTICR4</name>
            <displayName>EXTI_EXTICR4</displayName>
            <description>EXTI external interrupt selection register</description>
            <addressOffset>0x06C</addressOffset>
            <size>0x20</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>EXTI12</name>
                <description>EXTI0 GPIO port selection
These bits are written by software to select the source input for EXTI12 external interrupt.
When EXTI_SECCFGR.SEC12 is disabled, EXTI12 can be accessed with non-secure and secure access.
When EXTI_SECCFGR.SEC12 is enabled, EXTI12 can only be accessed with secure access. Non-secure write is discarded and non-secure read returns 0.
When EXTI_PRIVCFGR.PRIV12 is disabled, EXTI12 can be accessed with privileged and unprivileged access.
When EXTI_PRIVCFGR.PRIV12 is enabled, EXTI12 can only be accessed with privileged access. Unprivileged write to this bit is discarded.
Others: reserved</description>
                <bitOffset>0</bitOffset>
                <bitWidth>8</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x00</name>
                    <description>PA12 pin</description>
                    <value>0x00</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x01</name>
                    <description>PB12 pin</description>
                    <value>0x01</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>EXTI13</name>
                <description>EXTI13 GPIO port selection
These bits are written by software to select the source input for EXTI13 external interrupt.
When EXTI_SECCFGR.SEC13 is disabled, EXTI13 can be accessed with non-secure and secure access.
When EXTI_SECCFGR.SEC13 is enabled, EXTI13 can only be accessed with secure access. Non-secure write is discarded and non-secure read returns 0.
When EXTI_PRIVCFGR.PRIV13 is disabled, EXTI13 can be accessed with privileged and unprivileged access.
When EXTI_PRIVCFGR.PRIV13 is enabled, EXTI13 can only be accessed with privileged access. Unprivileged write to this bit is discarded.
Others: reserved</description>
                <bitOffset>8</bitOffset>
                <bitWidth>8</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x00</name>
                    <description>PA13 pin</description>
                    <value>0x00</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x01</name>
                    <description>PB13 pin</description>
                    <value>0x01</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x02</name>
                    <description>PC13 pin</description>
                    <value>0x02</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>EXTI14</name>
                <description>EXTI14 GPIO port selection 
These bits are written by software to select the source input for EXTI14 external interrupt.
When EXTI_SECCFGR.SEC14 is disabled, EXTI14 can be accessed with non-secure and secure access.
When EXTI_SECCFGR.SEC14 is enabled, EXTI14 can only be accessed with secure access. Non-secure write is discarded and non-secure read returns 0.
When EXTI_PRIVCFGR.PRIV14 is disabled, EXTI14 can be accessed with privileged and unprivileged access.
When EXTI_PRIVCFGR.PRIV14 is enabled, EXTI14 can only be accessed with privileged access. Unprivileged write to this bit is discarded.
Others: reserved</description>
                <bitOffset>16</bitOffset>
                <bitWidth>8</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x00</name>
                    <description>PA14 pin</description>
                    <value>0x00</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x01</name>
                    <description>PB14 pin</description>
                    <value>0x01</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x02</name>
                    <description>PC14 pin</description>
                    <value>0x02</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>EXTI15</name>
                <description>EXTI15 GPIO port selection
These bits are written by software to select the source input for EXTI15 external interrupt.
When EXTI_SECCFGR.SEC15 is disabled, EXTI15 can be accessed with non-secure and secure access.
When EXTI_SECCFGR.SEC15 is enabled, EXTI15 can only be accessed with secure access. Non-secure write is discarded and non-secure read returns 0.
When EXTI_PRIVCFGR.PRIV15 is disabled, EXTI15 can be accessed with privileged and unprivileged access.
When EXTI_PRIVCFGR.PRIV15 is enabled, EXTI15 can only be accessed with privileged access. Unprivileged write to this bit is discarded.
Others: reserved</description>
                <bitOffset>24</bitOffset>
                <bitWidth>8</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x00</name>
                    <description>PA15 pin</description>
                    <value>0x00</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x01</name>
                    <description>PB15 pin</description>
                    <value>0x01</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x02</name>
                    <description>PC15 pin</description>
                    <value>0x02</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
            </fields>
          </register>
          <register>
            <name>EXTI_LOCKR</name>
            <displayName>EXTI_LOCKR</displayName>
            <description>EXTI lock register</description>
            <addressOffset>0x070</addressOffset>
            <size>0x20</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>LOCK</name>
                <description>Global security and privilege configuration registers (EXTI_SECCFGR and EXTI_PRIVCFGR) lock 
This bit is written once after reset.</description>
                <bitOffset>0</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Security and privilege configuration open, can be modified.</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Security and privilege configuration locked, can no longer be modified.</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
            </fields>
          </register>
          <register>
            <name>EXTI_IMR1</name>
            <displayName>EXTI_IMR1</displayName>
            <description>EXTI CPU wakeup with interrupt mask register</description>
            <addressOffset>0x080</addressOffset>
            <size>0x20</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>IM0</name>
                <description>CPU wakeup with interrupt mask on event input x
When EXTI_SECCFGR.SECx is disabled, IMx can be accessed with non-secure and secure access.
When EXTI_SECCFGR.SECx is enabled, IMx can only be accessed with secure access. Non-secure write to this bit is discarded and non-secure read returns 0.
When EXTI_PRIVCFGR.PRIVx is disabled, IMx can be accessed with privileged and unprivileged access.
When EXTI_PRIVCFGR.PRIVx is enabled, IMx can only be accessed with privileged access. Unprivileged write to this bit is discarded.</description>
                <bitOffset>0</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Wakeup with interrupt request from input event x is masked.</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Wakeup with interrupt request from input event x is unmasked.</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>IM1</name>
                <description>CPU wakeup with interrupt mask on event input x
When EXTI_SECCFGR.SECx is disabled, IMx can be accessed with non-secure and secure access.
When EXTI_SECCFGR.SECx is enabled, IMx can only be accessed with secure access. Non-secure write to this bit is discarded and non-secure read returns 0.
When EXTI_PRIVCFGR.PRIVx is disabled, IMx can be accessed with privileged and unprivileged access.
When EXTI_PRIVCFGR.PRIVx is enabled, IMx can only be accessed with privileged access. Unprivileged write to this bit is discarded.</description>
                <bitOffset>1</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Wakeup with interrupt request from input event x is masked.</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Wakeup with interrupt request from input event x is unmasked.</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>IM2</name>
                <description>CPU wakeup with interrupt mask on event input x
When EXTI_SECCFGR.SECx is disabled, IMx can be accessed with non-secure and secure access.
When EXTI_SECCFGR.SECx is enabled, IMx can only be accessed with secure access. Non-secure write to this bit is discarded and non-secure read returns 0.
When EXTI_PRIVCFGR.PRIVx is disabled, IMx can be accessed with privileged and unprivileged access.
When EXTI_PRIVCFGR.PRIVx is enabled, IMx can only be accessed with privileged access. Unprivileged write to this bit is discarded.</description>
                <bitOffset>2</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Wakeup with interrupt request from input event x is masked.</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Wakeup with interrupt request from input event x is unmasked.</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>IM3</name>
                <description>CPU wakeup with interrupt mask on event input x
When EXTI_SECCFGR.SECx is disabled, IMx can be accessed with non-secure and secure access.
When EXTI_SECCFGR.SECx is enabled, IMx can only be accessed with secure access. Non-secure write to this bit is discarded and non-secure read returns 0.
When EXTI_PRIVCFGR.PRIVx is disabled, IMx can be accessed with privileged and unprivileged access.
When EXTI_PRIVCFGR.PRIVx is enabled, IMx can only be accessed with privileged access. Unprivileged write to this bit is discarded.</description>
                <bitOffset>3</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Wakeup with interrupt request from input event x is masked.</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Wakeup with interrupt request from input event x is unmasked.</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>IM4</name>
                <description>CPU wakeup with interrupt mask on event input x
When EXTI_SECCFGR.SECx is disabled, IMx can be accessed with non-secure and secure access.
When EXTI_SECCFGR.SECx is enabled, IMx can only be accessed with secure access. Non-secure write to this bit is discarded and non-secure read returns 0.
When EXTI_PRIVCFGR.PRIVx is disabled, IMx can be accessed with privileged and unprivileged access.
When EXTI_PRIVCFGR.PRIVx is enabled, IMx can only be accessed with privileged access. Unprivileged write to this bit is discarded.</description>
                <bitOffset>4</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Wakeup with interrupt request from input event x is masked.</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Wakeup with interrupt request from input event x is unmasked.</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>IM5</name>
                <description>CPU wakeup with interrupt mask on event input x
When EXTI_SECCFGR.SECx is disabled, IMx can be accessed with non-secure and secure access.
When EXTI_SECCFGR.SECx is enabled, IMx can only be accessed with secure access. Non-secure write to this bit is discarded and non-secure read returns 0.
When EXTI_PRIVCFGR.PRIVx is disabled, IMx can be accessed with privileged and unprivileged access.
When EXTI_PRIVCFGR.PRIVx is enabled, IMx can only be accessed with privileged access. Unprivileged write to this bit is discarded.</description>
                <bitOffset>5</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Wakeup with interrupt request from input event x is masked.</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Wakeup with interrupt request from input event x is unmasked.</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>IM6</name>
                <description>CPU wakeup with interrupt mask on event input x
When EXTI_SECCFGR.SECx is disabled, IMx can be accessed with non-secure and secure access.
When EXTI_SECCFGR.SECx is enabled, IMx can only be accessed with secure access. Non-secure write to this bit is discarded and non-secure read returns 0.
When EXTI_PRIVCFGR.PRIVx is disabled, IMx can be accessed with privileged and unprivileged access.
When EXTI_PRIVCFGR.PRIVx is enabled, IMx can only be accessed with privileged access. Unprivileged write to this bit is discarded.</description>
                <bitOffset>6</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Wakeup with interrupt request from input event x is masked.</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Wakeup with interrupt request from input event x is unmasked.</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>IM7</name>
                <description>CPU wakeup with interrupt mask on event input x
When EXTI_SECCFGR.SECx is disabled, IMx can be accessed with non-secure and secure access.
When EXTI_SECCFGR.SECx is enabled, IMx can only be accessed with secure access. Non-secure write to this bit is discarded and non-secure read returns 0.
When EXTI_PRIVCFGR.PRIVx is disabled, IMx can be accessed with privileged and unprivileged access.
When EXTI_PRIVCFGR.PRIVx is enabled, IMx can only be accessed with privileged access. Unprivileged write to this bit is discarded.</description>
                <bitOffset>7</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Wakeup with interrupt request from input event x is masked.</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Wakeup with interrupt request from input event x is unmasked.</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>IM8</name>
                <description>CPU wakeup with interrupt mask on event input x
When EXTI_SECCFGR.SECx is disabled, IMx can be accessed with non-secure and secure access.
When EXTI_SECCFGR.SECx is enabled, IMx can only be accessed with secure access. Non-secure write to this bit is discarded and non-secure read returns 0.
When EXTI_PRIVCFGR.PRIVx is disabled, IMx can be accessed with privileged and unprivileged access.
When EXTI_PRIVCFGR.PRIVx is enabled, IMx can only be accessed with privileged access. Unprivileged write to this bit is discarded.</description>
                <bitOffset>8</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Wakeup with interrupt request from input event x is masked.</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Wakeup with interrupt request from input event x is unmasked.</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>IM9</name>
                <description>CPU wakeup with interrupt mask on event input x
When EXTI_SECCFGR.SECx is disabled, IMx can be accessed with non-secure and secure access.
When EXTI_SECCFGR.SECx is enabled, IMx can only be accessed with secure access. Non-secure write to this bit is discarded and non-secure read returns 0.
When EXTI_PRIVCFGR.PRIVx is disabled, IMx can be accessed with privileged and unprivileged access.
When EXTI_PRIVCFGR.PRIVx is enabled, IMx can only be accessed with privileged access. Unprivileged write to this bit is discarded.</description>
                <bitOffset>9</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Wakeup with interrupt request from input event x is masked.</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Wakeup with interrupt request from input event x is unmasked.</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>IM10</name>
                <description>CPU wakeup with interrupt mask on event input x
When EXTI_SECCFGR.SECx is disabled, IMx can be accessed with non-secure and secure access.
When EXTI_SECCFGR.SECx is enabled, IMx can only be accessed with secure access. Non-secure write to this bit is discarded and non-secure read returns 0.
When EXTI_PRIVCFGR.PRIVx is disabled, IMx can be accessed with privileged and unprivileged access.
When EXTI_PRIVCFGR.PRIVx is enabled, IMx can only be accessed with privileged access. Unprivileged write to this bit is discarded.</description>
                <bitOffset>10</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Wakeup with interrupt request from input event x is masked.</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Wakeup with interrupt request from input event x is unmasked.</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>IM11</name>
                <description>CPU wakeup with interrupt mask on event input x
When EXTI_SECCFGR.SECx is disabled, IMx can be accessed with non-secure and secure access.
When EXTI_SECCFGR.SECx is enabled, IMx can only be accessed with secure access. Non-secure write to this bit is discarded and non-secure read returns 0.
When EXTI_PRIVCFGR.PRIVx is disabled, IMx can be accessed with privileged and unprivileged access.
When EXTI_PRIVCFGR.PRIVx is enabled, IMx can only be accessed with privileged access. Unprivileged write to this bit is discarded.</description>
                <bitOffset>11</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Wakeup with interrupt request from input event x is masked.</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Wakeup with interrupt request from input event x is unmasked.</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>IM12</name>
                <description>CPU wakeup with interrupt mask on event input x
When EXTI_SECCFGR.SECx is disabled, IMx can be accessed with non-secure and secure access.
When EXTI_SECCFGR.SECx is enabled, IMx can only be accessed with secure access. Non-secure write to this bit is discarded and non-secure read returns 0.
When EXTI_PRIVCFGR.PRIVx is disabled, IMx can be accessed with privileged and unprivileged access.
When EXTI_PRIVCFGR.PRIVx is enabled, IMx can only be accessed with privileged access. Unprivileged write to this bit is discarded.</description>
                <bitOffset>12</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Wakeup with interrupt request from input event x is masked.</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Wakeup with interrupt request from input event x is unmasked.</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>IM13</name>
                <description>CPU wakeup with interrupt mask on event input x
When EXTI_SECCFGR.SECx is disabled, IMx can be accessed with non-secure and secure access.
When EXTI_SECCFGR.SECx is enabled, IMx can only be accessed with secure access. Non-secure write to this bit is discarded and non-secure read returns 0.
When EXTI_PRIVCFGR.PRIVx is disabled, IMx can be accessed with privileged and unprivileged access.
When EXTI_PRIVCFGR.PRIVx is enabled, IMx can only be accessed with privileged access. Unprivileged write to this bit is discarded.</description>
                <bitOffset>13</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Wakeup with interrupt request from input event x is masked.</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Wakeup with interrupt request from input event x is unmasked.</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>IM14</name>
                <description>CPU wakeup with interrupt mask on event input x
When EXTI_SECCFGR.SECx is disabled, IMx can be accessed with non-secure and secure access.
When EXTI_SECCFGR.SECx is enabled, IMx can only be accessed with secure access. Non-secure write to this bit is discarded and non-secure read returns 0.
When EXTI_PRIVCFGR.PRIVx is disabled, IMx can be accessed with privileged and unprivileged access.
When EXTI_PRIVCFGR.PRIVx is enabled, IMx can only be accessed with privileged access. Unprivileged write to this bit is discarded.</description>
                <bitOffset>14</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Wakeup with interrupt request from input event x is masked.</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Wakeup with interrupt request from input event x is unmasked.</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>IM15</name>
                <description>CPU wakeup with interrupt mask on event input x
When EXTI_SECCFGR.SECx is disabled, IMx can be accessed with non-secure and secure access.
When EXTI_SECCFGR.SECx is enabled, IMx can only be accessed with secure access. Non-secure write to this bit is discarded and non-secure read returns 0.
When EXTI_PRIVCFGR.PRIVx is disabled, IMx can be accessed with privileged and unprivileged access.
When EXTI_PRIVCFGR.PRIVx is enabled, IMx can only be accessed with privileged access. Unprivileged write to this bit is discarded.</description>
                <bitOffset>15</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Wakeup with interrupt request from input event x is masked.</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Wakeup with interrupt request from input event x is unmasked.</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>IM16</name>
                <description>CPU wakeup with interrupt mask on event input x
When EXTI_SECCFGR.SECx is disabled, IMx can be accessed with non-secure and secure access.
When EXTI_SECCFGR.SECx is enabled, IMx can only be accessed with secure access. Non-secure write to this bit is discarded and non-secure read returns 0.
When EXTI_PRIVCFGR.PRIVx is disabled, IMx can be accessed with privileged and unprivileged access.
When EXTI_PRIVCFGR.PRIVx is enabled, IMx can only be accessed with privileged access. Unprivileged write to this bit is discarded.</description>
                <bitOffset>16</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Wakeup with interrupt request from input event x is masked.</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Wakeup with interrupt request from input event x is unmasked.</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
            </fields>
          </register>
          <register>
            <name>EXTI_EMR1</name>
            <displayName>EXTI_EMR1</displayName>
            <description>EXTI CPU wakeup with event mask register</description>
            <addressOffset>0x084</addressOffset>
            <size>0x20</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>EM0</name>
                <description>CPU wakeup with event generation mask on event input x
When EXTI_SECCFGR.SECx is disabled, EMx can be accessed with non-secure and secure access.
When EXTI_SECCFGR.SECx is enabled, EMx can only be accessed with secure access. Non-secure write to this bit x is discarded and non-secure read returns 0.
When EXTI_PRIVCFGR.PRIVx is disabled, EMx can be accessed with privileged and unprivileged access.
When EXTI_PRIVCFGR.PRIVx is enabled, EMx can only be accessed with privileged access. Unprivileged write to this bit is discarded.</description>
                <bitOffset>0</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Wakeup with event generation from Line x is masked.</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Wakeup with event generation from Line x is unmasked.</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>EM1</name>
                <description>CPU wakeup with event generation mask on event input x
When EXTI_SECCFGR.SECx is disabled, EMx can be accessed with non-secure and secure access.
When EXTI_SECCFGR.SECx is enabled, EMx can only be accessed with secure access. Non-secure write to this bit x is discarded and non-secure read returns 0.
When EXTI_PRIVCFGR.PRIVx is disabled, EMx can be accessed with privileged and unprivileged access.
When EXTI_PRIVCFGR.PRIVx is enabled, EMx can only be accessed with privileged access. Unprivileged write to this bit is discarded.</description>
                <bitOffset>1</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Wakeup with event generation from Line x is masked.</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Wakeup with event generation from Line x is unmasked.</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>EM2</name>
                <description>CPU wakeup with event generation mask on event input x
When EXTI_SECCFGR.SECx is disabled, EMx can be accessed with non-secure and secure access.
When EXTI_SECCFGR.SECx is enabled, EMx can only be accessed with secure access. Non-secure write to this bit x is discarded and non-secure read returns 0.
When EXTI_PRIVCFGR.PRIVx is disabled, EMx can be accessed with privileged and unprivileged access.
When EXTI_PRIVCFGR.PRIVx is enabled, EMx can only be accessed with privileged access. Unprivileged write to this bit is discarded.</description>
                <bitOffset>2</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Wakeup with event generation from Line x is masked.</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Wakeup with event generation from Line x is unmasked.</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>EM3</name>
                <description>CPU wakeup with event generation mask on event input x
When EXTI_SECCFGR.SECx is disabled, EMx can be accessed with non-secure and secure access.
When EXTI_SECCFGR.SECx is enabled, EMx can only be accessed with secure access. Non-secure write to this bit x is discarded and non-secure read returns 0.
When EXTI_PRIVCFGR.PRIVx is disabled, EMx can be accessed with privileged and unprivileged access.
When EXTI_PRIVCFGR.PRIVx is enabled, EMx can only be accessed with privileged access. Unprivileged write to this bit is discarded.</description>
                <bitOffset>3</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Wakeup with event generation from Line x is masked.</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Wakeup with event generation from Line x is unmasked.</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>EM4</name>
                <description>CPU wakeup with event generation mask on event input x
When EXTI_SECCFGR.SECx is disabled, EMx can be accessed with non-secure and secure access.
When EXTI_SECCFGR.SECx is enabled, EMx can only be accessed with secure access. Non-secure write to this bit x is discarded and non-secure read returns 0.
When EXTI_PRIVCFGR.PRIVx is disabled, EMx can be accessed with privileged and unprivileged access.
When EXTI_PRIVCFGR.PRIVx is enabled, EMx can only be accessed with privileged access. Unprivileged write to this bit is discarded.</description>
                <bitOffset>4</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Wakeup with event generation from Line x is masked.</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Wakeup with event generation from Line x is unmasked.</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>EM5</name>
                <description>CPU wakeup with event generation mask on event input x
When EXTI_SECCFGR.SECx is disabled, EMx can be accessed with non-secure and secure access.
When EXTI_SECCFGR.SECx is enabled, EMx can only be accessed with secure access. Non-secure write to this bit x is discarded and non-secure read returns 0.
When EXTI_PRIVCFGR.PRIVx is disabled, EMx can be accessed with privileged and unprivileged access.
When EXTI_PRIVCFGR.PRIVx is enabled, EMx can only be accessed with privileged access. Unprivileged write to this bit is discarded.</description>
                <bitOffset>5</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Wakeup with event generation from Line x is masked.</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Wakeup with event generation from Line x is unmasked.</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>EM6</name>
                <description>CPU wakeup with event generation mask on event input x
When EXTI_SECCFGR.SECx is disabled, EMx can be accessed with non-secure and secure access.
When EXTI_SECCFGR.SECx is enabled, EMx can only be accessed with secure access. Non-secure write to this bit x is discarded and non-secure read returns 0.
When EXTI_PRIVCFGR.PRIVx is disabled, EMx can be accessed with privileged and unprivileged access.
When EXTI_PRIVCFGR.PRIVx is enabled, EMx can only be accessed with privileged access. Unprivileged write to this bit is discarded.</description>
                <bitOffset>6</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Wakeup with event generation from Line x is masked.</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Wakeup with event generation from Line x is unmasked.</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>EM7</name>
                <description>CPU wakeup with event generation mask on event input x
When EXTI_SECCFGR.SECx is disabled, EMx can be accessed with non-secure and secure access.
When EXTI_SECCFGR.SECx is enabled, EMx can only be accessed with secure access. Non-secure write to this bit x is discarded and non-secure read returns 0.
When EXTI_PRIVCFGR.PRIVx is disabled, EMx can be accessed with privileged and unprivileged access.
When EXTI_PRIVCFGR.PRIVx is enabled, EMx can only be accessed with privileged access. Unprivileged write to this bit is discarded.</description>
                <bitOffset>7</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Wakeup with event generation from Line x is masked.</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Wakeup with event generation from Line x is unmasked.</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>EM8</name>
                <description>CPU wakeup with event generation mask on event input x
When EXTI_SECCFGR.SECx is disabled, EMx can be accessed with non-secure and secure access.
When EXTI_SECCFGR.SECx is enabled, EMx can only be accessed with secure access. Non-secure write to this bit x is discarded and non-secure read returns 0.
When EXTI_PRIVCFGR.PRIVx is disabled, EMx can be accessed with privileged and unprivileged access.
When EXTI_PRIVCFGR.PRIVx is enabled, EMx can only be accessed with privileged access. Unprivileged write to this bit is discarded.</description>
                <bitOffset>8</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Wakeup with event generation from Line x is masked.</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Wakeup with event generation from Line x is unmasked.</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>EM9</name>
                <description>CPU wakeup with event generation mask on event input x
When EXTI_SECCFGR.SECx is disabled, EMx can be accessed with non-secure and secure access.
When EXTI_SECCFGR.SECx is enabled, EMx can only be accessed with secure access. Non-secure write to this bit x is discarded and non-secure read returns 0.
When EXTI_PRIVCFGR.PRIVx is disabled, EMx can be accessed with privileged and unprivileged access.
When EXTI_PRIVCFGR.PRIVx is enabled, EMx can only be accessed with privileged access. Unprivileged write to this bit is discarded.</description>
                <bitOffset>9</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Wakeup with event generation from Line x is masked.</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Wakeup with event generation from Line x is unmasked.</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>EM10</name>
                <description>CPU wakeup with event generation mask on event input x
When EXTI_SECCFGR.SECx is disabled, EMx can be accessed with non-secure and secure access.
When EXTI_SECCFGR.SECx is enabled, EMx can only be accessed with secure access. Non-secure write to this bit x is discarded and non-secure read returns 0.
When EXTI_PRIVCFGR.PRIVx is disabled, EMx can be accessed with privileged and unprivileged access.
When EXTI_PRIVCFGR.PRIVx is enabled, EMx can only be accessed with privileged access. Unprivileged write to this bit is discarded.</description>
                <bitOffset>10</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Wakeup with event generation from Line x is masked.</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Wakeup with event generation from Line x is unmasked.</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>EM11</name>
                <description>CPU wakeup with event generation mask on event input x
When EXTI_SECCFGR.SECx is disabled, EMx can be accessed with non-secure and secure access.
When EXTI_SECCFGR.SECx is enabled, EMx can only be accessed with secure access. Non-secure write to this bit x is discarded and non-secure read returns 0.
When EXTI_PRIVCFGR.PRIVx is disabled, EMx can be accessed with privileged and unprivileged access.
When EXTI_PRIVCFGR.PRIVx is enabled, EMx can only be accessed with privileged access. Unprivileged write to this bit is discarded.</description>
                <bitOffset>11</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Wakeup with event generation from Line x is masked.</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Wakeup with event generation from Line x is unmasked.</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>EM12</name>
                <description>CPU wakeup with event generation mask on event input x
When EXTI_SECCFGR.SECx is disabled, EMx can be accessed with non-secure and secure access.
When EXTI_SECCFGR.SECx is enabled, EMx can only be accessed with secure access. Non-secure write to this bit x is discarded and non-secure read returns 0.
When EXTI_PRIVCFGR.PRIVx is disabled, EMx can be accessed with privileged and unprivileged access.
When EXTI_PRIVCFGR.PRIVx is enabled, EMx can only be accessed with privileged access. Unprivileged write to this bit is discarded.</description>
                <bitOffset>12</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Wakeup with event generation from Line x is masked.</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Wakeup with event generation from Line x is unmasked.</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>EM13</name>
                <description>CPU wakeup with event generation mask on event input x
When EXTI_SECCFGR.SECx is disabled, EMx can be accessed with non-secure and secure access.
When EXTI_SECCFGR.SECx is enabled, EMx can only be accessed with secure access. Non-secure write to this bit x is discarded and non-secure read returns 0.
When EXTI_PRIVCFGR.PRIVx is disabled, EMx can be accessed with privileged and unprivileged access.
When EXTI_PRIVCFGR.PRIVx is enabled, EMx can only be accessed with privileged access. Unprivileged write to this bit is discarded.</description>
                <bitOffset>13</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Wakeup with event generation from Line x is masked.</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Wakeup with event generation from Line x is unmasked.</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>EM14</name>
                <description>CPU wakeup with event generation mask on event input x
When EXTI_SECCFGR.SECx is disabled, EMx can be accessed with non-secure and secure access.
When EXTI_SECCFGR.SECx is enabled, EMx can only be accessed with secure access. Non-secure write to this bit x is discarded and non-secure read returns 0.
When EXTI_PRIVCFGR.PRIVx is disabled, EMx can be accessed with privileged and unprivileged access.
When EXTI_PRIVCFGR.PRIVx is enabled, EMx can only be accessed with privileged access. Unprivileged write to this bit is discarded.</description>
                <bitOffset>14</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Wakeup with event generation from Line x is masked.</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Wakeup with event generation from Line x is unmasked.</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>EM15</name>
                <description>CPU wakeup with event generation mask on event input x
When EXTI_SECCFGR.SECx is disabled, EMx can be accessed with non-secure and secure access.
When EXTI_SECCFGR.SECx is enabled, EMx can only be accessed with secure access. Non-secure write to this bit x is discarded and non-secure read returns 0.
When EXTI_PRIVCFGR.PRIVx is disabled, EMx can be accessed with privileged and unprivileged access.
When EXTI_PRIVCFGR.PRIVx is enabled, EMx can only be accessed with privileged access. Unprivileged write to this bit is discarded.</description>
                <bitOffset>15</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Wakeup with event generation from Line x is masked.</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Wakeup with event generation from Line x is unmasked.</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>EM16</name>
                <description>CPU wakeup with event generation mask on event input x
When EXTI_SECCFGR.SECx is disabled, EMx can be accessed with non-secure and secure access.
When EXTI_SECCFGR.SECx is enabled, EMx can only be accessed with secure access. Non-secure write to this bit x is discarded and non-secure read returns 0.
When EXTI_PRIVCFGR.PRIVx is disabled, EMx can be accessed with privileged and unprivileged access.
When EXTI_PRIVCFGR.PRIVx is enabled, EMx can only be accessed with privileged access. Unprivileged write to this bit is discarded.</description>
                <bitOffset>16</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Wakeup with event generation from Line x is masked.</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Wakeup with event generation from Line x is unmasked.</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
            </fields>
          </register>
        </registers>
    </peripheral>
    <peripheral derivedFrom="EXTI">
      <name>SEC_EXTI</name>
      <baseAddress>0x56022000</baseAddress>
    </peripheral>
	<peripheral>
        <name>GPDMA</name>
        <description>General purpose direct memory access controller</description>
        <groupName>GPDMA</groupName>
        <baseAddress>0x40020000</baseAddress>
        <addressBlock>
          <offset>0x0</offset>
          <size>0x1000</size>
          <usage>registers</usage>
        </addressBlock>
        <interrupt>
          <name>GPDMA1_CH0</name>
          <description>GPDMA1 channel 0 global interrupt</description>
          <value>029</value>
        </interrupt>
        <interrupt>
          <name>GPDMA1_CH1</name>
          <description>GPDMA1 channel 1 global interrupt</description>
          <value>030</value>
        </interrupt>
        <interrupt>
          <name>GPDMA1_CH2</name>
          <description>GPDMA1 channel 2 global interrupt</description>
          <value>031</value>
        </interrupt>
        <interrupt>
          <name>GPDMA1_CH3</name>
          <description>GPDMA1 channel 3 global interrupt</description>
          <value>032</value>
        </interrupt>
        <interrupt>
          <name>GPDMA1_CH4</name>
          <description>GPDMA1 channel 4 global interrupt</description>
          <value>033</value>
        </interrupt>
        <interrupt>
          <name>GPDMA1_CH5</name>
          <description>GPDMA1 channel 5 global interrupt</description>
          <value>034</value>
        </interrupt>
        <interrupt>
          <name>GPDMA1_CH6</name>
          <description>GPDMA1 channel 6 global interrupt</description>
          <value>035</value>
        </interrupt>
        <interrupt>
          <name>GPDMA1_CH7</name>
          <description>GPDMA1 channel 7 global interrupt</description>
          <value>036</value>
        </interrupt>
        <registers>
          <register>
            <name>GPDMA_SECCFGR</name>
            <displayName>GPDMA_SECCFGR</displayName>
            <description>GPDMA secure configuration register</description>
            <addressOffset>0x00</addressOffset>
            <size>0x20</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>SEC0</name>
                <description>secure state of channel x</description>
                <bitOffset>0</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>non-secure</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>secure</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>SEC1</name>
                <description>secure state of channel x</description>
                <bitOffset>1</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>non-secure</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>secure</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>SEC2</name>
                <description>secure state of channel x</description>
                <bitOffset>2</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>non-secure</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>secure</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>SEC3</name>
                <description>secure state of channel x</description>
                <bitOffset>3</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>non-secure</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>secure</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>SEC4</name>
                <description>secure state of channel x</description>
                <bitOffset>4</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>non-secure</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>secure</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>SEC5</name>
                <description>secure state of channel x</description>
                <bitOffset>5</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>non-secure</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>secure</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>SEC6</name>
                <description>secure state of channel x</description>
                <bitOffset>6</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>non-secure</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>secure</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>SEC7</name>
                <description>secure state of channel x</description>
                <bitOffset>7</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>non-secure</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>secure</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
            </fields>
          </register>
          <register>
            <name>GPDMA_PRIVCFGR</name>
            <displayName>GPDMA_PRIVCFGR</displayName>
            <description>GPDMA privileged configuration register</description>
            <addressOffset>0x04</addressOffset>
            <size>0x20</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>PRIV0</name>
                <description>privileged state of channel x</description>
                <bitOffset>0</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>unprivileged</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>privileged</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>PRIV1</name>
                <description>privileged state of channel x</description>
                <bitOffset>1</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>unprivileged</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>privileged</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>PRIV2</name>
                <description>privileged state of channel x</description>
                <bitOffset>2</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>unprivileged</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>privileged</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>PRIV3</name>
                <description>privileged state of channel x</description>
                <bitOffset>3</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>unprivileged</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>privileged</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>PRIV4</name>
                <description>privileged state of channel x</description>
                <bitOffset>4</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>unprivileged</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>privileged</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>PRIV5</name>
                <description>privileged state of channel x</description>
                <bitOffset>5</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>unprivileged</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>privileged</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>PRIV6</name>
                <description>privileged state of channel x</description>
                <bitOffset>6</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>unprivileged</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>privileged</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>PRIV7</name>
                <description>privileged state of channel x</description>
                <bitOffset>7</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>unprivileged</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>privileged</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
            </fields>
          </register>
          <register>
            <name>GPDMA_RCFGLOCKR</name>
            <displayName>GPDMA_RCFGLOCKR</displayName>
            <description>GPDMA configuration lock register</description>
            <addressOffset>0x08</addressOffset>
            <size>0x20</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>LOCK0</name>
                <description>lock the configuration of GPDMA_SECCFGR.SECx and GPDMA_PRIVCFGR.PRIVx, until a global GPDMA reset
This bit is cleared after reset and, once set, it cannot be reset until a global GPDMA reset.</description>
                <bitOffset>0</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>secure privilege configuration of the channel x is writable.</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>secure privilege configuration of the channel x is not writable.</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>LOCK1</name>
                <description>lock the configuration of GPDMA_SECCFGR.SECx and GPDMA_PRIVCFGR.PRIVx, until a global GPDMA reset
This bit is cleared after reset and, once set, it cannot be reset until a global GPDMA reset.</description>
                <bitOffset>1</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>secure privilege configuration of the channel x is writable.</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>secure privilege configuration of the channel x is not writable.</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>LOCK2</name>
                <description>lock the configuration of GPDMA_SECCFGR.SECx and GPDMA_PRIVCFGR.PRIVx, until a global GPDMA reset
This bit is cleared after reset and, once set, it cannot be reset until a global GPDMA reset.</description>
                <bitOffset>2</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>secure privilege configuration of the channel x is writable.</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>secure privilege configuration of the channel x is not writable.</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>LOCK3</name>
                <description>lock the configuration of GPDMA_SECCFGR.SECx and GPDMA_PRIVCFGR.PRIVx, until a global GPDMA reset
This bit is cleared after reset and, once set, it cannot be reset until a global GPDMA reset.</description>
                <bitOffset>3</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>secure privilege configuration of the channel x is writable.</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>secure privilege configuration of the channel x is not writable.</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>LOCK4</name>
                <description>lock the configuration of GPDMA_SECCFGR.SECx and GPDMA_PRIVCFGR.PRIVx, until a global GPDMA reset
This bit is cleared after reset and, once set, it cannot be reset until a global GPDMA reset.</description>
                <bitOffset>4</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>secure privilege configuration of the channel x is writable.</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>secure privilege configuration of the channel x is not writable.</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>LOCK5</name>
                <description>lock the configuration of GPDMA_SECCFGR.SECx and GPDMA_PRIVCFGR.PRIVx, until a global GPDMA reset
This bit is cleared after reset and, once set, it cannot be reset until a global GPDMA reset.</description>
                <bitOffset>5</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>secure privilege configuration of the channel x is writable.</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>secure privilege configuration of the channel x is not writable.</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>LOCK6</name>
                <description>lock the configuration of GPDMA_SECCFGR.SECx and GPDMA_PRIVCFGR.PRIVx, until a global GPDMA reset
This bit is cleared after reset and, once set, it cannot be reset until a global GPDMA reset.</description>
                <bitOffset>6</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>secure privilege configuration of the channel x is writable.</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>secure privilege configuration of the channel x is not writable.</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>LOCK7</name>
                <description>lock the configuration of GPDMA_SECCFGR.SECx and GPDMA_PRIVCFGR.PRIVx, until a global GPDMA reset
This bit is cleared after reset and, once set, it cannot be reset until a global GPDMA reset.</description>
                <bitOffset>7</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>secure privilege configuration of the channel x is writable.</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>secure privilege configuration of the channel x is not writable.</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
            </fields>
          </register>
          <register>
            <name>GPDMA_MISR</name>
            <displayName>GPDMA_MISR</displayName>
            <description>GPDMA non-secure masked interrupt status register</description>
            <addressOffset>0x0C</addressOffset>
            <size>0x20</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>MIS0</name>
                <description>masked interrupt status of channel x</description>
                <bitOffset>0</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>no interrupt occurred on channel x</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>an interrupt occurred on channel x</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>MIS1</name>
                <description>masked interrupt status of channel x</description>
                <bitOffset>1</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>no interrupt occurred on channel x</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>an interrupt occurred on channel x</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>MIS2</name>
                <description>masked interrupt status of channel x</description>
                <bitOffset>2</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>no interrupt occurred on channel x</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>an interrupt occurred on channel x</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>MIS3</name>
                <description>masked interrupt status of channel x</description>
                <bitOffset>3</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>no interrupt occurred on channel x</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>an interrupt occurred on channel x</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>MIS4</name>
                <description>masked interrupt status of channel x</description>
                <bitOffset>4</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>no interrupt occurred on channel x</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>an interrupt occurred on channel x</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>MIS5</name>
                <description>masked interrupt status of channel x</description>
                <bitOffset>5</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>no interrupt occurred on channel x</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>an interrupt occurred on channel x</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>MIS6</name>
                <description>masked interrupt status of channel x</description>
                <bitOffset>6</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>no interrupt occurred on channel x</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>an interrupt occurred on channel x</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>MIS7</name>
                <description>masked interrupt status of channel x</description>
                <bitOffset>7</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>no interrupt occurred on channel x</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>an interrupt occurred on channel x</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
            </fields>
          </register>
          <register>
            <name>GPDMA_SMISR</name>
            <displayName>GPDMA_SMISR</displayName>
            <description>GPDMA secure masked interrupt status register</description>
            <addressOffset>0x10</addressOffset>
            <size>0x20</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>MIS0</name>
                <description>masked interrupt status of the secure channel x</description>
                <bitOffset>0</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>no interrupt occurred on the secure channel x</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>an interrupt occurred on the secure channel x</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>MIS1</name>
                <description>masked interrupt status of the secure channel x</description>
                <bitOffset>1</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>no interrupt occurred on the secure channel x</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>an interrupt occurred on the secure channel x</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>MIS2</name>
                <description>masked interrupt status of the secure channel x</description>
                <bitOffset>2</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>no interrupt occurred on the secure channel x</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>an interrupt occurred on the secure channel x</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>MIS3</name>
                <description>masked interrupt status of the secure channel x</description>
                <bitOffset>3</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>no interrupt occurred on the secure channel x</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>an interrupt occurred on the secure channel x</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>MIS4</name>
                <description>masked interrupt status of the secure channel x</description>
                <bitOffset>4</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>no interrupt occurred on the secure channel x</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>an interrupt occurred on the secure channel x</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>MIS5</name>
                <description>masked interrupt status of the secure channel x</description>
                <bitOffset>5</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>no interrupt occurred on the secure channel x</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>an interrupt occurred on the secure channel x</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>MIS6</name>
                <description>masked interrupt status of the secure channel x</description>
                <bitOffset>6</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>no interrupt occurred on the secure channel x</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>an interrupt occurred on the secure channel x</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>MIS7</name>
                <description>masked interrupt status of the secure channel x</description>
                <bitOffset>7</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>no interrupt occurred on the secure channel x</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>an interrupt occurred on the secure channel x</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
            </fields>
          </register>
          <register>
            <name>GPDMA_C0LBAR</name>
            <displayName>GPDMA_C0LBAR</displayName>
            <description>GPDMA channel 0 linked-list base address register</description>
            <addressOffset>0x50</addressOffset>
            <size>0x20</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>LBA</name>
                <description>linked-list base address of GPDMA channel x</description>
                <bitOffset>16</bitOffset>
                <bitWidth>16</bitWidth>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>GPDMA_C0FCR</name>
            <displayName>GPDMA_C0FCR</displayName>
            <description>GPDMA channel 0 flag clear register</description>
            <addressOffset>0x5C</addressOffset>
            <size>0x20</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>TCF</name>
                <description>transfer complete flag clear</description>
                <bitOffset>8</bitOffset>
                <bitWidth>1</bitWidth>
                <access>write-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>no effect</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>corresponding TCF flag cleared</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>HTF</name>
                <description>half transfer flag clear</description>
                <bitOffset>9</bitOffset>
                <bitWidth>1</bitWidth>
                <access>write-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>no effect</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>corresponding HTF flag cleared</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>DTEF</name>
                <description>data transfer error flag clear</description>
                <bitOffset>10</bitOffset>
                <bitWidth>1</bitWidth>
                <access>write-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>no effect</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>corresponding DTEF flag cleared</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>ULEF</name>
                <description>update link transfer error flag clear</description>
                <bitOffset>11</bitOffset>
                <bitWidth>1</bitWidth>
                <access>write-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>no effect</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>corresponding ULEF flag cleared</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>USEF</name>
                <description>user setting error flag clear</description>
                <bitOffset>12</bitOffset>
                <bitWidth>1</bitWidth>
                <access>write-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>no effect</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>corresponding USEF flag cleared</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>SUSPF</name>
                <description>completed suspension flag clear</description>
                <bitOffset>13</bitOffset>
                <bitWidth>1</bitWidth>
                <access>write-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>no effect</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>corresponding SUSPF flag cleared</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>TOF</name>
                <description>trigger overrun flag clear</description>
                <bitOffset>14</bitOffset>
                <bitWidth>1</bitWidth>
                <access>write-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>no effect</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>corresponding TOF flag cleared</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
            </fields>
          </register>
          <register>
            <name>GPDMA_C0SR</name>
            <displayName>GPDMA_C0SR</displayName>
            <description>GPDMA channel 0 status register</description>
            <addressOffset>0x60</addressOffset>
            <size>0x20</size>
            <resetValue>0x00000001</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>IDLEF</name>
                <description>idle flag
This idle flag is deasserted by hardware when the channel is enabled (GPDMA_CxCR.EN = 1) with a valid channel configuration (no USEF to be immediately reported).
This idle flag is asserted after hard reset or by hardware when the channel is back in idle state (in suspended or disabled state).</description>
                <bitOffset>0</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>channel not in idle state</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>channel in idle state</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>TCF</name>
                <description>transfer complete flag
A transfer complete event is either a block transfer complete, or a LLI transfer complete including the upload of the next LLI if any, or the full linked-list completion, depending on the transfer complete event mode (GPDMA_CxTR2.TCEM[1:0]).</description>
                <bitOffset>8</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>no transfer complete event</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>a transfer complete event occurred</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>HTF</name>
                <description>half transfer flag
A half block transfer occurs when half of the bytes of the source block size (rounded up integer of GPDMA_CxBR1.BNDT[15:0]/2) has been transferred to the destination.</description>
                <bitOffset>9</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>no half transfer event</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>a half transfer event occurred</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>DTEF</name>
                <description>data transfer error flag</description>
                <bitOffset>10</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>no data transfer error event</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>a master bus error event occurred on a data transfer</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>ULEF</name>
                <description>update link transfer error flag</description>
                <bitOffset>11</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>no update link transfer error event</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>a master bus error event occurred while updating a linked-list register from memory</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>USEF</name>
                <description>user setting error flag</description>
                <bitOffset>12</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>no user setting error event</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>a user setting error event occurred</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>SUSPF</name>
                <description>completed suspension flag</description>
                <bitOffset>13</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>no completed suspension event</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>a completed suspension event occurred</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>TOF</name>
                <description>trigger overrun flag</description>
                <bitOffset>14</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>no trigger overrun event</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>a trigger overrun event occurred</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>FIFOL</name>
                <description>monitored FIFO level
Number of available write beats in the FIFO, in units of the programmed destination data width (see GPDMA_CxTR1.DDW_LOG2[1:0], in units of bytes, half-words, or words).
Note: After having suspended an active transfer, the user may need to read FIFOL[7:0], additionally to GPDMA_CxBR1.BDNT[15:0] to know how many data have been transferred to the destination. Before reading, the user may wait for the transfer to be suspended (GPDMA_CxSR.SUSPF = 1).</description>
                <bitOffset>16</bitOffset>
                <bitWidth>8</bitWidth>
                <access>read-only</access>
              </field>
            </fields>
          </register>
          <register>
            <name>GPDMA_C0CR</name>
            <displayName>GPDMA_C0CR</displayName>
            <description>GPDMA channel 0 control register</description>
            <addressOffset>0x64</addressOffset>
            <size>0x20</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>EN</name>
                <description>enable
Writing 1 into the field RESET (bit 1) causes the hardware to de-assert this bit, whatever is written into this bit 0. Else: 
this bit is deasserted by hardware when there is a transfer error (master bus error or user setting error) or when there is a channel transfer complete (channel ready to be configured, for example if LSM=1 at the end of a single execution of the LLI).
Else, this bit can be asserted by software. 
Writing 0 into this EN bit is ignored.</description>
                <bitOffset>0</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>write: ignored, read: channel disabled</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>write: enable channel, read: channel enabled</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>RESET</name>
                <description>reset
This bit is write only. Writing 0 has no impact. Writing 1 implies the reset of the following: the FIFO, the channel internal state, SUSP and EN bits (whatever is written receptively in bit 2 and bit 0).
The reset is effective when the channel is in steady state, meaning one of the following:
- active channel in suspended state (GPDMA_CxSR.SUSPF = 1 and GPDMA_CxSR.IDLEF = GPDMA_CxCR.EN = 1)
- channel in disabled state (GPDMA_CxSR.IDLEF = 1 and GPDMA_CxCR.EN = 0).
After writing a RESET, to continue using this channel, the user must explicitly reconfigure the channel including the hardware-modified configuration registers (GPDMA_CxBR1, GPDMA_CxSAR and GPDMA_CxDAR) before enabling again the channel (see the programming sequence in Figure 44).</description>
                <bitOffset>1</bitOffset>
                <bitWidth>1</bitWidth>
                <access>write-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>no channel reset</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>channel reset</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>SUSP</name>
                <description>suspend
Writing 1 into the field RESET (bit 1) causes the hardware to de-assert this bit, whatever is written into this bit 2. Else:
Software must write 1 in order to suspend an active channel (channel with an ongoing GPDMA transfer over its master ports). 
The software must write 0 in order to resume a suspended channel, following the programming sequence detailed in Figure 43.</description>
                <bitOffset>2</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>write: resume channel, read: channel not suspended</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>write: suspend channel, read: channel suspended.</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>TCIE</name>
                <description>transfer complete interrupt enable</description>
                <bitOffset>8</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>interrupt disabled</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>interrupt enabled</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>HTIE</name>
                <description>half transfer complete interrupt enable</description>
                <bitOffset>9</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>interrupt disabled</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>interrupt enabled</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>DTEIE</name>
                <description>data transfer error interrupt enable</description>
                <bitOffset>10</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>interrupt disabled</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>interrupt enabled</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>ULEIE</name>
                <description>update link transfer error interrupt enable</description>
                <bitOffset>11</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>interrupt disabled</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>interrupt enabled</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>USEIE</name>
                <description>user setting error interrupt enable</description>
                <bitOffset>12</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>interrupt disabled</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>interrupt enabled</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>SUSPIE</name>
                <description>completed suspension interrupt enable</description>
                <bitOffset>13</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>interrupt disabled</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>interrupt enabled</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>TOIE</name>
                <description>trigger overrun interrupt enable</description>
                <bitOffset>14</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>interrupt disabled</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>interrupt enabled</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>LSM</name>
                <description>Link step mode
First the (possible 1D/repeated) block transfer is executed as defined by the current internal register file until GPDMA_CxBR1.BNDT[15:0] = 0. Secondly the next linked-list data structure is conditionally uploaded from memory as defined by GPDMA_CxLLR. Then channel execution is completed.
Note: This bit must be written when EN=0. This bit is read-only when EN=1.</description>
                <bitOffset>16</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>channel executed for the full linked-list and completed at the end of the last LLI (GPDMA_CxLLR = 0). The 16 low-significant bits of the link address are null (LA[15:0] = 0) and all the update bits are null (UT1 =UB1 = UT2 = USA = UDA = ULL = 0). Then GPDMA_CxBR1.BNDT[15:0] = 0.</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>channel executed once for the current LLI</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>LAP</name>
                <description>linked-list allocated port
This bit is used to allocate the master port for the update of the GPDMA linked-list registers from the memory.
Note: This bit must be written when EN=0. This bit is read-only when EN=1.</description>
                <bitOffset>17</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>port 0 (AHB) allocated</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>port 1 (AHB) allocated</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>PRIO</name>
                <description>priority level of the channel x GPDMA transfer versus others
Note: This bit must be written when EN = 0. This bit is read-only when EN = 1.</description>
                <bitOffset>22</bitOffset>
                <bitWidth>2</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>low priority, low weight</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>low priority, mid weight</description>
                    <value>0x1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x2</name>
                    <description>low priority, high weight</description>
                    <value>0x2</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x3</name>
                    <description>high priority</description>
                    <value>0x3</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
            </fields>
          </register>
          <register>
            <name>GPDMA_C0TR1</name>
            <displayName>GPDMA_C0TR1</displayName>
            <description>GPDMA channel 0 transfer register 1</description>
            <addressOffset>0x90</addressOffset>
            <size>0x20</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>SDW_LOG2</name>
                <description>binary logarithm of the source data width of a burst in bytes
Setting a 8-byte data width causes a user setting error to be reported and no transfer is issued.
A source block size must be a multiple of the source data width (GPDMA_CxBR1.BNDT[2:0] versus SDW_LOG2[1:0]). Otherwise, a user setting error is reported and no transfer is issued.
Note: A source burst transfer must have an aligned address with its data width (start address GPDMA_CxSAR[2:0] versus SDW_LOG2[1:0]). Otherwise, a user setting error is reported and none transfer is issued.</description>
                <bitOffset>0</bitOffset>
                <bitWidth>2</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>byte</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>half-word (2 bytes)</description>
                    <value>0x1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x2</name>
                    <description>word (4 bytes)</description>
                    <value>0x2</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x3</name>
                    <description>user setting error reported and no transfer issued</description>
                    <value>0x3</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>SINC</name>
                <description>source incrementing burst
The source address, pointed by GPDMA_CxSAR, is kept constant after a burst beat/single transfer or is incremented by the offset value corresponding to a contiguous data after a burst beat/single transfer.</description>
                <bitOffset>3</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>fixed burst</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>contiguously incremented burst</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>SBL_1</name>
                <description>source burst length minus 1, between 0 and 63
The burst length unit is one data named beat within a burst. If SBL_1[5:0] =0 , the burst can be named as single. Each data/beat has a width defined by the destination data width SDW_LOG2[1:0].
Note: If a burst transfer crossed a 1-Kbyte address boundary on a AHB transfer, the GPDMA modifies and shortens the programmed burst into singles or bursts of lower length, to be compliant with the AHB protocol.
Note: If a burst transfer is of length greater than the FIFO size of the channel x, the GPDMA modifies and shortens the programmed burst into singles or bursts of lower length, to be compliant with the FIFO size. Transfer performance is lower, with GPDMA re-arbitration between effective and lower singles/bursts, but the data integrity is guaranteed.</description>
                <bitOffset>4</bitOffset>
                <bitWidth>6</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>PAM</name>
                <description>padding/alignment mode
If DDW_LOG2[1:0] = SDW_LOG2[1:0]: if the data width of a burst destination transfer is equal to the data width of a burst source transfer, these bits are ignored.
Else, in the following enumerated values, the condition PAM_1 is when destination data width is higher that source data width, and the condition PAM_2 is when destination data width is higher than source data width.
1x: successive source data are FIFO queued and packed at the destination data width, in a left (LSB) to right (MSB) order (named little endian), before a destination transfer
Note: 1x: source data is FIFO queued and unpacked at the destination data width, to be transferred in a left (LSB) to right (MSB) order (named little endian) to the destination</description>
                <bitOffset>11</bitOffset>
                <bitWidth>2</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0_PAM_1</name>
                    <description>source data is transferred as right aligned, padded with 0s up to the destination data width</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1_PAM_1</name>
                    <description>source data is transferred as right aligned, sign extended up to the destination data width</description>
                    <value>0x1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x0_PAM_2</name>
                    <description>source data is transferred as right aligned, left-truncated down to the destination data width</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1_PAM_2</name>
                    <description>source data is transferred as left-aligned, right-truncated down to the destination data width</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>SBX</name>
                <description>source byte exchange within the unaligned half-word of each source word 
If the source data width is shorter than a word, this bit is ignored.
If the source data width is a word:</description>
                <bitOffset>13</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>no byte-based exchange within the unaligned half-word of each source word</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>the two consecutive bytes within the unaligned half-word of each source word are exchanged.</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>SAP</name>
                <description>source allocated port
This bit is used to allocate the master port for the source transfer
Note: This bit must be written when EN = 0. This bit is read-only when EN = 1.</description>
                <bitOffset>14</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>port 0 (AHB) allocated</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>port 1 (AHB) allocated</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>SSEC</name>
                <description>security attribute of the GPDMA transfer from the source
If GPDMA_SECCFGR.SECx = 1 and the access is secure:
This is a secure register bit. This bit can only be read by a secure software. This bit must be written by a secure software when GPDMA_SECCFGR.SECx =1 . A secure write is ignored when GPDMA_SECCFGR.SECx = 0.
When GPDMA_SECCFGR.SECx is deasserted, this SSEC bit is also deasserted by hardware (on a secure reconfiguration of the channel as non-secure), and the GPDMA transfer from the source is non-secure.</description>
                <bitOffset>15</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>GPDMA transfer non-secure</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>GPDMA transfer secure</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>DDW_LOG2</name>
                <description>binary logarithm of the destination data width of a burst, in bytes
Setting a 8-byte data width causes a user setting error to be reported and none transfer is issued.
Note: A destination burst transfer must have an aligned address with its data width (start address GPDMA_CxDAR[2:0] versus DDW_LOG2[1:0]). Otherwise a user setting error is reported and no transfer is issued.</description>
                <bitOffset>16</bitOffset>
                <bitWidth>2</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>byte</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>half-word (2 bytes)</description>
                    <value>0x1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x2</name>
                    <description>word (4 bytes)</description>
                    <value>0x2</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x3</name>
                    <description>user setting error reported and no transfer issued</description>
                    <value>0x3</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>DINC</name>
                <description>destination incrementing burst
The destination address, pointed by GPDMA_CxDAR, is kept constant after a burst beat/single transfer, or is incremented by the offset value corresponding to a contiguous data after a burst beat/single transfer.</description>
                <bitOffset>19</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>fixed burst</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>contiguously incremented burst</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>DBL_1</name>
                <description>destination burst length minus 1, between 0 and 63
The burst length unit is one data named beat within a burst. If DBL_1[5:0] =0 , the burst can be named as single. Each data/beat has a width defined by the destination data width DDW_LOG2[1:0].
Note: If a burst transfer crossed a 1-Kbyte address boundary on a AHB transfer, the GPDMA modifies and shortens the programmed burst into singles or bursts of lower length, to be compliant with the AHB protocol.
Note: If a burst transfer is of length greater than the FIFO size of the channel x, the GPDMA modifies and shortens the programmed burst into singles or bursts of lower length, to be compliant with the FIFO size. Transfer performance is lower, with GPDMA re-arbitration between effective and lower singles/bursts, but the data integrity is guaranteed.</description>
                <bitOffset>20</bitOffset>
                <bitWidth>6</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>DBX</name>
                <description>destination byte exchange
If the destination data size is a byte, this bit is ignored.
If the destination data size is not a byte:</description>
                <bitOffset>26</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>no byte-based exchange within half-word</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>the two consecutive (post PAM) bytes are exchanged in each destination half-word.</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>DHX</name>
                <description>destination half-word exchange
If the destination data size is shorter than a word, this bit is ignored.
If the destination data size is a word:</description>
                <bitOffset>27</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>no halfword-based exchanged within word</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>the two consecutive (post PAM) half-words are exchanged in each destination word.</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>DAP</name>
                <description>destination allocated port
This bit is used to allocate the master port for the destination transfer
Note: This bit must be written when EN = 0. This bit is read-only when EN = 1.</description>
                <bitOffset>30</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>port 0 (AHB) allocated</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>port 1 (AHB) allocated</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>DSEC</name>
                <description>security attribute of the GPDMA transfer to the destination
If GPDMA_SECCFGR.SECx = 1 and the access is secure:
This is a secure register bit. This bit can only be read by a secure software. This bit must be written by a secure software when GPDMA_SECCFGR.SECx = 1. A secure write is ignored when GPDMA_SECCFGR.SECx = 0.
When GPDMA_SECCFGR.SECx is deasserted, this DSEC bit is also deasserted by hardware (on a secure reconfiguration of the channel as non-secure), and the GPDMA transfer to the destination is non-secure.</description>
                <bitOffset>31</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>GPDMA transfer non-secure</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>GPDMA transfer secure</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
            </fields>
          </register>
          <register>
            <name>GPDMA_C0TR2</name>
            <displayName>GPDMA_C0TR2</displayName>
            <description>GPDMA channel 0 transfer register 2</description>
            <addressOffset>0x94</addressOffset>
            <size>0x20</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>REQSEL</name>
                <description>GPDMA hardware request selection
These bits are ignored if channel x is activated (GPDMA_CxCR.EN asserted) with SWREQ = 1 (software request for a memory-to-memory transfer). Else, the selected hardware request is internally taken into account as per Section 16.3.3.
The user must not assign a same input hardware request (same REQSEL[5:0] value) to different active GPDMA channels (GPDMA_CxCR.EN = 1 and GPDMA_CxTR2.SWREQ = 0 for these channels). GPDMA is not intended to hardware support the case of simultaneous enabled channels incorrectly configured with a same hardware peripheral request signal, and there is no user setting error reporting.</description>
                <bitOffset>0</bitOffset>
                <bitWidth>6</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>SWREQ</name>
                <description>software request
This bit is internally taken into account when GPDMA_CxCR.EN is asserted.</description>
                <bitOffset>9</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>no software request. The selected hardware request REQSEL[5:0] is taken into account.</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>software request for a memory-to-memory transfer. The default selected hardware request as per REQSEL[5:0] is ignored.</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>DREQ</name>
                <description>destination hardware request
This bit is ignored if channel x is activated (GPDMA_CxCR.EN asserted) with SWREQ = 1 (software request for a memory-to-memory transfer). Else:</description>
                <bitOffset>10</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>selected hardware request driven by a source peripheral (request signal taken into account by the GPDMA transfer scheduler over the source/read port)</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>selected hardware request driven by a destination peripheral (request signal taken into account by the GPDMA transfer scheduler over the destination/write port)</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>BREQ</name>
                <description>Block hardware request
If the channel x is activated (GPDMA_CxCR.EN asserted) with SWREQ = 1 (software request for a memory-to-memory transfer), this bit is ignored. Else:</description>
                <bitOffset>11</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>the selected hardware request is driven by a peripheral with a hardware request/acknowledge protocol at a burst level.</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>the selected hardware request is driven by a peripheral with a hardware request/acknowledge protocol at a block level (see Section 16.3.3).</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>TRIGM</name>
                <description>trigger mode
These bits define the transfer granularity for its conditioning by the trigger.
If the channel x is enabled (GPDMA_CxCR.EN asserted) with TRIGPOL[1:0] = 00 or 11, these TRIGM[1:0] bits are ignored.
Else, a GPDMA transfer is conditioned by at least one trigger hit: 
 If the peripheral is programmed as a source (DREQ = 0) of the LLI data transfer, each programmed burst read is conditioned.
 If the peripheral is programmed as a destination (DREQ = 1) of the LLI data transfer, each programmed burst write is conditioned. The first memory burst read of a block, also named as the first ready FIFO-based source burst, is gated by the occurrence of both the hardware request and the first trigger hit.
The GPDMA monitoring of a trigger for channel x is started when the channel is enabled/loaded with a new active trigger configuration: rising or falling edge on a selected trigger (TRIGPOL[1:0] = 01 or respectively TRIGPOL[1:0] = 10).
The monitoring of this trigger is kept active during the triggered and uncompleted (data or link) transfer; and if a new trigger is detected then, this hit is internally memorized to grant the next transfer, as long as the defined rising or falling edge is not modified, and the TRIGSEL[4:0] is not modified, and the channel is enabled.
Transferring a next LLI&lt;sub&gt;n+1&lt;/sub&gt; that updates the GPDMA_CxTR2 with a new value for any of TRIGSEL[4:0] or TRIGPOL[1:0], resets the monitoring, trashing the memorized hit of the formerly defined LLI&lt;sub&gt;n &lt;/sub&gt;trigger.
After a first new trigger hit&lt;sub&gt;n+1&lt;/sub&gt; is memorized, if another second trigger hit&lt;sub&gt;n+2&lt;/sub&gt; is detected and if the hit&lt;sub&gt;n&lt;/sub&gt; triggered transfer is still not completed, hit&lt;sub&gt;n+2 &lt;/sub&gt;is lost and not memorized.memorized. A trigger overrun flag is reported (GPDMA_CxSR.TOF =1 ), and an interrupt is generated if enabled (GPDMA_CxCR.TOIE = 1). The channel is not automatically disabled by hardware due to a trigger overrun. 
Note: When the source block size is not a multiple of the source burst size and is a multiple of the source data width, then the last programmed source burst is not completed and is internally shorten to match the block size. In this case, if TRIGM[1:0] = 11 and (SWREQ =1  or (SWREQ = 0 and DREQ =0 )), the shortened burst transfer (by singles or/and by bursts of lower length) is conditioned once by the trigger.
Note: When the programmed destination burst is internally shortened by singles or/and by bursts of lower length (versus FIFO size, versus block size, 1-Kbyte boundary address crossing): if the trigger is conditioning the programmed destination burst (if TRIGM[1:0] = 11 and SWREQ = 0 and DREQ = 1), this shortened destination burst transfer is conditioned once by the trigger.</description>
                <bitOffset>14</bitOffset>
                <bitWidth>2</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>at block level: the first burst read of each block transfer is conditioned by one hit trigger .</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>channel x = 0 to 7, same as 0010: at link level: a LLI link transfer is conditioned by one hit trigger. The LLI data transfer (if any) is not conditioned.</description>
                    <value>0x1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x3</name>
                    <description>at programmed burst level: If SWREQ = 1, each programmed burst read is conditioned by one hit trigger. If SWREQ = 0, each programmed burst that is requested by the selected peripheral, is conditioned by one hit trigger.</description>
                    <value>0x3</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>TRIGSEL</name>
                <description>trigger event input selection
These bits select the trigger event input of the GPDMA transfer (as per Section 16.3.5), with an active trigger event if TRIGPOL[1:0]  00.</description>
                <bitOffset>16</bitOffset>
                <bitWidth>5</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>TRIGPOL</name>
                <description>trigger event polarity
These bits define the polarity of the selected trigger event input defined by TRIGSEL[4:0].</description>
                <bitOffset>24</bitOffset>
                <bitWidth>2</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>no trigger (masked trigger event)</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>trigger on the rising edge</description>
                    <value>0x1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x2</name>
                    <description>trigger on the falling edge</description>
                    <value>0x2</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x3</name>
                    <description>same as 00</description>
                    <value>0x3</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>TCEM</name>
                <description>transfer complete event mode
These bits define the transfer granularity for the transfer complete and half transfer complete events generation.
Note: If the initial LLI&lt;sub&gt;0 &lt;/sub&gt;data transfer is null/void (directly programmed by the internal register file with GPDMA_CxBR1.BNDT[15:0] = 0), then neither the complete transfer event nor the half transfer event is generated.
Note: If the initial LLI&lt;sub&gt;0 &lt;/sub&gt;data transfer is null/void (directly programmed by the internal register file with GPDMA_CxBR1.BNDT[15:0] = 0), then neither the complete transfer event nor the half transfer event is generated.
Note: If the initial LLI&lt;sub&gt;0 &lt;/sub&gt;data transfer is null/void (i.e. directly programmed by the internal register file with GPDMA_CxBR1.BNDT[15:0] =0 ), then the half transfer event is not generated, and the transfer complete event is generated when is completed the loading of the LLI&lt;sub&gt;1&lt;/sub&gt;.</description>
                <bitOffset>30</bitOffset>
                <bitWidth>2</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>at block level (when GPDMA_CxBR1.BNDT[15:0] = 0): the complete (and the half) transfer event is generated at the (respectively half of the) end of a block.</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>channel x (0 to 7, same as 00</description>
                    <value>0x1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x2</name>
                    <description>at LLI level: the complete transfer event is generated at the end of the LLI transfer, including the update of the LLI if any. The half transfer event is generated at the half of the LLI data transfer.</description>
                    <value>0x2</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x3</name>
                    <description>at channel level: the complete transfer event is generated at the end of the last LLI transfer. The half transfer event is generated at the half of the data transfer of the last LLI. The last LLI updates the link address GPDMA_CxLLR.LA[15:2] to zero and clears all the GPDMA_CxLLR update bits (UT1, UT2, UB1, USA, UDA and ULL). If the channel transfer is continuous/infinite, no event is generated.</description>
                    <value>0x3</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
            </fields>
          </register>
          <register>
            <name>GPDMA_C0BR1</name>
            <displayName>GPDMA_C0BR1</displayName>
            <description>GPDMA channel 0 block register 1</description>
            <addressOffset>0x98</addressOffset>
            <size>0x20</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>BNDT</name>
                <description>block number of data bytes to transfer from the source
Block size transferred from the source. When the channel is enabled, this field becomes read-only and is decremented, indicating the remaining number of data items in the current source block to be transferred. BNDT[15:0] is programmed in number of bytes, maximum source block size is 64 Kbytes -1.
Once the last data transfer is completed (BNDT[15:0] = 0):
- if GPDMA_CxLLR.UB1 = 1, this field is updated by the LLI in the memory.
- if GPDMA_CxLLR.UB1 = 0 and if there is at least one non null Uxx update bit, this field is internally restored to the programmed value.
- if all GPDMA_CxLLR.Uxx = 0 and if GPDMA_CxLLR.LA[15:0] = 0, this field is internally restored to the programmed value (infinite/continuous last LLI).
- if GPDMA_CxLLR = 0, this field is kept as zero following the last LLI data transfer.
Note: A non-null source block size must be a multiple of the source data width (BNDT[2:0] versus GPDMA_CxTR1.SDW_LOG2[1:0]). Else a user setting error is reported and no transfer is issued.
Note: When configured in packing mode (GPDMA_CxTR1.PAM[1] = 1 and destination data width different from source data width), a non-null source block size must be a multiple of the destination data width (BNDT[2:0] versus GPDMA_CxTR1.DDW_LOG2[1:0]). Else a user setting error is reported and no transfer is issued.</description>
                <bitOffset>0</bitOffset>
                <bitWidth>16</bitWidth>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>GPDMA_C0SAR</name>
            <displayName>GPDMA_C0SAR</displayName>
            <description>GPDMA channel 0 source address register</description>
            <addressOffset>0x9C</addressOffset>
            <size>0x20</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>SA</name>
                <description>source address
This field is the pointer to the address from which the next data is read.
During the channel activity, depending on the source addressing mode (GPDMA_CxTR1.SINC), this field is kept fixed or incremented by the data width (GPDMA_CxTR1.SDW_LOG2[1:0]) after each burst source data, reflecting the next address from which data is read.
During the channel activity, this address is updated after each completed source burst, consequently to:
the programmed source burst; either in fixed addressing mode or in contiguous-data incremented mode. If contiguously incremented (GPDMA_CxTR1.SINC = 1), then the additional address offset value is the programmed burst size, as defined by GPDMA_CxTR1.SBL_1[5:0] and GPDMA_CxTR1.SDW_LOG2[21:0]
the additional source incremented/decremented offset value as programmed by GPDMA_CxBR1.SDEC
In linked-list mode, after a LLI data transfer is completed, this register is automatically updated by GPDMA from the memory, provided the LLI is set with GPDMA_CxLLR.USA = 1.
Note: A source address must be aligned with the programmed data width of a source burst (SA[2:0] versus GPDMA_CxTR1.SDW_LOG2[1:0]). Else, a user setting error is reported and no transfer is issued.</description>
                <bitOffset>0</bitOffset>
                <bitWidth>32</bitWidth>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>GPDMA_C0DAR</name>
            <displayName>GPDMA_C0DAR</displayName>
            <description>GPDMA channel 0 destination address register</description>
            <addressOffset>0xA0</addressOffset>
            <size>0x20</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>DA</name>
                <description>destination address
This field is the pointer to the address from which the next data is written.
During the channel activity, depending on the destination addressing mode (GPDMA_CxTR1.DINC), this field is kept fixed or incremented by the data width (GPDMA_CxTR1.DDW_LOG2[21:0]) after each burst destination data, reflecting the next address from which data is written.
During the channel activity, this address is updated after each completed destination burst, consequently to:
the programmed destination burst; either in fixed addressing mode or in contiguous-data incremented mode. If contiguously incremented (GPDMA_CxTR1.DINC = 1), then the additional address offset value is the programmed burst size, as defined by GPDMA_CxTR1.DBL_1[5:0] and GPDMA_CxTR1.DDW_LOG2[1:0]
the additional destination incremented/decremented offset value as programmed by GPDMA_CxBR1.DDEC.
In linked-list mode, after a LLI data transfer is completed, this register is automatically updated by the GPDMA from the memory, provided the LLI is set with GPDMA_CxLLR.UDA = 1.
Note: A destination address must be aligned with the programmed data width of a destination burst (DA[2:0] versus GPDMA_CxTR1.DDW_LOG2[1:0]). Else, a user setting error is reported and no transfer is issued.</description>
                <bitOffset>0</bitOffset>
                <bitWidth>32</bitWidth>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>GPDMA_C0LLR</name>
            <displayName>GPDMA_C0LLR</displayName>
            <description>GPDMA channel 0 linked-list address register</description>
            <addressOffset>0xCC</addressOffset>
            <size>0x20</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>LA</name>
                <description>pointer (16-bit low-significant address) to the next linked-list data structure
If UT1 = UT2 = UB1 = USA = UDA = ULL = 0 and if LA[15:20] = 0, the current LLI is the last one. The channel transfer is completed without any update of the linked-list GPDMA register file.
Else, this field is the pointer to the memory address offset from which the next linked-list data structure is automatically fetched from, once the data transfer is completed, in order to conditionally update the linked-list GPDMA internal register file (GPDMA_CxCTR1, GPDMA_CxTR2, GPDMA_CxBR1, GPDMA_CxSAR, GPDMA_CxDAR and GPDMA_CxLLR).
Note: The user must program the pointer to be 32-bit aligned. The two low-significant bits are write ignored.</description>
                <bitOffset>2</bitOffset>
                <bitWidth>14</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>ULL</name>
                <description>Update GPDMA_CxLLR register from memory
This bit is used to control the update of GPDMA_CxLLR from the memory during the link transfer.</description>
                <bitOffset>16</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>no GPDMA_CxLLR update</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>GPDMA_CxLLR update</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>UDA</name>
                <description>Update GPDMA_CxDAR register from memory
This bit is used to control the update of GPDMA_CxDAR from the memory during the link transfer.</description>
                <bitOffset>27</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>no GPDMA_CxDAR update</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>GPDMA_CxDAR update</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>USA</name>
                <description>update GPDMA_CxSAR from memory
This bit controls the update of GPDMA_CxSAR from the memory during the link transfer.</description>
                <bitOffset>28</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>no GPDMA_CxSAR update</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>GPDMA_CxSAR update</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>UB1</name>
                <description>Update GPDMA_CxBR1 from memory
This bit controls the update of GPDMA_CxBR1 from the memory during the link transfer. If UB1 = 0 and if GPDMA_CxLLR  0, the linked-list is not completed. GPDMA_CxBR1.BNDT[15:0] is then restored to the programmed value after data transfer is completed and before the link transfer.</description>
                <bitOffset>29</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>no GPDMA_CxBR1 update from memory (GPDMA_CxBR1.BNDT[15:0] restored if any link transfer)</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>GPDMA_CxBR1 update</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>UT2</name>
                <description>Update GPDMA_CxTR2 from memory
This bit controls the update of GPDMA_CxTR2 from the memory during the link transfer.</description>
                <bitOffset>30</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>no GPDMA_CxTR2 update</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>GPDMA_CxTR2 update</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>UT1</name>
                <description>Update GPDMA_CxTR1 from memory
This bit controls the update of GPDMA_CxTR1 from the memory during the link transfer.</description>
                <bitOffset>31</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>no GPDMA_CxTR1 update</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>GPDMA_CxTR1 update</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
            </fields>
          </register>
          <register>
            <name>GPDMA_C1LBAR</name>
            <displayName>GPDMA_C1LBAR</displayName>
            <description>GPDMA channel 1 linked-list base address register</description>
            <addressOffset>0xD0</addressOffset>
            <size>0x20</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>LBA</name>
                <description>linked-list base address of GPDMA channel x</description>
                <bitOffset>16</bitOffset>
                <bitWidth>16</bitWidth>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>GPDMA_C1FCR</name>
            <displayName>GPDMA_C1FCR</displayName>
            <description>GPDMA channel 1 flag clear register</description>
            <addressOffset>0xDC</addressOffset>
            <size>0x20</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>TCF</name>
                <description>transfer complete flag clear</description>
                <bitOffset>8</bitOffset>
                <bitWidth>1</bitWidth>
                <access>write-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>no effect</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>corresponding TCF flag cleared</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>HTF</name>
                <description>half transfer flag clear</description>
                <bitOffset>9</bitOffset>
                <bitWidth>1</bitWidth>
                <access>write-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>no effect</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>corresponding HTF flag cleared</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>DTEF</name>
                <description>data transfer error flag clear</description>
                <bitOffset>10</bitOffset>
                <bitWidth>1</bitWidth>
                <access>write-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>no effect</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>corresponding DTEF flag cleared</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>ULEF</name>
                <description>update link transfer error flag clear</description>
                <bitOffset>11</bitOffset>
                <bitWidth>1</bitWidth>
                <access>write-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>no effect</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>corresponding ULEF flag cleared</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>USEF</name>
                <description>user setting error flag clear</description>
                <bitOffset>12</bitOffset>
                <bitWidth>1</bitWidth>
                <access>write-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>no effect</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>corresponding USEF flag cleared</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>SUSPF</name>
                <description>completed suspension flag clear</description>
                <bitOffset>13</bitOffset>
                <bitWidth>1</bitWidth>
                <access>write-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>no effect</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>corresponding SUSPF flag cleared</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>TOF</name>
                <description>trigger overrun flag clear</description>
                <bitOffset>14</bitOffset>
                <bitWidth>1</bitWidth>
                <access>write-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>no effect</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>corresponding TOF flag cleared</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
            </fields>
          </register>
          <register>
            <name>GPDMA_C1SR</name>
            <displayName>GPDMA_C1SR</displayName>
            <description>GPDMA channel 1 status register</description>
            <addressOffset>0xE0</addressOffset>
            <size>0x20</size>
            <resetValue>0x00000001</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>IDLEF</name>
                <description>idle flag
This idle flag is deasserted by hardware when the channel is enabled (GPDMA_CxCR.EN = 1) with a valid channel configuration (no USEF to be immediately reported).
This idle flag is asserted after hard reset or by hardware when the channel is back in idle state (in suspended or disabled state).</description>
                <bitOffset>0</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>channel not in idle state</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>channel in idle state</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>TCF</name>
                <description>transfer complete flag
A transfer complete event is either a block transfer complete, or a LLI transfer complete including the upload of the next LLI if any, or the full linked-list completion, depending on the transfer complete event mode (GPDMA_CxTR2.TCEM[1:0]).</description>
                <bitOffset>8</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>no transfer complete event</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>a transfer complete event occurred</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>HTF</name>
                <description>half transfer flag
A half block transfer occurs when half of the bytes of the source block size (rounded up integer of GPDMA_CxBR1.BNDT[15:0]/2) has been transferred to the destination.</description>
                <bitOffset>9</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>no half transfer event</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>a half transfer event occurred</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>DTEF</name>
                <description>data transfer error flag</description>
                <bitOffset>10</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>no data transfer error event</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>a master bus error event occurred on a data transfer</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>ULEF</name>
                <description>update link transfer error flag</description>
                <bitOffset>11</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>no update link transfer error event</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>a master bus error event occurred while updating a linked-list register from memory</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>USEF</name>
                <description>user setting error flag</description>
                <bitOffset>12</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>no user setting error event</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>a user setting error event occurred</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>SUSPF</name>
                <description>completed suspension flag</description>
                <bitOffset>13</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>no completed suspension event</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>a completed suspension event occurred</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>TOF</name>
                <description>trigger overrun flag</description>
                <bitOffset>14</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>no trigger overrun event</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>a trigger overrun event occurred</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>FIFOL</name>
                <description>monitored FIFO level
Number of available write beats in the FIFO, in units of the programmed destination data width (see GPDMA_CxTR1.DDW_LOG2[1:0], in units of bytes, half-words, or words).
Note: After having suspended an active transfer, the user may need to read FIFOL[7:0], additionally to GPDMA_CxBR1.BDNT[15:0] to know how many data have been transferred to the destination. Before reading, the user may wait for the transfer to be suspended (GPDMA_CxSR.SUSPF = 1).</description>
                <bitOffset>16</bitOffset>
                <bitWidth>8</bitWidth>
                <access>read-only</access>
              </field>
            </fields>
          </register>
          <register>
            <name>GPDMA_C1CR</name>
            <displayName>GPDMA_C1CR</displayName>
            <description>GPDMA channel 1 control register</description>
            <addressOffset>0xE4</addressOffset>
            <size>0x20</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>EN</name>
                <description>enable
Writing 1 into the field RESET (bit 1) causes the hardware to de-assert this bit, whatever is written into this bit 0. Else: 
this bit is deasserted by hardware when there is a transfer error (master bus error or user setting error) or when there is a channel transfer complete (channel ready to be configured, for example if LSM=1 at the end of a single execution of the LLI).
Else, this bit can be asserted by software. 
Writing 0 into this EN bit is ignored.</description>
                <bitOffset>0</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>write: ignored, read: channel disabled</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>write: enable channel, read: channel enabled</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>RESET</name>
                <description>reset
This bit is write only. Writing 0 has no impact. Writing 1 implies the reset of the following: the FIFO, the channel internal state, SUSP and EN bits (whatever is written receptively in bit 2 and bit 0).
The reset is effective when the channel is in steady state, meaning one of the following:
- active channel in suspended state (GPDMA_CxSR.SUSPF = 1 and GPDMA_CxSR.IDLEF = GPDMA_CxCR.EN = 1)
- channel in disabled state (GPDMA_CxSR.IDLEF = 1 and GPDMA_CxCR.EN = 0).
After writing a RESET, to continue using this channel, the user must explicitly reconfigure the channel including the hardware-modified configuration registers (GPDMA_CxBR1, GPDMA_CxSAR and GPDMA_CxDAR) before enabling again the channel (see the programming sequence in Figure 44).</description>
                <bitOffset>1</bitOffset>
                <bitWidth>1</bitWidth>
                <access>write-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>no channel reset</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>channel reset</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>SUSP</name>
                <description>suspend
Writing 1 into the field RESET (bit 1) causes the hardware to de-assert this bit, whatever is written into this bit 2. Else:
Software must write 1 in order to suspend an active channel (channel with an ongoing GPDMA transfer over its master ports). 
The software must write 0 in order to resume a suspended channel, following the programming sequence detailed in Figure 43.</description>
                <bitOffset>2</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>write: resume channel, read: channel not suspended</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>write: suspend channel, read: channel suspended.</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>TCIE</name>
                <description>transfer complete interrupt enable</description>
                <bitOffset>8</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>interrupt disabled</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>interrupt enabled</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>HTIE</name>
                <description>half transfer complete interrupt enable</description>
                <bitOffset>9</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>interrupt disabled</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>interrupt enabled</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>DTEIE</name>
                <description>data transfer error interrupt enable</description>
                <bitOffset>10</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>interrupt disabled</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>interrupt enabled</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>ULEIE</name>
                <description>update link transfer error interrupt enable</description>
                <bitOffset>11</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>interrupt disabled</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>interrupt enabled</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>USEIE</name>
                <description>user setting error interrupt enable</description>
                <bitOffset>12</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>interrupt disabled</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>interrupt enabled</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>SUSPIE</name>
                <description>completed suspension interrupt enable</description>
                <bitOffset>13</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>interrupt disabled</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>interrupt enabled</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>TOIE</name>
                <description>trigger overrun interrupt enable</description>
                <bitOffset>14</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>interrupt disabled</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>interrupt enabled</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>LSM</name>
                <description>Link step mode
First the (possible 1D/repeated) block transfer is executed as defined by the current internal register file until GPDMA_CxBR1.BNDT[15:0] = 0. Secondly the next linked-list data structure is conditionally uploaded from memory as defined by GPDMA_CxLLR. Then channel execution is completed.
Note: This bit must be written when EN=0. This bit is read-only when EN=1.</description>
                <bitOffset>16</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>channel executed for the full linked-list and completed at the end of the last LLI (GPDMA_CxLLR = 0). The 16 low-significant bits of the link address are null (LA[15:0] = 0) and all the update bits are null (UT1 =UB1 = UT2 = USA = UDA = ULL = 0). Then GPDMA_CxBR1.BNDT[15:0] = 0.</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>channel executed once for the current LLI</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>LAP</name>
                <description>linked-list allocated port
This bit is used to allocate the master port for the update of the GPDMA linked-list registers from the memory.
Note: This bit must be written when EN=0. This bit is read-only when EN=1.</description>
                <bitOffset>17</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>port 0 (AHB) allocated</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>port 1 (AHB) allocated</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>PRIO</name>
                <description>priority level of the channel x GPDMA transfer versus others
Note: This bit must be written when EN = 0. This bit is read-only when EN = 1.</description>
                <bitOffset>22</bitOffset>
                <bitWidth>2</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>low priority, low weight</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>low priority, mid weight</description>
                    <value>0x1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x2</name>
                    <description>low priority, high weight</description>
                    <value>0x2</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x3</name>
                    <description>high priority</description>
                    <value>0x3</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
            </fields>
          </register>
          <register>
            <name>GPDMA_C1TR1</name>
            <displayName>GPDMA_C1TR1</displayName>
            <description>GPDMA channel 1 transfer register 1</description>
            <addressOffset>0x110</addressOffset>
            <size>0x20</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>SDW_LOG2</name>
                <description>binary logarithm of the source data width of a burst in bytes
Setting a 8-byte data width causes a user setting error to be reported and no transfer is issued.
A source block size must be a multiple of the source data width (GPDMA_CxBR1.BNDT[2:0] versus SDW_LOG2[1:0]). Otherwise, a user setting error is reported and no transfer is issued.
Note: A source burst transfer must have an aligned address with its data width (start address GPDMA_CxSAR[2:0] versus SDW_LOG2[1:0]). Otherwise, a user setting error is reported and none transfer is issued.</description>
                <bitOffset>0</bitOffset>
                <bitWidth>2</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>byte</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>half-word (2 bytes)</description>
                    <value>0x1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x2</name>
                    <description>word (4 bytes)</description>
                    <value>0x2</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x3</name>
                    <description>user setting error reported and no transfer issued</description>
                    <value>0x3</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>SINC</name>
                <description>source incrementing burst
The source address, pointed by GPDMA_CxSAR, is kept constant after a burst beat/single transfer or is incremented by the offset value corresponding to a contiguous data after a burst beat/single transfer.</description>
                <bitOffset>3</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>fixed burst</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>contiguously incremented burst</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>SBL_1</name>
                <description>source burst length minus 1, between 0 and 63
The burst length unit is one data named beat within a burst. If SBL_1[5:0] =0 , the burst can be named as single. Each data/beat has a width defined by the destination data width SDW_LOG2[1:0].
Note: If a burst transfer crossed a 1-Kbyte address boundary on a AHB transfer, the GPDMA modifies and shortens the programmed burst into singles or bursts of lower length, to be compliant with the AHB protocol.
Note: If a burst transfer is of length greater than the FIFO size of the channel x, the GPDMA modifies and shortens the programmed burst into singles or bursts of lower length, to be compliant with the FIFO size. Transfer performance is lower, with GPDMA re-arbitration between effective and lower singles/bursts, but the data integrity is guaranteed.</description>
                <bitOffset>4</bitOffset>
                <bitWidth>6</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>PAM</name>
                <description>padding/alignment mode
If DDW_LOG2[1:0] = SDW_LOG2[1:0]: if the data width of a burst destination transfer is equal to the data width of a burst source transfer, these bits are ignored.
Else, in the following enumerated values, the condition PAM_1 is when destination data width is higher that source data width, and the condition PAM_2 is when destination data width is higher than source data width.
1x: successive source data are FIFO queued and packed at the destination data width, in a left (LSB) to right (MSB) order (named little endian), before a destination transfer
Note: 1x: source data is FIFO queued and unpacked at the destination data width, to be transferred in a left (LSB) to right (MSB) order (named little endian) to the destination</description>
                <bitOffset>11</bitOffset>
                <bitWidth>2</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0_PAM_1</name>
                    <description>source data is transferred as right aligned, padded with 0s up to the destination data width</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1_PAM_1</name>
                    <description>source data is transferred as right aligned, sign extended up to the destination data width</description>
                    <value>0x1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x0_PAM_2</name>
                    <description>source data is transferred as right aligned, left-truncated down to the destination data width</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1_PAM_2</name>
                    <description>source data is transferred as left-aligned, right-truncated down to the destination data width</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>SBX</name>
                <description>source byte exchange within the unaligned half-word of each source word 
If the source data width is shorter than a word, this bit is ignored.
If the source data width is a word:</description>
                <bitOffset>13</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>no byte-based exchange within the unaligned half-word of each source word</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>the two consecutive bytes within the unaligned half-word of each source word are exchanged.</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>SAP</name>
                <description>source allocated port
This bit is used to allocate the master port for the source transfer
Note: This bit must be written when EN = 0. This bit is read-only when EN = 1.</description>
                <bitOffset>14</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>port 0 (AHB) allocated</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>port 1 (AHB) allocated</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>SSEC</name>
                <description>security attribute of the GPDMA transfer from the source
If GPDMA_SECCFGR.SECx = 1 and the access is secure:
This is a secure register bit. This bit can only be read by a secure software. This bit must be written by a secure software when GPDMA_SECCFGR.SECx =1 . A secure write is ignored when GPDMA_SECCFGR.SECx = 0.
When GPDMA_SECCFGR.SECx is deasserted, this SSEC bit is also deasserted by hardware (on a secure reconfiguration of the channel as non-secure), and the GPDMA transfer from the source is non-secure.</description>
                <bitOffset>15</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>GPDMA transfer non-secure</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>GPDMA transfer secure</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>DDW_LOG2</name>
                <description>binary logarithm of the destination data width of a burst, in bytes
Setting a 8-byte data width causes a user setting error to be reported and none transfer is issued.
Note: A destination burst transfer must have an aligned address with its data width (start address GPDMA_CxDAR[2:0] versus DDW_LOG2[1:0]). Otherwise a user setting error is reported and no transfer is issued.</description>
                <bitOffset>16</bitOffset>
                <bitWidth>2</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>byte</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>half-word (2 bytes)</description>
                    <value>0x1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x2</name>
                    <description>word (4 bytes)</description>
                    <value>0x2</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x3</name>
                    <description>user setting error reported and no transfer issued</description>
                    <value>0x3</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>DINC</name>
                <description>destination incrementing burst
The destination address, pointed by GPDMA_CxDAR, is kept constant after a burst beat/single transfer, or is incremented by the offset value corresponding to a contiguous data after a burst beat/single transfer.</description>
                <bitOffset>19</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>fixed burst</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>contiguously incremented burst</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>DBL_1</name>
                <description>destination burst length minus 1, between 0 and 63
The burst length unit is one data named beat within a burst. If DBL_1[5:0] =0 , the burst can be named as single. Each data/beat has a width defined by the destination data width DDW_LOG2[1:0].
Note: If a burst transfer crossed a 1-Kbyte address boundary on a AHB transfer, the GPDMA modifies and shortens the programmed burst into singles or bursts of lower length, to be compliant with the AHB protocol.
Note: If a burst transfer is of length greater than the FIFO size of the channel x, the GPDMA modifies and shortens the programmed burst into singles or bursts of lower length, to be compliant with the FIFO size. Transfer performance is lower, with GPDMA re-arbitration between effective and lower singles/bursts, but the data integrity is guaranteed.</description>
                <bitOffset>20</bitOffset>
                <bitWidth>6</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>DBX</name>
                <description>destination byte exchange
If the destination data size is a byte, this bit is ignored.
If the destination data size is not a byte:</description>
                <bitOffset>26</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>no byte-based exchange within half-word</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>the two consecutive (post PAM) bytes are exchanged in each destination half-word.</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>DHX</name>
                <description>destination half-word exchange
If the destination data size is shorter than a word, this bit is ignored.
If the destination data size is a word:</description>
                <bitOffset>27</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>no halfword-based exchanged within word</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>the two consecutive (post PAM) half-words are exchanged in each destination word.</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>DAP</name>
                <description>destination allocated port
This bit is used to allocate the master port for the destination transfer
Note: This bit must be written when EN = 0. This bit is read-only when EN = 1.</description>
                <bitOffset>30</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>port 0 (AHB) allocated</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>port 1 (AHB) allocated</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>DSEC</name>
                <description>security attribute of the GPDMA transfer to the destination
If GPDMA_SECCFGR.SECx = 1 and the access is secure:
This is a secure register bit. This bit can only be read by a secure software. This bit must be written by a secure software when GPDMA_SECCFGR.SECx = 1. A secure write is ignored when GPDMA_SECCFGR.SECx = 0.
When GPDMA_SECCFGR.SECx is deasserted, this DSEC bit is also deasserted by hardware (on a secure reconfiguration of the channel as non-secure), and the GPDMA transfer to the destination is non-secure.</description>
                <bitOffset>31</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>GPDMA transfer non-secure</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>GPDMA transfer secure</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
            </fields>
          </register>
          <register>
            <name>GPDMA_C1TR2</name>
            <displayName>GPDMA_C1TR2</displayName>
            <description>GPDMA channel 1 transfer register 2</description>
            <addressOffset>0x114</addressOffset>
            <size>0x20</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>REQSEL</name>
                <description>GPDMA hardware request selection
These bits are ignored if channel x is activated (GPDMA_CxCR.EN asserted) with SWREQ = 1 (software request for a memory-to-memory transfer). Else, the selected hardware request is internally taken into account as per Section 16.3.3.
The user must not assign a same input hardware request (same REQSEL[5:0] value) to different active GPDMA channels (GPDMA_CxCR.EN = 1 and GPDMA_CxTR2.SWREQ = 0 for these channels). GPDMA is not intended to hardware support the case of simultaneous enabled channels incorrectly configured with a same hardware peripheral request signal, and there is no user setting error reporting.</description>
                <bitOffset>0</bitOffset>
                <bitWidth>6</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>SWREQ</name>
                <description>software request
This bit is internally taken into account when GPDMA_CxCR.EN is asserted.</description>
                <bitOffset>9</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>no software request. The selected hardware request REQSEL[5:0] is taken into account.</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>software request for a memory-to-memory transfer. The default selected hardware request as per REQSEL[5:0] is ignored.</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>DREQ</name>
                <description>destination hardware request
This bit is ignored if channel x is activated (GPDMA_CxCR.EN asserted) with SWREQ = 1 (software request for a memory-to-memory transfer). Else:</description>
                <bitOffset>10</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>selected hardware request driven by a source peripheral (request signal taken into account by the GPDMA transfer scheduler over the source/read port)</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>selected hardware request driven by a destination peripheral (request signal taken into account by the GPDMA transfer scheduler over the destination/write port)</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>BREQ</name>
                <description>Block hardware request
If the channel x is activated (GPDMA_CxCR.EN asserted) with SWREQ = 1 (software request for a memory-to-memory transfer), this bit is ignored. Else:</description>
                <bitOffset>11</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>the selected hardware request is driven by a peripheral with a hardware request/acknowledge protocol at a burst level.</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>the selected hardware request is driven by a peripheral with a hardware request/acknowledge protocol at a block level (see Section 16.3.3).</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>TRIGM</name>
                <description>trigger mode
These bits define the transfer granularity for its conditioning by the trigger.
If the channel x is enabled (GPDMA_CxCR.EN asserted) with TRIGPOL[1:0] = 00 or 11, these TRIGM[1:0] bits are ignored.
Else, a GPDMA transfer is conditioned by at least one trigger hit: 
 If the peripheral is programmed as a source (DREQ = 0) of the LLI data transfer, each programmed burst read is conditioned.
 If the peripheral is programmed as a destination (DREQ = 1) of the LLI data transfer, each programmed burst write is conditioned. The first memory burst read of a block, also named as the first ready FIFO-based source burst, is gated by the occurrence of both the hardware request and the first trigger hit.
The GPDMA monitoring of a trigger for channel x is started when the channel is enabled/loaded with a new active trigger configuration: rising or falling edge on a selected trigger (TRIGPOL[1:0] = 01 or respectively TRIGPOL[1:0] = 10).
The monitoring of this trigger is kept active during the triggered and uncompleted (data or link) transfer; and if a new trigger is detected then, this hit is internally memorized to grant the next transfer, as long as the defined rising or falling edge is not modified, and the TRIGSEL[4:0] is not modified, and the channel is enabled.
Transferring a next LLI&lt;sub&gt;n+1&lt;/sub&gt; that updates the GPDMA_CxTR2 with a new value for any of TRIGSEL[4:0] or TRIGPOL[1:0], resets the monitoring, trashing the memorized hit of the formerly defined LLI&lt;sub&gt;n &lt;/sub&gt;trigger.
After a first new trigger hit&lt;sub&gt;n+1&lt;/sub&gt; is memorized, if another second trigger hit&lt;sub&gt;n+2&lt;/sub&gt; is detected and if the hit&lt;sub&gt;n&lt;/sub&gt; triggered transfer is still not completed, hit&lt;sub&gt;n+2 &lt;/sub&gt;is lost and not memorized.memorized. A trigger overrun flag is reported (GPDMA_CxSR.TOF =1 ), and an interrupt is generated if enabled (GPDMA_CxCR.TOIE = 1). The channel is not automatically disabled by hardware due to a trigger overrun. 
Note: When the source block size is not a multiple of the source burst size and is a multiple of the source data width, then the last programmed source burst is not completed and is internally shorten to match the block size. In this case, if TRIGM[1:0] = 11 and (SWREQ =1  or (SWREQ = 0 and DREQ =0 )), the shortened burst transfer (by singles or/and by bursts of lower length) is conditioned once by the trigger.
Note: When the programmed destination burst is internally shortened by singles or/and by bursts of lower length (versus FIFO size, versus block size, 1-Kbyte boundary address crossing): if the trigger is conditioning the programmed destination burst (if TRIGM[1:0] = 11 and SWREQ = 0 and DREQ = 1), this shortened destination burst transfer is conditioned once by the trigger.</description>
                <bitOffset>14</bitOffset>
                <bitWidth>2</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>at block level: the first burst read of each block transfer is conditioned by one hit trigger .</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>channel x = 0 to 7, same as 0010: at link level: a LLI link transfer is conditioned by one hit trigger. The LLI data transfer (if any) is not conditioned.</description>
                    <value>0x1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x3</name>
                    <description>at programmed burst level: If SWREQ = 1, each programmed burst read is conditioned by one hit trigger. If SWREQ = 0, each programmed burst that is requested by the selected peripheral, is conditioned by one hit trigger.</description>
                    <value>0x3</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>TRIGSEL</name>
                <description>trigger event input selection
These bits select the trigger event input of the GPDMA transfer (as per Section 16.3.5), with an active trigger event if TRIGPOL[1:0]  00.</description>
                <bitOffset>16</bitOffset>
                <bitWidth>5</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>TRIGPOL</name>
                <description>trigger event polarity
These bits define the polarity of the selected trigger event input defined by TRIGSEL[4:0].</description>
                <bitOffset>24</bitOffset>
                <bitWidth>2</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>no trigger (masked trigger event)</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>trigger on the rising edge</description>
                    <value>0x1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x2</name>
                    <description>trigger on the falling edge</description>
                    <value>0x2</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x3</name>
                    <description>same as 00</description>
                    <value>0x3</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>TCEM</name>
                <description>transfer complete event mode
These bits define the transfer granularity for the transfer complete and half transfer complete events generation.
Note: If the initial LLI&lt;sub&gt;0 &lt;/sub&gt;data transfer is null/void (directly programmed by the internal register file with GPDMA_CxBR1.BNDT[15:0] = 0), then neither the complete transfer event nor the half transfer event is generated.
Note: If the initial LLI&lt;sub&gt;0 &lt;/sub&gt;data transfer is null/void (directly programmed by the internal register file with GPDMA_CxBR1.BNDT[15:0] = 0), then neither the complete transfer event nor the half transfer event is generated.
Note: If the initial LLI&lt;sub&gt;0 &lt;/sub&gt;data transfer is null/void (i.e. directly programmed by the internal register file with GPDMA_CxBR1.BNDT[15:0] =0 ), then the half transfer event is not generated, and the transfer complete event is generated when is completed the loading of the LLI&lt;sub&gt;1&lt;/sub&gt;.</description>
                <bitOffset>30</bitOffset>
                <bitWidth>2</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>at block level (when GPDMA_CxBR1.BNDT[15:0] = 0): the complete (and the half) transfer event is generated at the (respectively half of the) end of a block.</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>channel x (0 to 7, same as 00</description>
                    <value>0x1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x2</name>
                    <description>at LLI level: the complete transfer event is generated at the end of the LLI transfer, including the update of the LLI if any. The half transfer event is generated at the half of the LLI data transfer.</description>
                    <value>0x2</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x3</name>
                    <description>at channel level: the complete transfer event is generated at the end of the last LLI transfer. The half transfer event is generated at the half of the data transfer of the last LLI. The last LLI updates the link address GPDMA_CxLLR.LA[15:2] to zero and clears all the GPDMA_CxLLR update bits (UT1, UT2, UB1, USA, UDA and ULL). If the channel transfer is continuous/infinite, no event is generated.</description>
                    <value>0x3</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
            </fields>
          </register>
          <register>
            <name>GPDMA_C1BR1</name>
            <displayName>GPDMA_C1BR1</displayName>
            <description>GPDMA channel 1 block register 1</description>
            <addressOffset>0x118</addressOffset>
            <size>0x20</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>BNDT</name>
                <description>block number of data bytes to transfer from the source
Block size transferred from the source. When the channel is enabled, this field becomes read-only and is decremented, indicating the remaining number of data items in the current source block to be transferred. BNDT[15:0] is programmed in number of bytes, maximum source block size is 64 Kbytes -1.
Once the last data transfer is completed (BNDT[15:0] = 0):
- if GPDMA_CxLLR.UB1 = 1, this field is updated by the LLI in the memory.
- if GPDMA_CxLLR.UB1 = 0 and if there is at least one non null Uxx update bit, this field is internally restored to the programmed value.
- if all GPDMA_CxLLR.Uxx = 0 and if GPDMA_CxLLR.LA[15:0] = 0, this field is internally restored to the programmed value (infinite/continuous last LLI).
- if GPDMA_CxLLR = 0, this field is kept as zero following the last LLI data transfer.
Note: A non-null source block size must be a multiple of the source data width (BNDT[2:0] versus GPDMA_CxTR1.SDW_LOG2[1:0]). Else a user setting error is reported and no transfer is issued.
Note: When configured in packing mode (GPDMA_CxTR1.PAM[1] = 1 and destination data width different from source data width), a non-null source block size must be a multiple of the destination data width (BNDT[2:0] versus GPDMA_CxTR1.DDW_LOG2[1:0]). Else a user setting error is reported and no transfer is issued.</description>
                <bitOffset>0</bitOffset>
                <bitWidth>16</bitWidth>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>GPDMA_C1SAR</name>
            <displayName>GPDMA_C1SAR</displayName>
            <description>GPDMA channel 1 source address register</description>
            <addressOffset>0x11C</addressOffset>
            <size>0x20</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>SA</name>
                <description>source address
This field is the pointer to the address from which the next data is read.
During the channel activity, depending on the source addressing mode (GPDMA_CxTR1.SINC), this field is kept fixed or incremented by the data width (GPDMA_CxTR1.SDW_LOG2[1:0]) after each burst source data, reflecting the next address from which data is read.
During the channel activity, this address is updated after each completed source burst, consequently to:
the programmed source burst; either in fixed addressing mode or in contiguous-data incremented mode. If contiguously incremented (GPDMA_CxTR1.SINC = 1), then the additional address offset value is the programmed burst size, as defined by GPDMA_CxTR1.SBL_1[5:0] and GPDMA_CxTR1.SDW_LOG2[21:0]
the additional source incremented/decremented offset value as programmed by GPDMA_CxBR1.SDEC
In linked-list mode, after a LLI data transfer is completed, this register is automatically updated by GPDMA from the memory, provided the LLI is set with GPDMA_CxLLR.USA = 1.
Note: A source address must be aligned with the programmed data width of a source burst (SA[2:0] versus GPDMA_CxTR1.SDW_LOG2[1:0]). Else, a user setting error is reported and no transfer is issued.</description>
                <bitOffset>0</bitOffset>
                <bitWidth>32</bitWidth>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>GPDMA_C1DAR</name>
            <displayName>GPDMA_C1DAR</displayName>
            <description>GPDMA channel 1 destination address register</description>
            <addressOffset>0x120</addressOffset>
            <size>0x20</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>DA</name>
                <description>destination address
This field is the pointer to the address from which the next data is written.
During the channel activity, depending on the destination addressing mode (GPDMA_CxTR1.DINC), this field is kept fixed or incremented by the data width (GPDMA_CxTR1.DDW_LOG2[21:0]) after each burst destination data, reflecting the next address from which data is written.
During the channel activity, this address is updated after each completed destination burst, consequently to:
the programmed destination burst; either in fixed addressing mode or in contiguous-data incremented mode. If contiguously incremented (GPDMA_CxTR1.DINC = 1), then the additional address offset value is the programmed burst size, as defined by GPDMA_CxTR1.DBL_1[5:0] and GPDMA_CxTR1.DDW_LOG2[1:0]
the additional destination incremented/decremented offset value as programmed by GPDMA_CxBR1.DDEC.
In linked-list mode, after a LLI data transfer is completed, this register is automatically updated by the GPDMA from the memory, provided the LLI is set with GPDMA_CxLLR.UDA = 1.
Note: A destination address must be aligned with the programmed data width of a destination burst (DA[2:0] versus GPDMA_CxTR1.DDW_LOG2[1:0]). Else, a user setting error is reported and no transfer is issued.</description>
                <bitOffset>0</bitOffset>
                <bitWidth>32</bitWidth>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>GPDMA_C1LLR</name>
            <displayName>GPDMA_C1LLR</displayName>
            <description>GPDMA channel 1 linked-list address register</description>
            <addressOffset>0x14C</addressOffset>
            <size>0x20</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>LA</name>
                <description>pointer (16-bit low-significant address) to the next linked-list data structure
If UT1 = UT2 = UB1 = USA = UDA = ULL = 0 and if LA[15:20] = 0, the current LLI is the last one. The channel transfer is completed without any update of the linked-list GPDMA register file.
Else, this field is the pointer to the memory address offset from which the next linked-list data structure is automatically fetched from, once the data transfer is completed, in order to conditionally update the linked-list GPDMA internal register file (GPDMA_CxCTR1, GPDMA_CxTR2, GPDMA_CxBR1, GPDMA_CxSAR, GPDMA_CxDAR and GPDMA_CxLLR).
Note: The user must program the pointer to be 32-bit aligned. The two low-significant bits are write ignored.</description>
                <bitOffset>2</bitOffset>
                <bitWidth>14</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>ULL</name>
                <description>Update GPDMA_CxLLR register from memory
This bit is used to control the update of GPDMA_CxLLR from the memory during the link transfer.</description>
                <bitOffset>16</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>no GPDMA_CxLLR update</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>GPDMA_CxLLR update</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>UDA</name>
                <description>Update GPDMA_CxDAR register from memory
This bit is used to control the update of GPDMA_CxDAR from the memory during the link transfer.</description>
                <bitOffset>27</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>no GPDMA_CxDAR update</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>GPDMA_CxDAR update</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>USA</name>
                <description>update GPDMA_CxSAR from memory
This bit controls the update of GPDMA_CxSAR from the memory during the link transfer.</description>
                <bitOffset>28</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>no GPDMA_CxSAR update</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>GPDMA_CxSAR update</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>UB1</name>
                <description>Update GPDMA_CxBR1 from memory
This bit controls the update of GPDMA_CxBR1 from the memory during the link transfer. If UB1 = 0 and if GPDMA_CxLLR  0, the linked-list is not completed. GPDMA_CxBR1.BNDT[15:0] is then restored to the programmed value after data transfer is completed and before the link transfer.</description>
                <bitOffset>29</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>no GPDMA_CxBR1 update from memory (GPDMA_CxBR1.BNDT[15:0] restored if any link transfer)</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>GPDMA_CxBR1 update</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>UT2</name>
                <description>Update GPDMA_CxTR2 from memory
This bit controls the update of GPDMA_CxTR2 from the memory during the link transfer.</description>
                <bitOffset>30</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>no GPDMA_CxTR2 update</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>GPDMA_CxTR2 update</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>UT1</name>
                <description>Update GPDMA_CxTR1 from memory
This bit controls the update of GPDMA_CxTR1 from the memory during the link transfer.</description>
                <bitOffset>31</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>no GPDMA_CxTR1 update</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>GPDMA_CxTR1 update</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
            </fields>
          </register>
          <register>
            <name>GPDMA_C2LBAR</name>
            <displayName>GPDMA_C2LBAR</displayName>
            <description>GPDMA channel 2 linked-list base address register</description>
            <addressOffset>0x150</addressOffset>
            <size>0x20</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>LBA</name>
                <description>linked-list base address of GPDMA channel x</description>
                <bitOffset>16</bitOffset>
                <bitWidth>16</bitWidth>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>GPDMA_C2FCR</name>
            <displayName>GPDMA_C2FCR</displayName>
            <description>GPDMA channel 2 flag clear register</description>
            <addressOffset>0x15C</addressOffset>
            <size>0x20</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>TCF</name>
                <description>transfer complete flag clear</description>
                <bitOffset>8</bitOffset>
                <bitWidth>1</bitWidth>
                <access>write-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>no effect</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>corresponding TCF flag cleared</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>HTF</name>
                <description>half transfer flag clear</description>
                <bitOffset>9</bitOffset>
                <bitWidth>1</bitWidth>
                <access>write-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>no effect</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>corresponding HTF flag cleared</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>DTEF</name>
                <description>data transfer error flag clear</description>
                <bitOffset>10</bitOffset>
                <bitWidth>1</bitWidth>
                <access>write-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>no effect</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>corresponding DTEF flag cleared</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>ULEF</name>
                <description>update link transfer error flag clear</description>
                <bitOffset>11</bitOffset>
                <bitWidth>1</bitWidth>
                <access>write-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>no effect</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>corresponding ULEF flag cleared</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>USEF</name>
                <description>user setting error flag clear</description>
                <bitOffset>12</bitOffset>
                <bitWidth>1</bitWidth>
                <access>write-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>no effect</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>corresponding USEF flag cleared</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>SUSPF</name>
                <description>completed suspension flag clear</description>
                <bitOffset>13</bitOffset>
                <bitWidth>1</bitWidth>
                <access>write-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>no effect</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>corresponding SUSPF flag cleared</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>TOF</name>
                <description>trigger overrun flag clear</description>
                <bitOffset>14</bitOffset>
                <bitWidth>1</bitWidth>
                <access>write-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>no effect</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>corresponding TOF flag cleared</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
            </fields>
          </register>
          <register>
            <name>GPDMA_C2SR</name>
            <displayName>GPDMA_C2SR</displayName>
            <description>GPDMA channel 2 status register</description>
            <addressOffset>0x160</addressOffset>
            <size>0x20</size>
            <resetValue>0x00000001</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>IDLEF</name>
                <description>idle flag
This idle flag is deasserted by hardware when the channel is enabled (GPDMA_CxCR.EN = 1) with a valid channel configuration (no USEF to be immediately reported).
This idle flag is asserted after hard reset or by hardware when the channel is back in idle state (in suspended or disabled state).</description>
                <bitOffset>0</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>channel not in idle state</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>channel in idle state</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>TCF</name>
                <description>transfer complete flag
A transfer complete event is either a block transfer complete, or a LLI transfer complete including the upload of the next LLI if any, or the full linked-list completion, depending on the transfer complete event mode (GPDMA_CxTR2.TCEM[1:0]).</description>
                <bitOffset>8</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>no transfer complete event</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>a transfer complete event occurred</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>HTF</name>
                <description>half transfer flag
A half block transfer occurs when half of the bytes of the source block size (rounded up integer of GPDMA_CxBR1.BNDT[15:0]/2) has been transferred to the destination.</description>
                <bitOffset>9</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>no half transfer event</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>a half transfer event occurred</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>DTEF</name>
                <description>data transfer error flag</description>
                <bitOffset>10</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>no data transfer error event</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>a master bus error event occurred on a data transfer</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>ULEF</name>
                <description>update link transfer error flag</description>
                <bitOffset>11</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>no update link transfer error event</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>a master bus error event occurred while updating a linked-list register from memory</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>USEF</name>
                <description>user setting error flag</description>
                <bitOffset>12</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>no user setting error event</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>a user setting error event occurred</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>SUSPF</name>
                <description>completed suspension flag</description>
                <bitOffset>13</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>no completed suspension event</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>a completed suspension event occurred</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>TOF</name>
                <description>trigger overrun flag</description>
                <bitOffset>14</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>no trigger overrun event</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>a trigger overrun event occurred</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>FIFOL</name>
                <description>monitored FIFO level
Number of available write beats in the FIFO, in units of the programmed destination data width (see GPDMA_CxTR1.DDW_LOG2[1:0], in units of bytes, half-words, or words).
Note: After having suspended an active transfer, the user may need to read FIFOL[7:0], additionally to GPDMA_CxBR1.BDNT[15:0] to know how many data have been transferred to the destination. Before reading, the user may wait for the transfer to be suspended (GPDMA_CxSR.SUSPF = 1).</description>
                <bitOffset>16</bitOffset>
                <bitWidth>8</bitWidth>
                <access>read-only</access>
              </field>
            </fields>
          </register>
          <register>
            <name>GPDMA_C2CR</name>
            <displayName>GPDMA_C2CR</displayName>
            <description>GPDMA channel 2 control register</description>
            <addressOffset>0x164</addressOffset>
            <size>0x20</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>EN</name>
                <description>enable
Writing 1 into the field RESET (bit 1) causes the hardware to de-assert this bit, whatever is written into this bit 0. Else: 
this bit is deasserted by hardware when there is a transfer error (master bus error or user setting error) or when there is a channel transfer complete (channel ready to be configured, for example if LSM=1 at the end of a single execution of the LLI).
Else, this bit can be asserted by software. 
Writing 0 into this EN bit is ignored.</description>
                <bitOffset>0</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>write: ignored, read: channel disabled</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>write: enable channel, read: channel enabled</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>RESET</name>
                <description>reset
This bit is write only. Writing 0 has no impact. Writing 1 implies the reset of the following: the FIFO, the channel internal state, SUSP and EN bits (whatever is written receptively in bit 2 and bit 0).
The reset is effective when the channel is in steady state, meaning one of the following:
- active channel in suspended state (GPDMA_CxSR.SUSPF = 1 and GPDMA_CxSR.IDLEF = GPDMA_CxCR.EN = 1)
- channel in disabled state (GPDMA_CxSR.IDLEF = 1 and GPDMA_CxCR.EN = 0).
After writing a RESET, to continue using this channel, the user must explicitly reconfigure the channel including the hardware-modified configuration registers (GPDMA_CxBR1, GPDMA_CxSAR and GPDMA_CxDAR) before enabling again the channel (see the programming sequence in Figure 44).</description>
                <bitOffset>1</bitOffset>
                <bitWidth>1</bitWidth>
                <access>write-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>no channel reset</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>channel reset</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>SUSP</name>
                <description>suspend
Writing 1 into the field RESET (bit 1) causes the hardware to de-assert this bit, whatever is written into this bit 2. Else:
Software must write 1 in order to suspend an active channel (channel with an ongoing GPDMA transfer over its master ports). 
The software must write 0 in order to resume a suspended channel, following the programming sequence detailed in Figure 43.</description>
                <bitOffset>2</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>write: resume channel, read: channel not suspended</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>write: suspend channel, read: channel suspended.</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>TCIE</name>
                <description>transfer complete interrupt enable</description>
                <bitOffset>8</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>interrupt disabled</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>interrupt enabled</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>HTIE</name>
                <description>half transfer complete interrupt enable</description>
                <bitOffset>9</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>interrupt disabled</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>interrupt enabled</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>DTEIE</name>
                <description>data transfer error interrupt enable</description>
                <bitOffset>10</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>interrupt disabled</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>interrupt enabled</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>ULEIE</name>
                <description>update link transfer error interrupt enable</description>
                <bitOffset>11</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>interrupt disabled</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>interrupt enabled</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>USEIE</name>
                <description>user setting error interrupt enable</description>
                <bitOffset>12</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>interrupt disabled</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>interrupt enabled</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>SUSPIE</name>
                <description>completed suspension interrupt enable</description>
                <bitOffset>13</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>interrupt disabled</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>interrupt enabled</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>TOIE</name>
                <description>trigger overrun interrupt enable</description>
                <bitOffset>14</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>interrupt disabled</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>interrupt enabled</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>LSM</name>
                <description>Link step mode
First the (possible 1D/repeated) block transfer is executed as defined by the current internal register file until GPDMA_CxBR1.BNDT[15:0] = 0. Secondly the next linked-list data structure is conditionally uploaded from memory as defined by GPDMA_CxLLR. Then channel execution is completed.
Note: This bit must be written when EN=0. This bit is read-only when EN=1.</description>
                <bitOffset>16</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>channel executed for the full linked-list and completed at the end of the last LLI (GPDMA_CxLLR = 0). The 16 low-significant bits of the link address are null (LA[15:0] = 0) and all the update bits are null (UT1 =UB1 = UT2 = USA = UDA = ULL = 0). Then GPDMA_CxBR1.BNDT[15:0] = 0.</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>channel executed once for the current LLI</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>LAP</name>
                <description>linked-list allocated port
This bit is used to allocate the master port for the update of the GPDMA linked-list registers from the memory.
Note: This bit must be written when EN=0. This bit is read-only when EN=1.</description>
                <bitOffset>17</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>port 0 (AHB) allocated</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>port 1 (AHB) allocated</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>PRIO</name>
                <description>priority level of the channel x GPDMA transfer versus others
Note: This bit must be written when EN = 0. This bit is read-only when EN = 1.</description>
                <bitOffset>22</bitOffset>
                <bitWidth>2</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>low priority, low weight</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>low priority, mid weight</description>
                    <value>0x1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x2</name>
                    <description>low priority, high weight</description>
                    <value>0x2</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x3</name>
                    <description>high priority</description>
                    <value>0x3</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
            </fields>
          </register>
          <register>
            <name>GPDMA_C2TR1</name>
            <displayName>GPDMA_C2TR1</displayName>
            <description>GPDMA channel 2 transfer register 1</description>
            <addressOffset>0x190</addressOffset>
            <size>0x20</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>SDW_LOG2</name>
                <description>binary logarithm of the source data width of a burst in bytes
Setting a 8-byte data width causes a user setting error to be reported and no transfer is issued.
A source block size must be a multiple of the source data width (GPDMA_CxBR1.BNDT[2:0] versus SDW_LOG2[1:0]). Otherwise, a user setting error is reported and no transfer is issued.
Note: A source burst transfer must have an aligned address with its data width (start address GPDMA_CxSAR[2:0] versus SDW_LOG2[1:0]). Otherwise, a user setting error is reported and none transfer is issued.</description>
                <bitOffset>0</bitOffset>
                <bitWidth>2</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>byte</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>half-word (2 bytes)</description>
                    <value>0x1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x2</name>
                    <description>word (4 bytes)</description>
                    <value>0x2</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x3</name>
                    <description>user setting error reported and no transfer issued</description>
                    <value>0x3</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>SINC</name>
                <description>source incrementing burst
The source address, pointed by GPDMA_CxSAR, is kept constant after a burst beat/single transfer or is incremented by the offset value corresponding to a contiguous data after a burst beat/single transfer.</description>
                <bitOffset>3</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>fixed burst</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>contiguously incremented burst</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>SBL_1</name>
                <description>source burst length minus 1, between 0 and 63
The burst length unit is one data named beat within a burst. If SBL_1[5:0] =0 , the burst can be named as single. Each data/beat has a width defined by the destination data width SDW_LOG2[1:0].
Note: If a burst transfer crossed a 1-Kbyte address boundary on a AHB transfer, the GPDMA modifies and shortens the programmed burst into singles or bursts of lower length, to be compliant with the AHB protocol.
Note: If a burst transfer is of length greater than the FIFO size of the channel x, the GPDMA modifies and shortens the programmed burst into singles or bursts of lower length, to be compliant with the FIFO size. Transfer performance is lower, with GPDMA re-arbitration between effective and lower singles/bursts, but the data integrity is guaranteed.</description>
                <bitOffset>4</bitOffset>
                <bitWidth>6</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>PAM</name>
                <description>padding/alignment mode
If DDW_LOG2[1:0] = SDW_LOG2[1:0]: if the data width of a burst destination transfer is equal to the data width of a burst source transfer, these bits are ignored.
Else, in the following enumerated values, the condition PAM_1 is when destination data width is higher that source data width, and the condition PAM_2 is when destination data width is higher than source data width.
1x: successive source data are FIFO queued and packed at the destination data width, in a left (LSB) to right (MSB) order (named little endian), before a destination transfer
Note: 1x: source data is FIFO queued and unpacked at the destination data width, to be transferred in a left (LSB) to right (MSB) order (named little endian) to the destination</description>
                <bitOffset>11</bitOffset>
                <bitWidth>2</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0_PAM_1</name>
                    <description>source data is transferred as right aligned, padded with 0s up to the destination data width</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1_PAM_1</name>
                    <description>source data is transferred as right aligned, sign extended up to the destination data width</description>
                    <value>0x1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x0_PAM_2</name>
                    <description>source data is transferred as right aligned, left-truncated down to the destination data width</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1_PAM_2</name>
                    <description>source data is transferred as left-aligned, right-truncated down to the destination data width</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>SBX</name>
                <description>source byte exchange within the unaligned half-word of each source word 
If the source data width is shorter than a word, this bit is ignored.
If the source data width is a word:</description>
                <bitOffset>13</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>no byte-based exchange within the unaligned half-word of each source word</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>the two consecutive bytes within the unaligned half-word of each source word are exchanged.</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>SAP</name>
                <description>source allocated port
This bit is used to allocate the master port for the source transfer
Note: This bit must be written when EN = 0. This bit is read-only when EN = 1.</description>
                <bitOffset>14</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>port 0 (AHB) allocated</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>port 1 (AHB) allocated</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>SSEC</name>
                <description>security attribute of the GPDMA transfer from the source
If GPDMA_SECCFGR.SECx = 1 and the access is secure:
This is a secure register bit. This bit can only be read by a secure software. This bit must be written by a secure software when GPDMA_SECCFGR.SECx =1 . A secure write is ignored when GPDMA_SECCFGR.SECx = 0.
When GPDMA_SECCFGR.SECx is deasserted, this SSEC bit is also deasserted by hardware (on a secure reconfiguration of the channel as non-secure), and the GPDMA transfer from the source is non-secure.</description>
                <bitOffset>15</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>GPDMA transfer non-secure</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>GPDMA transfer secure</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>DDW_LOG2</name>
                <description>binary logarithm of the destination data width of a burst, in bytes
Setting a 8-byte data width causes a user setting error to be reported and none transfer is issued.
Note: A destination burst transfer must have an aligned address with its data width (start address GPDMA_CxDAR[2:0] versus DDW_LOG2[1:0]). Otherwise a user setting error is reported and no transfer is issued.</description>
                <bitOffset>16</bitOffset>
                <bitWidth>2</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>byte</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>half-word (2 bytes)</description>
                    <value>0x1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x2</name>
                    <description>word (4 bytes)</description>
                    <value>0x2</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x3</name>
                    <description>user setting error reported and no transfer issued</description>
                    <value>0x3</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>DINC</name>
                <description>destination incrementing burst
The destination address, pointed by GPDMA_CxDAR, is kept constant after a burst beat/single transfer, or is incremented by the offset value corresponding to a contiguous data after a burst beat/single transfer.</description>
                <bitOffset>19</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>fixed burst</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>contiguously incremented burst</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>DBL_1</name>
                <description>destination burst length minus 1, between 0 and 63
The burst length unit is one data named beat within a burst. If DBL_1[5:0] =0 , the burst can be named as single. Each data/beat has a width defined by the destination data width DDW_LOG2[1:0].
Note: If a burst transfer crossed a 1-Kbyte address boundary on a AHB transfer, the GPDMA modifies and shortens the programmed burst into singles or bursts of lower length, to be compliant with the AHB protocol.
Note: If a burst transfer is of length greater than the FIFO size of the channel x, the GPDMA modifies and shortens the programmed burst into singles or bursts of lower length, to be compliant with the FIFO size. Transfer performance is lower, with GPDMA re-arbitration between effective and lower singles/bursts, but the data integrity is guaranteed.</description>
                <bitOffset>20</bitOffset>
                <bitWidth>6</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>DBX</name>
                <description>destination byte exchange
If the destination data size is a byte, this bit is ignored.
If the destination data size is not a byte:</description>
                <bitOffset>26</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>no byte-based exchange within half-word</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>the two consecutive (post PAM) bytes are exchanged in each destination half-word.</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>DHX</name>
                <description>destination half-word exchange
If the destination data size is shorter than a word, this bit is ignored.
If the destination data size is a word:</description>
                <bitOffset>27</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>no halfword-based exchanged within word</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>the two consecutive (post PAM) half-words are exchanged in each destination word.</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>DAP</name>
                <description>destination allocated port
This bit is used to allocate the master port for the destination transfer
Note: This bit must be written when EN = 0. This bit is read-only when EN = 1.</description>
                <bitOffset>30</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>port 0 (AHB) allocated</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>port 1 (AHB) allocated</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>DSEC</name>
                <description>security attribute of the GPDMA transfer to the destination
If GPDMA_SECCFGR.SECx = 1 and the access is secure:
This is a secure register bit. This bit can only be read by a secure software. This bit must be written by a secure software when GPDMA_SECCFGR.SECx = 1. A secure write is ignored when GPDMA_SECCFGR.SECx = 0.
When GPDMA_SECCFGR.SECx is deasserted, this DSEC bit is also deasserted by hardware (on a secure reconfiguration of the channel as non-secure), and the GPDMA transfer to the destination is non-secure.</description>
                <bitOffset>31</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>GPDMA transfer non-secure</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>GPDMA transfer secure</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
            </fields>
          </register>
          <register>
            <name>GPDMA_C2TR2</name>
            <displayName>GPDMA_C2TR2</displayName>
            <description>GPDMA channel 2 transfer register 2</description>
            <addressOffset>0x194</addressOffset>
            <size>0x20</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>REQSEL</name>
                <description>GPDMA hardware request selection
These bits are ignored if channel x is activated (GPDMA_CxCR.EN asserted) with SWREQ = 1 (software request for a memory-to-memory transfer). Else, the selected hardware request is internally taken into account as per Section 16.3.3.
The user must not assign a same input hardware request (same REQSEL[5:0] value) to different active GPDMA channels (GPDMA_CxCR.EN = 1 and GPDMA_CxTR2.SWREQ = 0 for these channels). GPDMA is not intended to hardware support the case of simultaneous enabled channels incorrectly configured with a same hardware peripheral request signal, and there is no user setting error reporting.</description>
                <bitOffset>0</bitOffset>
                <bitWidth>6</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>SWREQ</name>
                <description>software request
This bit is internally taken into account when GPDMA_CxCR.EN is asserted.</description>
                <bitOffset>9</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>no software request. The selected hardware request REQSEL[5:0] is taken into account.</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>software request for a memory-to-memory transfer. The default selected hardware request as per REQSEL[5:0] is ignored.</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>DREQ</name>
                <description>destination hardware request
This bit is ignored if channel x is activated (GPDMA_CxCR.EN asserted) with SWREQ = 1 (software request for a memory-to-memory transfer). Else:</description>
                <bitOffset>10</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>selected hardware request driven by a source peripheral (request signal taken into account by the GPDMA transfer scheduler over the source/read port)</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>selected hardware request driven by a destination peripheral (request signal taken into account by the GPDMA transfer scheduler over the destination/write port)</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>BREQ</name>
                <description>Block hardware request
If the channel x is activated (GPDMA_CxCR.EN asserted) with SWREQ = 1 (software request for a memory-to-memory transfer), this bit is ignored. Else:</description>
                <bitOffset>11</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>the selected hardware request is driven by a peripheral with a hardware request/acknowledge protocol at a burst level.</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>the selected hardware request is driven by a peripheral with a hardware request/acknowledge protocol at a block level (see Section 16.3.3).</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>TRIGM</name>
                <description>trigger mode
These bits define the transfer granularity for its conditioning by the trigger.
If the channel x is enabled (GPDMA_CxCR.EN asserted) with TRIGPOL[1:0] = 00 or 11, these TRIGM[1:0] bits are ignored.
Else, a GPDMA transfer is conditioned by at least one trigger hit: 
 If the peripheral is programmed as a source (DREQ = 0) of the LLI data transfer, each programmed burst read is conditioned.
 If the peripheral is programmed as a destination (DREQ = 1) of the LLI data transfer, each programmed burst write is conditioned. The first memory burst read of a block, also named as the first ready FIFO-based source burst, is gated by the occurrence of both the hardware request and the first trigger hit.
The GPDMA monitoring of a trigger for channel x is started when the channel is enabled/loaded with a new active trigger configuration: rising or falling edge on a selected trigger (TRIGPOL[1:0] = 01 or respectively TRIGPOL[1:0] = 10).
The monitoring of this trigger is kept active during the triggered and uncompleted (data or link) transfer; and if a new trigger is detected then, this hit is internally memorized to grant the next transfer, as long as the defined rising or falling edge is not modified, and the TRIGSEL[4:0] is not modified, and the channel is enabled.
Transferring a next LLI&lt;sub&gt;n+1&lt;/sub&gt; that updates the GPDMA_CxTR2 with a new value for any of TRIGSEL[4:0] or TRIGPOL[1:0], resets the monitoring, trashing the memorized hit of the formerly defined LLI&lt;sub&gt;n &lt;/sub&gt;trigger.
After a first new trigger hit&lt;sub&gt;n+1&lt;/sub&gt; is memorized, if another second trigger hit&lt;sub&gt;n+2&lt;/sub&gt; is detected and if the hit&lt;sub&gt;n&lt;/sub&gt; triggered transfer is still not completed, hit&lt;sub&gt;n+2 &lt;/sub&gt;is lost and not memorized.memorized. A trigger overrun flag is reported (GPDMA_CxSR.TOF =1 ), and an interrupt is generated if enabled (GPDMA_CxCR.TOIE = 1). The channel is not automatically disabled by hardware due to a trigger overrun. 
Note: When the source block size is not a multiple of the source burst size and is a multiple of the source data width, then the last programmed source burst is not completed and is internally shorten to match the block size. In this case, if TRIGM[1:0] = 11 and (SWREQ =1  or (SWREQ = 0 and DREQ =0 )), the shortened burst transfer (by singles or/and by bursts of lower length) is conditioned once by the trigger.
Note: When the programmed destination burst is internally shortened by singles or/and by bursts of lower length (versus FIFO size, versus block size, 1-Kbyte boundary address crossing): if the trigger is conditioning the programmed destination burst (if TRIGM[1:0] = 11 and SWREQ = 0 and DREQ = 1), this shortened destination burst transfer is conditioned once by the trigger.</description>
                <bitOffset>14</bitOffset>
                <bitWidth>2</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>at block level: the first burst read of each block transfer is conditioned by one hit trigger .</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>channel x = 0 to 7, same as 0010: at link level: a LLI link transfer is conditioned by one hit trigger. The LLI data transfer (if any) is not conditioned.</description>
                    <value>0x1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x3</name>
                    <description>at programmed burst level: If SWREQ = 1, each programmed burst read is conditioned by one hit trigger. If SWREQ = 0, each programmed burst that is requested by the selected peripheral, is conditioned by one hit trigger.</description>
                    <value>0x3</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>TRIGSEL</name>
                <description>trigger event input selection
These bits select the trigger event input of the GPDMA transfer (as per Section 16.3.5), with an active trigger event if TRIGPOL[1:0]  00.</description>
                <bitOffset>16</bitOffset>
                <bitWidth>5</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>TRIGPOL</name>
                <description>trigger event polarity
These bits define the polarity of the selected trigger event input defined by TRIGSEL[4:0].</description>
                <bitOffset>24</bitOffset>
                <bitWidth>2</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>no trigger (masked trigger event)</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>trigger on the rising edge</description>
                    <value>0x1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x2</name>
                    <description>trigger on the falling edge</description>
                    <value>0x2</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x3</name>
                    <description>same as 00</description>
                    <value>0x3</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>TCEM</name>
                <description>transfer complete event mode
These bits define the transfer granularity for the transfer complete and half transfer complete events generation.
Note: If the initial LLI&lt;sub&gt;0 &lt;/sub&gt;data transfer is null/void (directly programmed by the internal register file with GPDMA_CxBR1.BNDT[15:0] = 0), then neither the complete transfer event nor the half transfer event is generated.
Note: If the initial LLI&lt;sub&gt;0 &lt;/sub&gt;data transfer is null/void (directly programmed by the internal register file with GPDMA_CxBR1.BNDT[15:0] = 0), then neither the complete transfer event nor the half transfer event is generated.
Note: If the initial LLI&lt;sub&gt;0 &lt;/sub&gt;data transfer is null/void (i.e. directly programmed by the internal register file with GPDMA_CxBR1.BNDT[15:0] =0 ), then the half transfer event is not generated, and the transfer complete event is generated when is completed the loading of the LLI&lt;sub&gt;1&lt;/sub&gt;.</description>
                <bitOffset>30</bitOffset>
                <bitWidth>2</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>at block level (when GPDMA_CxBR1.BNDT[15:0] = 0): the complete (and the half) transfer event is generated at the (respectively half of the) end of a block.</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>channel x (0 to 7, same as 00</description>
                    <value>0x1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x2</name>
                    <description>at LLI level: the complete transfer event is generated at the end of the LLI transfer, including the update of the LLI if any. The half transfer event is generated at the half of the LLI data transfer.</description>
                    <value>0x2</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x3</name>
                    <description>at channel level: the complete transfer event is generated at the end of the last LLI transfer. The half transfer event is generated at the half of the data transfer of the last LLI. The last LLI updates the link address GPDMA_CxLLR.LA[15:2] to zero and clears all the GPDMA_CxLLR update bits (UT1, UT2, UB1, USA, UDA and ULL). If the channel transfer is continuous/infinite, no event is generated.</description>
                    <value>0x3</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
            </fields>
          </register>
          <register>
            <name>GPDMA_C2BR1</name>
            <displayName>GPDMA_C2BR1</displayName>
            <description>GPDMA channel 2 block register 1</description>
            <addressOffset>0x198</addressOffset>
            <size>0x20</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>BNDT</name>
                <description>block number of data bytes to transfer from the source
Block size transferred from the source. When the channel is enabled, this field becomes read-only and is decremented, indicating the remaining number of data items in the current source block to be transferred. BNDT[15:0] is programmed in number of bytes, maximum source block size is 64 Kbytes -1.
Once the last data transfer is completed (BNDT[15:0] = 0):
- if GPDMA_CxLLR.UB1 = 1, this field is updated by the LLI in the memory.
- if GPDMA_CxLLR.UB1 = 0 and if there is at least one non null Uxx update bit, this field is internally restored to the programmed value.
- if all GPDMA_CxLLR.Uxx = 0 and if GPDMA_CxLLR.LA[15:0] = 0, this field is internally restored to the programmed value (infinite/continuous last LLI).
- if GPDMA_CxLLR = 0, this field is kept as zero following the last LLI data transfer.
Note: A non-null source block size must be a multiple of the source data width (BNDT[2:0] versus GPDMA_CxTR1.SDW_LOG2[1:0]). Else a user setting error is reported and no transfer is issued.
Note: When configured in packing mode (GPDMA_CxTR1.PAM[1] = 1 and destination data width different from source data width), a non-null source block size must be a multiple of the destination data width (BNDT[2:0] versus GPDMA_CxTR1.DDW_LOG2[1:0]). Else a user setting error is reported and no transfer is issued.</description>
                <bitOffset>0</bitOffset>
                <bitWidth>16</bitWidth>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>GPDMA_C2SAR</name>
            <displayName>GPDMA_C2SAR</displayName>
            <description>GPDMA channel 2 source address register</description>
            <addressOffset>0x19C</addressOffset>
            <size>0x20</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>SA</name>
                <description>source address
This field is the pointer to the address from which the next data is read.
During the channel activity, depending on the source addressing mode (GPDMA_CxTR1.SINC), this field is kept fixed or incremented by the data width (GPDMA_CxTR1.SDW_LOG2[1:0]) after each burst source data, reflecting the next address from which data is read.
During the channel activity, this address is updated after each completed source burst, consequently to:
the programmed source burst; either in fixed addressing mode or in contiguous-data incremented mode. If contiguously incremented (GPDMA_CxTR1.SINC = 1), then the additional address offset value is the programmed burst size, as defined by GPDMA_CxTR1.SBL_1[5:0] and GPDMA_CxTR1.SDW_LOG2[21:0]
the additional source incremented/decremented offset value as programmed by GPDMA_CxBR1.SDEC
In linked-list mode, after a LLI data transfer is completed, this register is automatically updated by GPDMA from the memory, provided the LLI is set with GPDMA_CxLLR.USA = 1.
Note: A source address must be aligned with the programmed data width of a source burst (SA[2:0] versus GPDMA_CxTR1.SDW_LOG2[1:0]). Else, a user setting error is reported and no transfer is issued.</description>
                <bitOffset>0</bitOffset>
                <bitWidth>32</bitWidth>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>GPDMA_C2DAR</name>
            <displayName>GPDMA_C2DAR</displayName>
            <description>GPDMA channel 2 destination address register</description>
            <addressOffset>0x1A0</addressOffset>
            <size>0x20</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>DA</name>
                <description>destination address
This field is the pointer to the address from which the next data is written.
During the channel activity, depending on the destination addressing mode (GPDMA_CxTR1.DINC), this field is kept fixed or incremented by the data width (GPDMA_CxTR1.DDW_LOG2[21:0]) after each burst destination data, reflecting the next address from which data is written.
During the channel activity, this address is updated after each completed destination burst, consequently to:
the programmed destination burst; either in fixed addressing mode or in contiguous-data incremented mode. If contiguously incremented (GPDMA_CxTR1.DINC = 1), then the additional address offset value is the programmed burst size, as defined by GPDMA_CxTR1.DBL_1[5:0] and GPDMA_CxTR1.DDW_LOG2[1:0]
the additional destination incremented/decremented offset value as programmed by GPDMA_CxBR1.DDEC.
In linked-list mode, after a LLI data transfer is completed, this register is automatically updated by the GPDMA from the memory, provided the LLI is set with GPDMA_CxLLR.UDA = 1.
Note: A destination address must be aligned with the programmed data width of a destination burst (DA[2:0] versus GPDMA_CxTR1.DDW_LOG2[1:0]). Else, a user setting error is reported and no transfer is issued.</description>
                <bitOffset>0</bitOffset>
                <bitWidth>32</bitWidth>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>GPDMA_C2LLR</name>
            <displayName>GPDMA_C2LLR</displayName>
            <description>GPDMA channel 2 linked-list address register</description>
            <addressOffset>0x1CC</addressOffset>
            <size>0x20</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>LA</name>
                <description>pointer (16-bit low-significant address) to the next linked-list data structure
If UT1 = UT2 = UB1 = USA = UDA = ULL = 0 and if LA[15:20] = 0, the current LLI is the last one. The channel transfer is completed without any update of the linked-list GPDMA register file.
Else, this field is the pointer to the memory address offset from which the next linked-list data structure is automatically fetched from, once the data transfer is completed, in order to conditionally update the linked-list GPDMA internal register file (GPDMA_CxCTR1, GPDMA_CxTR2, GPDMA_CxBR1, GPDMA_CxSAR, GPDMA_CxDAR and GPDMA_CxLLR).
Note: The user must program the pointer to be 32-bit aligned. The two low-significant bits are write ignored.</description>
                <bitOffset>2</bitOffset>
                <bitWidth>14</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>ULL</name>
                <description>Update GPDMA_CxLLR register from memory
This bit is used to control the update of GPDMA_CxLLR from the memory during the link transfer.</description>
                <bitOffset>16</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>no GPDMA_CxLLR update</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>GPDMA_CxLLR update</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>UDA</name>
                <description>Update GPDMA_CxDAR register from memory
This bit is used to control the update of GPDMA_CxDAR from the memory during the link transfer.</description>
                <bitOffset>27</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>no GPDMA_CxDAR update</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>GPDMA_CxDAR update</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>USA</name>
                <description>update GPDMA_CxSAR from memory
This bit controls the update of GPDMA_CxSAR from the memory during the link transfer.</description>
                <bitOffset>28</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>no GPDMA_CxSAR update</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>GPDMA_CxSAR update</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>UB1</name>
                <description>Update GPDMA_CxBR1 from memory
This bit controls the update of GPDMA_CxBR1 from the memory during the link transfer. If UB1 = 0 and if GPDMA_CxLLR  0, the linked-list is not completed. GPDMA_CxBR1.BNDT[15:0] is then restored to the programmed value after data transfer is completed and before the link transfer.</description>
                <bitOffset>29</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>no GPDMA_CxBR1 update from memory (GPDMA_CxBR1.BNDT[15:0] restored if any link transfer)</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>GPDMA_CxBR1 update</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>UT2</name>
                <description>Update GPDMA_CxTR2 from memory
This bit controls the update of GPDMA_CxTR2 from the memory during the link transfer.</description>
                <bitOffset>30</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>no GPDMA_CxTR2 update</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>GPDMA_CxTR2 update</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>UT1</name>
                <description>Update GPDMA_CxTR1 from memory
This bit controls the update of GPDMA_CxTR1 from the memory during the link transfer.</description>
                <bitOffset>31</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>no GPDMA_CxTR1 update</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>GPDMA_CxTR1 update</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
            </fields>
          </register>
          <register>
            <name>GPDMA_C3LBAR</name>
            <displayName>GPDMA_C3LBAR</displayName>
            <description>GPDMA channel 3 linked-list base address register</description>
            <addressOffset>0x1D0</addressOffset>
            <size>0x20</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>LBA</name>
                <description>linked-list base address of GPDMA channel x</description>
                <bitOffset>16</bitOffset>
                <bitWidth>16</bitWidth>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>GPDMA_C3FCR</name>
            <displayName>GPDMA_C3FCR</displayName>
            <description>GPDMA channel 3 flag clear register</description>
            <addressOffset>0x1DC</addressOffset>
            <size>0x20</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>TCF</name>
                <description>transfer complete flag clear</description>
                <bitOffset>8</bitOffset>
                <bitWidth>1</bitWidth>
                <access>write-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>no effect</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>corresponding TCF flag cleared</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>HTF</name>
                <description>half transfer flag clear</description>
                <bitOffset>9</bitOffset>
                <bitWidth>1</bitWidth>
                <access>write-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>no effect</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>corresponding HTF flag cleared</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>DTEF</name>
                <description>data transfer error flag clear</description>
                <bitOffset>10</bitOffset>
                <bitWidth>1</bitWidth>
                <access>write-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>no effect</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>corresponding DTEF flag cleared</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>ULEF</name>
                <description>update link transfer error flag clear</description>
                <bitOffset>11</bitOffset>
                <bitWidth>1</bitWidth>
                <access>write-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>no effect</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>corresponding ULEF flag cleared</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>USEF</name>
                <description>user setting error flag clear</description>
                <bitOffset>12</bitOffset>
                <bitWidth>1</bitWidth>
                <access>write-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>no effect</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>corresponding USEF flag cleared</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>SUSPF</name>
                <description>completed suspension flag clear</description>
                <bitOffset>13</bitOffset>
                <bitWidth>1</bitWidth>
                <access>write-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>no effect</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>corresponding SUSPF flag cleared</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>TOF</name>
                <description>trigger overrun flag clear</description>
                <bitOffset>14</bitOffset>
                <bitWidth>1</bitWidth>
                <access>write-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>no effect</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>corresponding TOF flag cleared</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
            </fields>
          </register>
          <register>
            <name>GPDMA_C3SR</name>
            <displayName>GPDMA_C3SR</displayName>
            <description>GPDMA channel 3 status register</description>
            <addressOffset>0x1E0</addressOffset>
            <size>0x20</size>
            <resetValue>0x00000001</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>IDLEF</name>
                <description>idle flag
This idle flag is deasserted by hardware when the channel is enabled (GPDMA_CxCR.EN = 1) with a valid channel configuration (no USEF to be immediately reported).
This idle flag is asserted after hard reset or by hardware when the channel is back in idle state (in suspended or disabled state).</description>
                <bitOffset>0</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>channel not in idle state</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>channel in idle state</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>TCF</name>
                <description>transfer complete flag
A transfer complete event is either a block transfer complete, or a LLI transfer complete including the upload of the next LLI if any, or the full linked-list completion, depending on the transfer complete event mode (GPDMA_CxTR2.TCEM[1:0]).</description>
                <bitOffset>8</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>no transfer complete event</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>a transfer complete event occurred</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>HTF</name>
                <description>half transfer flag
A half block transfer occurs when half of the bytes of the source block size (rounded up integer of GPDMA_CxBR1.BNDT[15:0]/2) has been transferred to the destination.</description>
                <bitOffset>9</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>no half transfer event</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>a half transfer event occurred</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>DTEF</name>
                <description>data transfer error flag</description>
                <bitOffset>10</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>no data transfer error event</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>a master bus error event occurred on a data transfer</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>ULEF</name>
                <description>update link transfer error flag</description>
                <bitOffset>11</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>no update link transfer error event</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>a master bus error event occurred while updating a linked-list register from memory</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>USEF</name>
                <description>user setting error flag</description>
                <bitOffset>12</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>no user setting error event</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>a user setting error event occurred</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>SUSPF</name>
                <description>completed suspension flag</description>
                <bitOffset>13</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>no completed suspension event</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>a completed suspension event occurred</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>TOF</name>
                <description>trigger overrun flag</description>
                <bitOffset>14</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>no trigger overrun event</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>a trigger overrun event occurred</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>FIFOL</name>
                <description>monitored FIFO level
Number of available write beats in the FIFO, in units of the programmed destination data width (see GPDMA_CxTR1.DDW_LOG2[1:0], in units of bytes, half-words, or words).
Note: After having suspended an active transfer, the user may need to read FIFOL[7:0], additionally to GPDMA_CxBR1.BDNT[15:0] to know how many data have been transferred to the destination. Before reading, the user may wait for the transfer to be suspended (GPDMA_CxSR.SUSPF = 1).</description>
                <bitOffset>16</bitOffset>
                <bitWidth>8</bitWidth>
                <access>read-only</access>
              </field>
            </fields>
          </register>
          <register>
            <name>GPDMA_C3CR</name>
            <displayName>GPDMA_C3CR</displayName>
            <description>GPDMA channel 3 control register</description>
            <addressOffset>0x1E4</addressOffset>
            <size>0x20</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>EN</name>
                <description>enable
Writing 1 into the field RESET (bit 1) causes the hardware to de-assert this bit, whatever is written into this bit 0. Else: 
this bit is deasserted by hardware when there is a transfer error (master bus error or user setting error) or when there is a channel transfer complete (channel ready to be configured, for example if LSM=1 at the end of a single execution of the LLI).
Else, this bit can be asserted by software. 
Writing 0 into this EN bit is ignored.</description>
                <bitOffset>0</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>write: ignored, read: channel disabled</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>write: enable channel, read: channel enabled</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>RESET</name>
                <description>reset
This bit is write only. Writing 0 has no impact. Writing 1 implies the reset of the following: the FIFO, the channel internal state, SUSP and EN bits (whatever is written receptively in bit 2 and bit 0).
The reset is effective when the channel is in steady state, meaning one of the following:
- active channel in suspended state (GPDMA_CxSR.SUSPF = 1 and GPDMA_CxSR.IDLEF = GPDMA_CxCR.EN = 1)
- channel in disabled state (GPDMA_CxSR.IDLEF = 1 and GPDMA_CxCR.EN = 0).
After writing a RESET, to continue using this channel, the user must explicitly reconfigure the channel including the hardware-modified configuration registers (GPDMA_CxBR1, GPDMA_CxSAR and GPDMA_CxDAR) before enabling again the channel (see the programming sequence in Figure 44).</description>
                <bitOffset>1</bitOffset>
                <bitWidth>1</bitWidth>
                <access>write-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>no channel reset</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>channel reset</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>SUSP</name>
                <description>suspend
Writing 1 into the field RESET (bit 1) causes the hardware to de-assert this bit, whatever is written into this bit 2. Else:
Software must write 1 in order to suspend an active channel (channel with an ongoing GPDMA transfer over its master ports). 
The software must write 0 in order to resume a suspended channel, following the programming sequence detailed in Figure 43.</description>
                <bitOffset>2</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>write: resume channel, read: channel not suspended</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>write: suspend channel, read: channel suspended.</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>TCIE</name>
                <description>transfer complete interrupt enable</description>
                <bitOffset>8</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>interrupt disabled</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>interrupt enabled</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>HTIE</name>
                <description>half transfer complete interrupt enable</description>
                <bitOffset>9</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>interrupt disabled</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>interrupt enabled</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>DTEIE</name>
                <description>data transfer error interrupt enable</description>
                <bitOffset>10</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>interrupt disabled</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>interrupt enabled</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>ULEIE</name>
                <description>update link transfer error interrupt enable</description>
                <bitOffset>11</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>interrupt disabled</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>interrupt enabled</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>USEIE</name>
                <description>user setting error interrupt enable</description>
                <bitOffset>12</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>interrupt disabled</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>interrupt enabled</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>SUSPIE</name>
                <description>completed suspension interrupt enable</description>
                <bitOffset>13</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>interrupt disabled</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>interrupt enabled</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>TOIE</name>
                <description>trigger overrun interrupt enable</description>
                <bitOffset>14</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>interrupt disabled</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>interrupt enabled</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>LSM</name>
                <description>Link step mode
First the (possible 1D/repeated) block transfer is executed as defined by the current internal register file until GPDMA_CxBR1.BNDT[15:0] = 0. Secondly the next linked-list data structure is conditionally uploaded from memory as defined by GPDMA_CxLLR. Then channel execution is completed.
Note: This bit must be written when EN=0. This bit is read-only when EN=1.</description>
                <bitOffset>16</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>channel executed for the full linked-list and completed at the end of the last LLI (GPDMA_CxLLR = 0). The 16 low-significant bits of the link address are null (LA[15:0] = 0) and all the update bits are null (UT1 =UB1 = UT2 = USA = UDA = ULL = 0). Then GPDMA_CxBR1.BNDT[15:0] = 0.</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>channel executed once for the current LLI</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>LAP</name>
                <description>linked-list allocated port
This bit is used to allocate the master port for the update of the GPDMA linked-list registers from the memory.
Note: This bit must be written when EN=0. This bit is read-only when EN=1.</description>
                <bitOffset>17</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>port 0 (AHB) allocated</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>port 1 (AHB) allocated</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>PRIO</name>
                <description>priority level of the channel x GPDMA transfer versus others
Note: This bit must be written when EN = 0. This bit is read-only when EN = 1.</description>
                <bitOffset>22</bitOffset>
                <bitWidth>2</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>low priority, low weight</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>low priority, mid weight</description>
                    <value>0x1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x2</name>
                    <description>low priority, high weight</description>
                    <value>0x2</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x3</name>
                    <description>high priority</description>
                    <value>0x3</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
            </fields>
          </register>
          <register>
            <name>GPDMA_C3TR1</name>
            <displayName>GPDMA_C3TR1</displayName>
            <description>GPDMA channel 3 transfer register 1</description>
            <addressOffset>0x210</addressOffset>
            <size>0x20</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>SDW_LOG2</name>
                <description>binary logarithm of the source data width of a burst in bytes
Setting a 8-byte data width causes a user setting error to be reported and no transfer is issued.
A source block size must be a multiple of the source data width (GPDMA_CxBR1.BNDT[2:0] versus SDW_LOG2[1:0]). Otherwise, a user setting error is reported and no transfer is issued.
Note: A source burst transfer must have an aligned address with its data width (start address GPDMA_CxSAR[2:0] versus SDW_LOG2[1:0]). Otherwise, a user setting error is reported and none transfer is issued.</description>
                <bitOffset>0</bitOffset>
                <bitWidth>2</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>byte</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>half-word (2 bytes)</description>
                    <value>0x1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x2</name>
                    <description>word (4 bytes)</description>
                    <value>0x2</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x3</name>
                    <description>user setting error reported and no transfer issued</description>
                    <value>0x3</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>SINC</name>
                <description>source incrementing burst
The source address, pointed by GPDMA_CxSAR, is kept constant after a burst beat/single transfer or is incremented by the offset value corresponding to a contiguous data after a burst beat/single transfer.</description>
                <bitOffset>3</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>fixed burst</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>contiguously incremented burst</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>SBL_1</name>
                <description>source burst length minus 1, between 0 and 63
The burst length unit is one data named beat within a burst. If SBL_1[5:0] =0 , the burst can be named as single. Each data/beat has a width defined by the destination data width SDW_LOG2[1:0].
Note: If a burst transfer crossed a 1-Kbyte address boundary on a AHB transfer, the GPDMA modifies and shortens the programmed burst into singles or bursts of lower length, to be compliant with the AHB protocol.
Note: If a burst transfer is of length greater than the FIFO size of the channel x, the GPDMA modifies and shortens the programmed burst into singles or bursts of lower length, to be compliant with the FIFO size. Transfer performance is lower, with GPDMA re-arbitration between effective and lower singles/bursts, but the data integrity is guaranteed.</description>
                <bitOffset>4</bitOffset>
                <bitWidth>6</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>PAM</name>
                <description>padding/alignment mode
If DDW_LOG2[1:0] = SDW_LOG2[1:0]: if the data width of a burst destination transfer is equal to the data width of a burst source transfer, these bits are ignored.
Else, in the following enumerated values, the condition PAM_1 is when destination data width is higher that source data width, and the condition PAM_2 is when destination data width is higher than source data width.
1x: successive source data are FIFO queued and packed at the destination data width, in a left (LSB) to right (MSB) order (named little endian), before a destination transfer
Note: 1x: source data is FIFO queued and unpacked at the destination data width, to be transferred in a left (LSB) to right (MSB) order (named little endian) to the destination</description>
                <bitOffset>11</bitOffset>
                <bitWidth>2</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0_PAM_1</name>
                    <description>source data is transferred as right aligned, padded with 0s up to the destination data width</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1_PAM_1</name>
                    <description>source data is transferred as right aligned, sign extended up to the destination data width</description>
                    <value>0x1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x0_PAM_2</name>
                    <description>source data is transferred as right aligned, left-truncated down to the destination data width</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1_PAM_2</name>
                    <description>source data is transferred as left-aligned, right-truncated down to the destination data width</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>SBX</name>
                <description>source byte exchange within the unaligned half-word of each source word 
If the source data width is shorter than a word, this bit is ignored.
If the source data width is a word:</description>
                <bitOffset>13</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>no byte-based exchange within the unaligned half-word of each source word</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>the two consecutive bytes within the unaligned half-word of each source word are exchanged.</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>SAP</name>
                <description>source allocated port
This bit is used to allocate the master port for the source transfer
Note: This bit must be written when EN = 0. This bit is read-only when EN = 1.</description>
                <bitOffset>14</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>port 0 (AHB) allocated</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>port 1 (AHB) allocated</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>SSEC</name>
                <description>security attribute of the GPDMA transfer from the source
If GPDMA_SECCFGR.SECx = 1 and the access is secure:
This is a secure register bit. This bit can only be read by a secure software. This bit must be written by a secure software when GPDMA_SECCFGR.SECx =1 . A secure write is ignored when GPDMA_SECCFGR.SECx = 0.
When GPDMA_SECCFGR.SECx is deasserted, this SSEC bit is also deasserted by hardware (on a secure reconfiguration of the channel as non-secure), and the GPDMA transfer from the source is non-secure.</description>
                <bitOffset>15</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>GPDMA transfer non-secure</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>GPDMA transfer secure</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>DDW_LOG2</name>
                <description>binary logarithm of the destination data width of a burst, in bytes
Setting a 8-byte data width causes a user setting error to be reported and none transfer is issued.
Note: A destination burst transfer must have an aligned address with its data width (start address GPDMA_CxDAR[2:0] versus DDW_LOG2[1:0]). Otherwise a user setting error is reported and no transfer is issued.</description>
                <bitOffset>16</bitOffset>
                <bitWidth>2</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>byte</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>half-word (2 bytes)</description>
                    <value>0x1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x2</name>
                    <description>word (4 bytes)</description>
                    <value>0x2</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x3</name>
                    <description>user setting error reported and no transfer issued</description>
                    <value>0x3</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>DINC</name>
                <description>destination incrementing burst
The destination address, pointed by GPDMA_CxDAR, is kept constant after a burst beat/single transfer, or is incremented by the offset value corresponding to a contiguous data after a burst beat/single transfer.</description>
                <bitOffset>19</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>fixed burst</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>contiguously incremented burst</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>DBL_1</name>
                <description>destination burst length minus 1, between 0 and 63
The burst length unit is one data named beat within a burst. If DBL_1[5:0] =0 , the burst can be named as single. Each data/beat has a width defined by the destination data width DDW_LOG2[1:0].
Note: If a burst transfer crossed a 1-Kbyte address boundary on a AHB transfer, the GPDMA modifies and shortens the programmed burst into singles or bursts of lower length, to be compliant with the AHB protocol.
Note: If a burst transfer is of length greater than the FIFO size of the channel x, the GPDMA modifies and shortens the programmed burst into singles or bursts of lower length, to be compliant with the FIFO size. Transfer performance is lower, with GPDMA re-arbitration between effective and lower singles/bursts, but the data integrity is guaranteed.</description>
                <bitOffset>20</bitOffset>
                <bitWidth>6</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>DBX</name>
                <description>destination byte exchange
If the destination data size is a byte, this bit is ignored.
If the destination data size is not a byte:</description>
                <bitOffset>26</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>no byte-based exchange within half-word</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>the two consecutive (post PAM) bytes are exchanged in each destination half-word.</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>DHX</name>
                <description>destination half-word exchange
If the destination data size is shorter than a word, this bit is ignored.
If the destination data size is a word:</description>
                <bitOffset>27</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>no halfword-based exchanged within word</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>the two consecutive (post PAM) half-words are exchanged in each destination word.</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>DAP</name>
                <description>destination allocated port
This bit is used to allocate the master port for the destination transfer
Note: This bit must be written when EN = 0. This bit is read-only when EN = 1.</description>
                <bitOffset>30</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>port 0 (AHB) allocated</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>port 1 (AHB) allocated</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>DSEC</name>
                <description>security attribute of the GPDMA transfer to the destination
If GPDMA_SECCFGR.SECx = 1 and the access is secure:
This is a secure register bit. This bit can only be read by a secure software. This bit must be written by a secure software when GPDMA_SECCFGR.SECx = 1. A secure write is ignored when GPDMA_SECCFGR.SECx = 0.
When GPDMA_SECCFGR.SECx is deasserted, this DSEC bit is also deasserted by hardware (on a secure reconfiguration of the channel as non-secure), and the GPDMA transfer to the destination is non-secure.</description>
                <bitOffset>31</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>GPDMA transfer non-secure</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>GPDMA transfer secure</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
            </fields>
          </register>
          <register>
            <name>GPDMA_C3TR2</name>
            <displayName>GPDMA_C3TR2</displayName>
            <description>GPDMA channel 3 transfer register 2</description>
            <addressOffset>0x214</addressOffset>
            <size>0x20</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>REQSEL</name>
                <description>GPDMA hardware request selection
These bits are ignored if channel x is activated (GPDMA_CxCR.EN asserted) with SWREQ = 1 (software request for a memory-to-memory transfer). Else, the selected hardware request is internally taken into account as per Section 16.3.3.
The user must not assign a same input hardware request (same REQSEL[5:0] value) to different active GPDMA channels (GPDMA_CxCR.EN = 1 and GPDMA_CxTR2.SWREQ = 0 for these channels). GPDMA is not intended to hardware support the case of simultaneous enabled channels incorrectly configured with a same hardware peripheral request signal, and there is no user setting error reporting.</description>
                <bitOffset>0</bitOffset>
                <bitWidth>6</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>SWREQ</name>
                <description>software request
This bit is internally taken into account when GPDMA_CxCR.EN is asserted.</description>
                <bitOffset>9</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>no software request. The selected hardware request REQSEL[5:0] is taken into account.</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>software request for a memory-to-memory transfer. The default selected hardware request as per REQSEL[5:0] is ignored.</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>DREQ</name>
                <description>destination hardware request
This bit is ignored if channel x is activated (GPDMA_CxCR.EN asserted) with SWREQ = 1 (software request for a memory-to-memory transfer). Else:</description>
                <bitOffset>10</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>selected hardware request driven by a source peripheral (request signal taken into account by the GPDMA transfer scheduler over the source/read port)</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>selected hardware request driven by a destination peripheral (request signal taken into account by the GPDMA transfer scheduler over the destination/write port)</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>BREQ</name>
                <description>Block hardware request
If the channel x is activated (GPDMA_CxCR.EN asserted) with SWREQ = 1 (software request for a memory-to-memory transfer), this bit is ignored. Else:</description>
                <bitOffset>11</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>the selected hardware request is driven by a peripheral with a hardware request/acknowledge protocol at a burst level.</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>the selected hardware request is driven by a peripheral with a hardware request/acknowledge protocol at a block level (see Section 16.3.3).</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>TRIGM</name>
                <description>trigger mode
These bits define the transfer granularity for its conditioning by the trigger.
If the channel x is enabled (GPDMA_CxCR.EN asserted) with TRIGPOL[1:0] = 00 or 11, these TRIGM[1:0] bits are ignored.
Else, a GPDMA transfer is conditioned by at least one trigger hit: 
 If the peripheral is programmed as a source (DREQ = 0) of the LLI data transfer, each programmed burst read is conditioned.
 If the peripheral is programmed as a destination (DREQ = 1) of the LLI data transfer, each programmed burst write is conditioned. The first memory burst read of a block, also named as the first ready FIFO-based source burst, is gated by the occurrence of both the hardware request and the first trigger hit.
The GPDMA monitoring of a trigger for channel x is started when the channel is enabled/loaded with a new active trigger configuration: rising or falling edge on a selected trigger (TRIGPOL[1:0] = 01 or respectively TRIGPOL[1:0] = 10).
The monitoring of this trigger is kept active during the triggered and uncompleted (data or link) transfer; and if a new trigger is detected then, this hit is internally memorized to grant the next transfer, as long as the defined rising or falling edge is not modified, and the TRIGSEL[4:0] is not modified, and the channel is enabled.
Transferring a next LLI&lt;sub&gt;n+1&lt;/sub&gt; that updates the GPDMA_CxTR2 with a new value for any of TRIGSEL[4:0] or TRIGPOL[1:0], resets the monitoring, trashing the memorized hit of the formerly defined LLI&lt;sub&gt;n &lt;/sub&gt;trigger.
After a first new trigger hit&lt;sub&gt;n+1&lt;/sub&gt; is memorized, if another second trigger hit&lt;sub&gt;n+2&lt;/sub&gt; is detected and if the hit&lt;sub&gt;n&lt;/sub&gt; triggered transfer is still not completed, hit&lt;sub&gt;n+2 &lt;/sub&gt;is lost and not memorized.memorized. A trigger overrun flag is reported (GPDMA_CxSR.TOF =1 ), and an interrupt is generated if enabled (GPDMA_CxCR.TOIE = 1). The channel is not automatically disabled by hardware due to a trigger overrun. 
Note: When the source block size is not a multiple of the source burst size and is a multiple of the source data width, then the last programmed source burst is not completed and is internally shorten to match the block size. In this case, if TRIGM[1:0] = 11 and (SWREQ =1  or (SWREQ = 0 and DREQ =0 )), the shortened burst transfer (by singles or/and by bursts of lower length) is conditioned once by the trigger.
Note: When the programmed destination burst is internally shortened by singles or/and by bursts of lower length (versus FIFO size, versus block size, 1-Kbyte boundary address crossing): if the trigger is conditioning the programmed destination burst (if TRIGM[1:0] = 11 and SWREQ = 0 and DREQ = 1), this shortened destination burst transfer is conditioned once by the trigger.</description>
                <bitOffset>14</bitOffset>
                <bitWidth>2</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>at block level: the first burst read of each block transfer is conditioned by one hit trigger .</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>channel x = 0 to 7, same as 0010: at link level: a LLI link transfer is conditioned by one hit trigger. The LLI data transfer (if any) is not conditioned.</description>
                    <value>0x1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x3</name>
                    <description>at programmed burst level: If SWREQ = 1, each programmed burst read is conditioned by one hit trigger. If SWREQ = 0, each programmed burst that is requested by the selected peripheral, is conditioned by one hit trigger.</description>
                    <value>0x3</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>TRIGSEL</name>
                <description>trigger event input selection
These bits select the trigger event input of the GPDMA transfer (as per Section 16.3.5), with an active trigger event if TRIGPOL[1:0]  00.</description>
                <bitOffset>16</bitOffset>
                <bitWidth>5</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>TRIGPOL</name>
                <description>trigger event polarity
These bits define the polarity of the selected trigger event input defined by TRIGSEL[4:0].</description>
                <bitOffset>24</bitOffset>
                <bitWidth>2</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>no trigger (masked trigger event)</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>trigger on the rising edge</description>
                    <value>0x1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x2</name>
                    <description>trigger on the falling edge</description>
                    <value>0x2</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x3</name>
                    <description>same as 00</description>
                    <value>0x3</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>TCEM</name>
                <description>transfer complete event mode
These bits define the transfer granularity for the transfer complete and half transfer complete events generation.
Note: If the initial LLI&lt;sub&gt;0 &lt;/sub&gt;data transfer is null/void (directly programmed by the internal register file with GPDMA_CxBR1.BNDT[15:0] = 0), then neither the complete transfer event nor the half transfer event is generated.
Note: If the initial LLI&lt;sub&gt;0 &lt;/sub&gt;data transfer is null/void (directly programmed by the internal register file with GPDMA_CxBR1.BNDT[15:0] = 0), then neither the complete transfer event nor the half transfer event is generated.
Note: If the initial LLI&lt;sub&gt;0 &lt;/sub&gt;data transfer is null/void (i.e. directly programmed by the internal register file with GPDMA_CxBR1.BNDT[15:0] =0 ), then the half transfer event is not generated, and the transfer complete event is generated when is completed the loading of the LLI&lt;sub&gt;1&lt;/sub&gt;.</description>
                <bitOffset>30</bitOffset>
                <bitWidth>2</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>at block level (when GPDMA_CxBR1.BNDT[15:0] = 0): the complete (and the half) transfer event is generated at the (respectively half of the) end of a block.</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>channel x (0 to 7, same as 00</description>
                    <value>0x1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x2</name>
                    <description>at LLI level: the complete transfer event is generated at the end of the LLI transfer, including the update of the LLI if any. The half transfer event is generated at the half of the LLI data transfer.</description>
                    <value>0x2</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x3</name>
                    <description>at channel level: the complete transfer event is generated at the end of the last LLI transfer. The half transfer event is generated at the half of the data transfer of the last LLI. The last LLI updates the link address GPDMA_CxLLR.LA[15:2] to zero and clears all the GPDMA_CxLLR update bits (UT1, UT2, UB1, USA, UDA and ULL). If the channel transfer is continuous/infinite, no event is generated.</description>
                    <value>0x3</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
            </fields>
          </register>
          <register>
            <name>GPDMA_C3BR1</name>
            <displayName>GPDMA_C3BR1</displayName>
            <description>GPDMA channel 3 block register 1</description>
            <addressOffset>0x218</addressOffset>
            <size>0x20</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>BNDT</name>
                <description>block number of data bytes to transfer from the source
Block size transferred from the source. When the channel is enabled, this field becomes read-only and is decremented, indicating the remaining number of data items in the current source block to be transferred. BNDT[15:0] is programmed in number of bytes, maximum source block size is 64 Kbytes -1.
Once the last data transfer is completed (BNDT[15:0] = 0):
- if GPDMA_CxLLR.UB1 = 1, this field is updated by the LLI in the memory.
- if GPDMA_CxLLR.UB1 = 0 and if there is at least one non null Uxx update bit, this field is internally restored to the programmed value.
- if all GPDMA_CxLLR.Uxx = 0 and if GPDMA_CxLLR.LA[15:0] = 0, this field is internally restored to the programmed value (infinite/continuous last LLI).
- if GPDMA_CxLLR = 0, this field is kept as zero following the last LLI data transfer.
Note: A non-null source block size must be a multiple of the source data width (BNDT[2:0] versus GPDMA_CxTR1.SDW_LOG2[1:0]). Else a user setting error is reported and no transfer is issued.
Note: When configured in packing mode (GPDMA_CxTR1.PAM[1] = 1 and destination data width different from source data width), a non-null source block size must be a multiple of the destination data width (BNDT[2:0] versus GPDMA_CxTR1.DDW_LOG2[1:0]). Else a user setting error is reported and no transfer is issued.</description>
                <bitOffset>0</bitOffset>
                <bitWidth>16</bitWidth>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>GPDMA_C3SAR</name>
            <displayName>GPDMA_C3SAR</displayName>
            <description>GPDMA channel 3 source address register</description>
            <addressOffset>0x21C</addressOffset>
            <size>0x20</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>SA</name>
                <description>source address
This field is the pointer to the address from which the next data is read.
During the channel activity, depending on the source addressing mode (GPDMA_CxTR1.SINC), this field is kept fixed or incremented by the data width (GPDMA_CxTR1.SDW_LOG2[1:0]) after each burst source data, reflecting the next address from which data is read.
During the channel activity, this address is updated after each completed source burst, consequently to:
the programmed source burst; either in fixed addressing mode or in contiguous-data incremented mode. If contiguously incremented (GPDMA_CxTR1.SINC = 1), then the additional address offset value is the programmed burst size, as defined by GPDMA_CxTR1.SBL_1[5:0] and GPDMA_CxTR1.SDW_LOG2[21:0]
the additional source incremented/decremented offset value as programmed by GPDMA_CxBR1.SDEC
In linked-list mode, after a LLI data transfer is completed, this register is automatically updated by GPDMA from the memory, provided the LLI is set with GPDMA_CxLLR.USA = 1.
Note: A source address must be aligned with the programmed data width of a source burst (SA[2:0] versus GPDMA_CxTR1.SDW_LOG2[1:0]). Else, a user setting error is reported and no transfer is issued.</description>
                <bitOffset>0</bitOffset>
                <bitWidth>32</bitWidth>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>GPDMA_C3DAR</name>
            <displayName>GPDMA_C3DAR</displayName>
            <description>GPDMA channel 3 destination address register</description>
            <addressOffset>0x220</addressOffset>
            <size>0x20</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>DA</name>
                <description>destination address
This field is the pointer to the address from which the next data is written.
During the channel activity, depending on the destination addressing mode (GPDMA_CxTR1.DINC), this field is kept fixed or incremented by the data width (GPDMA_CxTR1.DDW_LOG2[21:0]) after each burst destination data, reflecting the next address from which data is written.
During the channel activity, this address is updated after each completed destination burst, consequently to:
the programmed destination burst; either in fixed addressing mode or in contiguous-data incremented mode. If contiguously incremented (GPDMA_CxTR1.DINC = 1), then the additional address offset value is the programmed burst size, as defined by GPDMA_CxTR1.DBL_1[5:0] and GPDMA_CxTR1.DDW_LOG2[1:0]
the additional destination incremented/decremented offset value as programmed by GPDMA_CxBR1.DDEC.
In linked-list mode, after a LLI data transfer is completed, this register is automatically updated by the GPDMA from the memory, provided the LLI is set with GPDMA_CxLLR.UDA = 1.
Note: A destination address must be aligned with the programmed data width of a destination burst (DA[2:0] versus GPDMA_CxTR1.DDW_LOG2[1:0]). Else, a user setting error is reported and no transfer is issued.</description>
                <bitOffset>0</bitOffset>
                <bitWidth>32</bitWidth>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>GPDMA_C3LLR</name>
            <displayName>GPDMA_C3LLR</displayName>
            <description>GPDMA channel 3 linked-list address register</description>
            <addressOffset>0x24C</addressOffset>
            <size>0x20</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>LA</name>
                <description>pointer (16-bit low-significant address) to the next linked-list data structure
If UT1 = UT2 = UB1 = USA = UDA = ULL = 0 and if LA[15:20] = 0, the current LLI is the last one. The channel transfer is completed without any update of the linked-list GPDMA register file.
Else, this field is the pointer to the memory address offset from which the next linked-list data structure is automatically fetched from, once the data transfer is completed, in order to conditionally update the linked-list GPDMA internal register file (GPDMA_CxCTR1, GPDMA_CxTR2, GPDMA_CxBR1, GPDMA_CxSAR, GPDMA_CxDAR and GPDMA_CxLLR).
Note: The user must program the pointer to be 32-bit aligned. The two low-significant bits are write ignored.</description>
                <bitOffset>2</bitOffset>
                <bitWidth>14</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>ULL</name>
                <description>Update GPDMA_CxLLR register from memory
This bit is used to control the update of GPDMA_CxLLR from the memory during the link transfer.</description>
                <bitOffset>16</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>no GPDMA_CxLLR update</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>GPDMA_CxLLR update</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>UDA</name>
                <description>Update GPDMA_CxDAR register from memory
This bit is used to control the update of GPDMA_CxDAR from the memory during the link transfer.</description>
                <bitOffset>27</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>no GPDMA_CxDAR update</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>GPDMA_CxDAR update</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>USA</name>
                <description>update GPDMA_CxSAR from memory
This bit controls the update of GPDMA_CxSAR from the memory during the link transfer.</description>
                <bitOffset>28</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>no GPDMA_CxSAR update</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>GPDMA_CxSAR update</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>UB1</name>
                <description>Update GPDMA_CxBR1 from memory
This bit controls the update of GPDMA_CxBR1 from the memory during the link transfer. If UB1 = 0 and if GPDMA_CxLLR  0, the linked-list is not completed. GPDMA_CxBR1.BNDT[15:0] is then restored to the programmed value after data transfer is completed and before the link transfer.</description>
                <bitOffset>29</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>no GPDMA_CxBR1 update from memory (GPDMA_CxBR1.BNDT[15:0] restored if any link transfer)</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>GPDMA_CxBR1 update</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>UT2</name>
                <description>Update GPDMA_CxTR2 from memory
This bit controls the update of GPDMA_CxTR2 from the memory during the link transfer.</description>
                <bitOffset>30</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>no GPDMA_CxTR2 update</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>GPDMA_CxTR2 update</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>UT1</name>
                <description>Update GPDMA_CxTR1 from memory
This bit controls the update of GPDMA_CxTR1 from the memory during the link transfer.</description>
                <bitOffset>31</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>no GPDMA_CxTR1 update</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>GPDMA_CxTR1 update</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
            </fields>
          </register>
          <register>
            <name>GPDMA_C4LBAR</name>
            <displayName>GPDMA_C4LBAR</displayName>
            <description>GPDMA channel 4 linked-list base address register</description>
            <addressOffset>0x250</addressOffset>
            <size>0x20</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>LBA</name>
                <description>linked-list base address of GPDMA channel x</description>
                <bitOffset>16</bitOffset>
                <bitWidth>16</bitWidth>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>GPDMA_C4FCR</name>
            <displayName>GPDMA_C4FCR</displayName>
            <description>GPDMA channel 4 flag clear register</description>
            <addressOffset>0x25C</addressOffset>
            <size>0x20</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>TCF</name>
                <description>transfer complete flag clear</description>
                <bitOffset>8</bitOffset>
                <bitWidth>1</bitWidth>
                <access>write-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>no effect</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>corresponding TCF flag cleared</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>HTF</name>
                <description>half transfer flag clear</description>
                <bitOffset>9</bitOffset>
                <bitWidth>1</bitWidth>
                <access>write-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>no effect</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>corresponding HTF flag cleared</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>DTEF</name>
                <description>data transfer error flag clear</description>
                <bitOffset>10</bitOffset>
                <bitWidth>1</bitWidth>
                <access>write-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>no effect</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>corresponding DTEF flag cleared</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>ULEF</name>
                <description>update link transfer error flag clear</description>
                <bitOffset>11</bitOffset>
                <bitWidth>1</bitWidth>
                <access>write-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>no effect</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>corresponding ULEF flag cleared</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>USEF</name>
                <description>user setting error flag clear</description>
                <bitOffset>12</bitOffset>
                <bitWidth>1</bitWidth>
                <access>write-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>no effect</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>corresponding USEF flag cleared</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>SUSPF</name>
                <description>completed suspension flag clear</description>
                <bitOffset>13</bitOffset>
                <bitWidth>1</bitWidth>
                <access>write-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>no effect</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>corresponding SUSPF flag cleared</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>TOF</name>
                <description>trigger overrun flag clear</description>
                <bitOffset>14</bitOffset>
                <bitWidth>1</bitWidth>
                <access>write-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>no effect</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>corresponding TOF flag cleared</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
            </fields>
          </register>
          <register>
            <name>GPDMA_C4SR</name>
            <displayName>GPDMA_C4SR</displayName>
            <description>GPDMA channel 4 status register</description>
            <addressOffset>0x260</addressOffset>
            <size>0x20</size>
            <resetValue>0x00000001</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>IDLEF</name>
                <description>idle flag
This idle flag is deasserted by hardware when the channel is enabled (GPDMA_CxCR.EN = 1) with a valid channel configuration (no USEF to be immediately reported).
This idle flag is asserted after hard reset or by hardware when the channel is back in idle state (in suspended or disabled state).</description>
                <bitOffset>0</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>channel not in idle state</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>channel in idle state</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>TCF</name>
                <description>transfer complete flag
A transfer complete event is either a block transfer complete, or a LLI transfer complete including the upload of the next LLI if any, or the full linked-list completion, depending on the transfer complete event mode (GPDMA_CxTR2.TCEM[1:0]).</description>
                <bitOffset>8</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>no transfer complete event</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>a transfer complete event occurred</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>HTF</name>
                <description>half transfer flag
A half block transfer occurs when half of the bytes of the source block size (rounded up integer of GPDMA_CxBR1.BNDT[15:0]/2) has been transferred to the destination.</description>
                <bitOffset>9</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>no half transfer event</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>a half transfer event occurred</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>DTEF</name>
                <description>data transfer error flag</description>
                <bitOffset>10</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>no data transfer error event</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>a master bus error event occurred on a data transfer</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>ULEF</name>
                <description>update link transfer error flag</description>
                <bitOffset>11</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>no update link transfer error event</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>a master bus error event occurred while updating a linked-list register from memory</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>USEF</name>
                <description>user setting error flag</description>
                <bitOffset>12</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>no user setting error event</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>a user setting error event occurred</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>SUSPF</name>
                <description>completed suspension flag</description>
                <bitOffset>13</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>no completed suspension event</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>a completed suspension event occurred</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>TOF</name>
                <description>trigger overrun flag</description>
                <bitOffset>14</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>no trigger overrun event</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>a trigger overrun event occurred</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>FIFOL</name>
                <description>monitored FIFO level
Number of available write beats in the FIFO, in units of the programmed destination data width (see GPDMA_CxTR1.DDW_LOG2[1:0], in units of bytes, half-words, or words).
Note: After having suspended an active transfer, the user may need to read FIFOL[7:0], additionally to GPDMA_CxBR1.BDNT[15:0] to know how many data have been transferred to the destination. Before reading, the user may wait for the transfer to be suspended (GPDMA_CxSR.SUSPF = 1).</description>
                <bitOffset>16</bitOffset>
                <bitWidth>8</bitWidth>
                <access>read-only</access>
              </field>
            </fields>
          </register>
          <register>
            <name>GPDMA_C4CR</name>
            <displayName>GPDMA_C4CR</displayName>
            <description>GPDMA channel 4 control register</description>
            <addressOffset>0x264</addressOffset>
            <size>0x20</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>EN</name>
                <description>enable
Writing 1 into the field RESET (bit 1) causes the hardware to de-assert this bit, whatever is written into this bit 0. Else: 
this bit is deasserted by hardware when there is a transfer error (master bus error or user setting error) or when there is a channel transfer complete (channel ready to be configured, for example if LSM=1 at the end of a single execution of the LLI).
Else, this bit can be asserted by software. 
Writing 0 into this EN bit is ignored.</description>
                <bitOffset>0</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>write: ignored, read: channel disabled</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>write: enable channel, read: channel enabled</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>RESET</name>
                <description>reset
This bit is write only. Writing 0 has no impact. Writing 1 implies the reset of the following: the FIFO, the channel internal state, SUSP and EN bits (whatever is written receptively in bit 2 and bit 0).
The reset is effective when the channel is in steady state, meaning one of the following:
- active channel in suspended state (GPDMA_CxSR.SUSPF = 1 and GPDMA_CxSR.IDLEF = GPDMA_CxCR.EN = 1)
- channel in disabled state (GPDMA_CxSR.IDLEF = 1 and GPDMA_CxCR.EN = 0).
After writing a RESET, to continue using this channel, the user must explicitly reconfigure the channel including the hardware-modified configuration registers (GPDMA_CxBR1, GPDMA_CxSAR and GPDMA_CxDAR) before enabling again the channel (see the programming sequence in Figure 44).</description>
                <bitOffset>1</bitOffset>
                <bitWidth>1</bitWidth>
                <access>write-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>no channel reset</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>channel reset</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>SUSP</name>
                <description>suspend
Writing 1 into the field RESET (bit 1) causes the hardware to de-assert this bit, whatever is written into this bit 2. Else:
Software must write 1 in order to suspend an active channel (channel with an ongoing GPDMA transfer over its master ports). 
The software must write 0 in order to resume a suspended channel, following the programming sequence detailed in Figure 43.</description>
                <bitOffset>2</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>write: resume channel, read: channel not suspended</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>write: suspend channel, read: channel suspended.</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>TCIE</name>
                <description>transfer complete interrupt enable</description>
                <bitOffset>8</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>interrupt disabled</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>interrupt enabled</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>HTIE</name>
                <description>half transfer complete interrupt enable</description>
                <bitOffset>9</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>interrupt disabled</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>interrupt enabled</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>DTEIE</name>
                <description>data transfer error interrupt enable</description>
                <bitOffset>10</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>interrupt disabled</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>interrupt enabled</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>ULEIE</name>
                <description>update link transfer error interrupt enable</description>
                <bitOffset>11</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>interrupt disabled</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>interrupt enabled</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>USEIE</name>
                <description>user setting error interrupt enable</description>
                <bitOffset>12</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>interrupt disabled</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>interrupt enabled</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>SUSPIE</name>
                <description>completed suspension interrupt enable</description>
                <bitOffset>13</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>interrupt disabled</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>interrupt enabled</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>TOIE</name>
                <description>trigger overrun interrupt enable</description>
                <bitOffset>14</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>interrupt disabled</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>interrupt enabled</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>LSM</name>
                <description>Link step mode
First the (possible 1D/repeated) block transfer is executed as defined by the current internal register file until GPDMA_CxBR1.BNDT[15:0] = 0. Secondly the next linked-list data structure is conditionally uploaded from memory as defined by GPDMA_CxLLR. Then channel execution is completed.
Note: This bit must be written when EN=0. This bit is read-only when EN=1.</description>
                <bitOffset>16</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>channel executed for the full linked-list and completed at the end of the last LLI (GPDMA_CxLLR = 0). The 16 low-significant bits of the link address are null (LA[15:0] = 0) and all the update bits are null (UT1 =UB1 = UT2 = USA = UDA = ULL = 0). Then GPDMA_CxBR1.BNDT[15:0] = 0.</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>channel executed once for the current LLI</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>LAP</name>
                <description>linked-list allocated port
This bit is used to allocate the master port for the update of the GPDMA linked-list registers from the memory.
Note: This bit must be written when EN=0. This bit is read-only when EN=1.</description>
                <bitOffset>17</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>port 0 (AHB) allocated</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>port 1 (AHB) allocated</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>PRIO</name>
                <description>priority level of the channel x GPDMA transfer versus others
Note: This bit must be written when EN = 0. This bit is read-only when EN = 1.</description>
                <bitOffset>22</bitOffset>
                <bitWidth>2</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>low priority, low weight</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>low priority, mid weight</description>
                    <value>0x1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x2</name>
                    <description>low priority, high weight</description>
                    <value>0x2</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x3</name>
                    <description>high priority</description>
                    <value>0x3</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
            </fields>
          </register>
          <register>
            <name>GPDMA_C4TR1</name>
            <displayName>GPDMA_C4TR1</displayName>
            <description>GPDMA channel 4 transfer register 1</description>
            <addressOffset>0x290</addressOffset>
            <size>0x20</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>SDW_LOG2</name>
                <description>binary logarithm of the source data width of a burst in bytes
Setting a 8-byte data width causes a user setting error to be reported and no transfer is issued.
A source block size must be a multiple of the source data width (GPDMA_CxBR1.BNDT[2:0] versus SDW_LOG2[1:0]). Otherwise, a user setting error is reported and no transfer is issued.
Note: A source burst transfer must have an aligned address with its data width (start address GPDMA_CxSAR[2:0] versus SDW_LOG2[1:0]). Otherwise, a user setting error is reported and none transfer is issued.</description>
                <bitOffset>0</bitOffset>
                <bitWidth>2</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>byte</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>half-word (2 bytes)</description>
                    <value>0x1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x2</name>
                    <description>word (4 bytes)</description>
                    <value>0x2</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x3</name>
                    <description>user setting error reported and no transfer issued</description>
                    <value>0x3</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>SINC</name>
                <description>source incrementing burst
The source address, pointed by GPDMA_CxSAR, is kept constant after a burst beat/single transfer or is incremented by the offset value corresponding to a contiguous data after a burst beat/single transfer.</description>
                <bitOffset>3</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>fixed burst</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>contiguously incremented burst</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>SBL_1</name>
                <description>source burst length minus 1, between 0 and 63
The burst length unit is one data named beat within a burst. If SBL_1[5:0] =0 , the burst can be named as single. Each data/beat has a width defined by the destination data width SDW_LOG2[1:0].
Note: If a burst transfer crossed a 1-Kbyte address boundary on a AHB transfer, the GPDMA modifies and shortens the programmed burst into singles or bursts of lower length, to be compliant with the AHB protocol.
Note: If a burst transfer is of length greater than the FIFO size of the channel x, the GPDMA modifies and shortens the programmed burst into singles or bursts of lower length, to be compliant with the FIFO size. Transfer performance is lower, with GPDMA re-arbitration between effective and lower singles/bursts, but the data integrity is guaranteed.</description>
                <bitOffset>4</bitOffset>
                <bitWidth>6</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>PAM</name>
                <description>padding/alignment mode
If DDW_LOG2[1:0] = SDW_LOG2[1:0]: if the data width of a burst destination transfer is equal to the data width of a burst source transfer, these bits are ignored.
Else, in the following enumerated values, the condition PAM_1 is when destination data width is higher that source data width, and the condition PAM_2 is when destination data width is higher than source data width.
1x: successive source data are FIFO queued and packed at the destination data width, in a left (LSB) to right (MSB) order (named little endian), before a destination transfer
Note: 1x: source data is FIFO queued and unpacked at the destination data width, to be transferred in a left (LSB) to right (MSB) order (named little endian) to the destination</description>
                <bitOffset>11</bitOffset>
                <bitWidth>2</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0_PAM_1</name>
                    <description>source data is transferred as right aligned, padded with 0s up to the destination data width</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1_PAM_1</name>
                    <description>source data is transferred as right aligned, sign extended up to the destination data width</description>
                    <value>0x1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x0_PAM_2</name>
                    <description>source data is transferred as right aligned, left-truncated down to the destination data width</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1_PAM_2</name>
                    <description>source data is transferred as left-aligned, right-truncated down to the destination data width</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>SBX</name>
                <description>source byte exchange within the unaligned half-word of each source word 
If the source data width is shorter than a word, this bit is ignored.
If the source data width is a word:</description>
                <bitOffset>13</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>no byte-based exchange within the unaligned half-word of each source word</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>the two consecutive bytes within the unaligned half-word of each source word are exchanged.</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>SAP</name>
                <description>source allocated port
This bit is used to allocate the master port for the source transfer
Note: This bit must be written when EN = 0. This bit is read-only when EN = 1.</description>
                <bitOffset>14</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>port 0 (AHB) allocated</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>port 1 (AHB) allocated</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>SSEC</name>
                <description>security attribute of the GPDMA transfer from the source
If GPDMA_SECCFGR.SECx = 1 and the access is secure:
This is a secure register bit. This bit can only be read by a secure software. This bit must be written by a secure software when GPDMA_SECCFGR.SECx =1 . A secure write is ignored when GPDMA_SECCFGR.SECx = 0.
When GPDMA_SECCFGR.SECx is deasserted, this SSEC bit is also deasserted by hardware (on a secure reconfiguration of the channel as non-secure), and the GPDMA transfer from the source is non-secure.</description>
                <bitOffset>15</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>GPDMA transfer non-secure</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>GPDMA transfer secure</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>DDW_LOG2</name>
                <description>binary logarithm of the destination data width of a burst, in bytes
Setting a 8-byte data width causes a user setting error to be reported and none transfer is issued.
Note: A destination burst transfer must have an aligned address with its data width (start address GPDMA_CxDAR[2:0] versus DDW_LOG2[1:0]). Otherwise a user setting error is reported and no transfer is issued.</description>
                <bitOffset>16</bitOffset>
                <bitWidth>2</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>byte</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>half-word (2 bytes)</description>
                    <value>0x1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x2</name>
                    <description>word (4 bytes)</description>
                    <value>0x2</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x3</name>
                    <description>user setting error reported and no transfer issued</description>
                    <value>0x3</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>DINC</name>
                <description>destination incrementing burst
The destination address, pointed by GPDMA_CxDAR, is kept constant after a burst beat/single transfer, or is incremented by the offset value corresponding to a contiguous data after a burst beat/single transfer.</description>
                <bitOffset>19</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>fixed burst</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>contiguously incremented burst</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>DBL_1</name>
                <description>destination burst length minus 1, between 0 and 63
The burst length unit is one data named beat within a burst. If DBL_1[5:0] =0 , the burst can be named as single. Each data/beat has a width defined by the destination data width DDW_LOG2[1:0].
Note: If a burst transfer crossed a 1-Kbyte address boundary on a AHB transfer, the GPDMA modifies and shortens the programmed burst into singles or bursts of lower length, to be compliant with the AHB protocol.
Note: If a burst transfer is of length greater than the FIFO size of the channel x, the GPDMA modifies and shortens the programmed burst into singles or bursts of lower length, to be compliant with the FIFO size. Transfer performance is lower, with GPDMA re-arbitration between effective and lower singles/bursts, but the data integrity is guaranteed.</description>
                <bitOffset>20</bitOffset>
                <bitWidth>6</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>DBX</name>
                <description>destination byte exchange
If the destination data size is a byte, this bit is ignored.
If the destination data size is not a byte:</description>
                <bitOffset>26</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>no byte-based exchange within half-word</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>the two consecutive (post PAM) bytes are exchanged in each destination half-word.</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>DHX</name>
                <description>destination half-word exchange
If the destination data size is shorter than a word, this bit is ignored.
If the destination data size is a word:</description>
                <bitOffset>27</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>no halfword-based exchanged within word</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>the two consecutive (post PAM) half-words are exchanged in each destination word.</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>DAP</name>
                <description>destination allocated port
This bit is used to allocate the master port for the destination transfer
Note: This bit must be written when EN = 0. This bit is read-only when EN = 1.</description>
                <bitOffset>30</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>port 0 (AHB) allocated</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>port 1 (AHB) allocated</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>DSEC</name>
                <description>security attribute of the GPDMA transfer to the destination
If GPDMA_SECCFGR.SECx = 1 and the access is secure:
This is a secure register bit. This bit can only be read by a secure software. This bit must be written by a secure software when GPDMA_SECCFGR.SECx = 1. A secure write is ignored when GPDMA_SECCFGR.SECx = 0.
When GPDMA_SECCFGR.SECx is deasserted, this DSEC bit is also deasserted by hardware (on a secure reconfiguration of the channel as non-secure), and the GPDMA transfer to the destination is non-secure.</description>
                <bitOffset>31</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>GPDMA transfer non-secure</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>GPDMA transfer secure</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
            </fields>
          </register>
          <register>
            <name>GPDMA_C4TR2</name>
            <displayName>GPDMA_C4TR2</displayName>
            <description>GPDMA channel 4 transfer register 2</description>
            <addressOffset>0x294</addressOffset>
            <size>0x20</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>REQSEL</name>
                <description>GPDMA hardware request selection
These bits are ignored if channel x is activated (GPDMA_CxCR.EN asserted) with SWREQ = 1 (software request for a memory-to-memory transfer). Else, the selected hardware request is internally taken into account as per Section 16.3.3.
The user must not assign a same input hardware request (same REQSEL[5:0] value) to different active GPDMA channels (GPDMA_CxCR.EN = 1 and GPDMA_CxTR2.SWREQ = 0 for these channels). GPDMA is not intended to hardware support the case of simultaneous enabled channels incorrectly configured with a same hardware peripheral request signal, and there is no user setting error reporting.</description>
                <bitOffset>0</bitOffset>
                <bitWidth>6</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>SWREQ</name>
                <description>software request
This bit is internally taken into account when GPDMA_CxCR.EN is asserted.</description>
                <bitOffset>9</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>no software request. The selected hardware request REQSEL[5:0] is taken into account.</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>software request for a memory-to-memory transfer. The default selected hardware request as per REQSEL[5:0] is ignored.</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>DREQ</name>
                <description>destination hardware request
This bit is ignored if channel x is activated (GPDMA_CxCR.EN asserted) with SWREQ = 1 (software request for a memory-to-memory transfer). Else:</description>
                <bitOffset>10</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>selected hardware request driven by a source peripheral (request signal taken into account by the GPDMA transfer scheduler over the source/read port)</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>selected hardware request driven by a destination peripheral (request signal taken into account by the GPDMA transfer scheduler over the destination/write port)</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>BREQ</name>
                <description>Block hardware request
If the channel x is activated (GPDMA_CxCR.EN asserted) with SWREQ = 1 (software request for a memory-to-memory transfer), this bit is ignored. Else:</description>
                <bitOffset>11</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>the selected hardware request is driven by a peripheral with a hardware request/acknowledge protocol at a burst level.</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>the selected hardware request is driven by a peripheral with a hardware request/acknowledge protocol at a block level (see Section 16.3.3).</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>TRIGM</name>
                <description>trigger mode
These bits define the transfer granularity for its conditioning by the trigger.
If the channel x is enabled (GPDMA_CxCR.EN asserted) with TRIGPOL[1:0] = 00 or 11, these TRIGM[1:0] bits are ignored.
Else, a GPDMA transfer is conditioned by at least one trigger hit: 
 If the peripheral is programmed as a source (DREQ = 0) of the LLI data transfer, each programmed burst read is conditioned.
 If the peripheral is programmed as a destination (DREQ = 1) of the LLI data transfer, each programmed burst write is conditioned. The first memory burst read of a block, also named as the first ready FIFO-based source burst, is gated by the occurrence of both the hardware request and the first trigger hit.
The GPDMA monitoring of a trigger for channel x is started when the channel is enabled/loaded with a new active trigger configuration: rising or falling edge on a selected trigger (TRIGPOL[1:0] = 01 or respectively TRIGPOL[1:0] = 10).
The monitoring of this trigger is kept active during the triggered and uncompleted (data or link) transfer; and if a new trigger is detected then, this hit is internally memorized to grant the next transfer, as long as the defined rising or falling edge is not modified, and the TRIGSEL[4:0] is not modified, and the channel is enabled.
Transferring a next LLI&lt;sub&gt;n+1&lt;/sub&gt; that updates the GPDMA_CxTR2 with a new value for any of TRIGSEL[4:0] or TRIGPOL[1:0], resets the monitoring, trashing the memorized hit of the formerly defined LLI&lt;sub&gt;n &lt;/sub&gt;trigger.
After a first new trigger hit&lt;sub&gt;n+1&lt;/sub&gt; is memorized, if another second trigger hit&lt;sub&gt;n+2&lt;/sub&gt; is detected and if the hit&lt;sub&gt;n&lt;/sub&gt; triggered transfer is still not completed, hit&lt;sub&gt;n+2 &lt;/sub&gt;is lost and not memorized.memorized. A trigger overrun flag is reported (GPDMA_CxSR.TOF =1 ), and an interrupt is generated if enabled (GPDMA_CxCR.TOIE = 1). The channel is not automatically disabled by hardware due to a trigger overrun. 
Note: When the source block size is not a multiple of the source burst size and is a multiple of the source data width, then the last programmed source burst is not completed and is internally shorten to match the block size. In this case, if TRIGM[1:0] = 11 and (SWREQ =1  or (SWREQ = 0 and DREQ =0 )), the shortened burst transfer (by singles or/and by bursts of lower length) is conditioned once by the trigger.
Note: When the programmed destination burst is internally shortened by singles or/and by bursts of lower length (versus FIFO size, versus block size, 1-Kbyte boundary address crossing): if the trigger is conditioning the programmed destination burst (if TRIGM[1:0] = 11 and SWREQ = 0 and DREQ = 1), this shortened destination burst transfer is conditioned once by the trigger.</description>
                <bitOffset>14</bitOffset>
                <bitWidth>2</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>at block level: the first burst read of each block transfer is conditioned by one hit trigger .</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>channel x = 0 to 7, same as 0010: at link level: a LLI link transfer is conditioned by one hit trigger. The LLI data transfer (if any) is not conditioned.</description>
                    <value>0x1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x3</name>
                    <description>at programmed burst level: If SWREQ = 1, each programmed burst read is conditioned by one hit trigger. If SWREQ = 0, each programmed burst that is requested by the selected peripheral, is conditioned by one hit trigger.</description>
                    <value>0x3</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>TRIGSEL</name>
                <description>trigger event input selection
These bits select the trigger event input of the GPDMA transfer (as per Section 16.3.5), with an active trigger event if TRIGPOL[1:0]  00.</description>
                <bitOffset>16</bitOffset>
                <bitWidth>5</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>TRIGPOL</name>
                <description>trigger event polarity
These bits define the polarity of the selected trigger event input defined by TRIGSEL[4:0].</description>
                <bitOffset>24</bitOffset>
                <bitWidth>2</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>no trigger (masked trigger event)</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>trigger on the rising edge</description>
                    <value>0x1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x2</name>
                    <description>trigger on the falling edge</description>
                    <value>0x2</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x3</name>
                    <description>same as 00</description>
                    <value>0x3</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>TCEM</name>
                <description>transfer complete event mode
These bits define the transfer granularity for the transfer complete and half transfer complete events generation.
Note: If the initial LLI&lt;sub&gt;0 &lt;/sub&gt;data transfer is null/void (directly programmed by the internal register file with GPDMA_CxBR1.BNDT[15:0] = 0), then neither the complete transfer event nor the half transfer event is generated.
Note: If the initial LLI&lt;sub&gt;0 &lt;/sub&gt;data transfer is null/void (directly programmed by the internal register file with GPDMA_CxBR1.BNDT[15:0] = 0), then neither the complete transfer event nor the half transfer event is generated.
Note: If the initial LLI&lt;sub&gt;0 &lt;/sub&gt;data transfer is null/void (i.e. directly programmed by the internal register file with GPDMA_CxBR1.BNDT[15:0] =0 ), then the half transfer event is not generated, and the transfer complete event is generated when is completed the loading of the LLI&lt;sub&gt;1&lt;/sub&gt;.</description>
                <bitOffset>30</bitOffset>
                <bitWidth>2</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>at block level (when GPDMA_CxBR1.BNDT[15:0] = 0): the complete (and the half) transfer event is generated at the (respectively half of the) end of a block.</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>channel x (0 to 7, same as 00</description>
                    <value>0x1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x2</name>
                    <description>at LLI level: the complete transfer event is generated at the end of the LLI transfer, including the update of the LLI if any. The half transfer event is generated at the half of the LLI data transfer.</description>
                    <value>0x2</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x3</name>
                    <description>at channel level: the complete transfer event is generated at the end of the last LLI transfer. The half transfer event is generated at the half of the data transfer of the last LLI. The last LLI updates the link address GPDMA_CxLLR.LA[15:2] to zero and clears all the GPDMA_CxLLR update bits (UT1, UT2, UB1, USA, UDA and ULL). If the channel transfer is continuous/infinite, no event is generated.</description>
                    <value>0x3</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
            </fields>
          </register>
          <register>
            <name>GPDMA_C4BR1</name>
            <displayName>GPDMA_C4BR1</displayName>
            <description>GPDMA channel 4 block register 1</description>
            <addressOffset>0x298</addressOffset>
            <size>0x20</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>BNDT</name>
                <description>block number of data bytes to transfer from the source
Block size transferred from the source. When the channel is enabled, this field becomes read-only and is decremented, indicating the remaining number of data items in the current source block to be transferred. BNDT[15:0] is programmed in number of bytes, maximum source block size is 64 Kbytes -1.
Once the last data transfer is completed (BNDT[15:0] = 0):
- if GPDMA_CxLLR.UB1 = 1, this field is updated by the LLI in the memory.
- if GPDMA_CxLLR.UB1 = 0 and if there is at least one non null Uxx update bit, this field is internally restored to the programmed value.
- if all GPDMA_CxLLR.Uxx = 0 and if GPDMA_CxLLR.LA[15:0] = 0, this field is internally restored to the programmed value (infinite/continuous last LLI).
- if GPDMA_CxLLR = 0, this field is kept as zero following the last LLI data transfer.
Note: A non-null source block size must be a multiple of the source data width (BNDT[2:0] versus GPDMA_CxTR1.SDW_LOG2[1:0]). Else a user setting error is reported and no transfer is issued.
Note: When configured in packing mode (GPDMA_CxTR1.PAM[1] = 1 and destination data width different from source data width), a non-null source block size must be a multiple of the destination data width (BNDT[2:0] versus GPDMA_CxTR1.DDW_LOG2[1:0]). Else a user setting error is reported and no transfer is issued.</description>
                <bitOffset>0</bitOffset>
                <bitWidth>16</bitWidth>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>GPDMA_C4SAR</name>
            <displayName>GPDMA_C4SAR</displayName>
            <description>GPDMA channel 4 source address register</description>
            <addressOffset>0x29C</addressOffset>
            <size>0x20</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>SA</name>
                <description>source address
This field is the pointer to the address from which the next data is read.
During the channel activity, depending on the source addressing mode (GPDMA_CxTR1.SINC), this field is kept fixed or incremented by the data width (GPDMA_CxTR1.SDW_LOG2[1:0]) after each burst source data, reflecting the next address from which data is read.
During the channel activity, this address is updated after each completed source burst, consequently to:
the programmed source burst; either in fixed addressing mode or in contiguous-data incremented mode. If contiguously incremented (GPDMA_CxTR1.SINC = 1), then the additional address offset value is the programmed burst size, as defined by GPDMA_CxTR1.SBL_1[5:0] and GPDMA_CxTR1.SDW_LOG2[21:0]
the additional source incremented/decremented offset value as programmed by GPDMA_CxBR1.SDEC
In linked-list mode, after a LLI data transfer is completed, this register is automatically updated by GPDMA from the memory, provided the LLI is set with GPDMA_CxLLR.USA = 1.
Note: A source address must be aligned with the programmed data width of a source burst (SA[2:0] versus GPDMA_CxTR1.SDW_LOG2[1:0]). Else, a user setting error is reported and no transfer is issued.</description>
                <bitOffset>0</bitOffset>
                <bitWidth>32</bitWidth>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>GPDMA_C4DAR</name>
            <displayName>GPDMA_C4DAR</displayName>
            <description>GPDMA channel 4 destination address register</description>
            <addressOffset>0x2A0</addressOffset>
            <size>0x20</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>DA</name>
                <description>destination address
This field is the pointer to the address from which the next data is written.
During the channel activity, depending on the destination addressing mode (GPDMA_CxTR1.DINC), this field is kept fixed or incremented by the data width (GPDMA_CxTR1.DDW_LOG2[21:0]) after each burst destination data, reflecting the next address from which data is written.
During the channel activity, this address is updated after each completed destination burst, consequently to:
the programmed destination burst; either in fixed addressing mode or in contiguous-data incremented mode. If contiguously incremented (GPDMA_CxTR1.DINC = 1), then the additional address offset value is the programmed burst size, as defined by GPDMA_CxTR1.DBL_1[5:0] and GPDMA_CxTR1.DDW_LOG2[1:0]
the additional destination incremented/decremented offset value as programmed by GPDMA_CxBR1.DDEC.
In linked-list mode, after a LLI data transfer is completed, this register is automatically updated by the GPDMA from the memory, provided the LLI is set with GPDMA_CxLLR.UDA = 1.
Note: A destination address must be aligned with the programmed data width of a destination burst (DA[2:0] versus GPDMA_CxTR1.DDW_LOG2[1:0]). Else, a user setting error is reported and no transfer is issued.</description>
                <bitOffset>0</bitOffset>
                <bitWidth>32</bitWidth>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>GPDMA_C4LLR</name>
            <displayName>GPDMA_C4LLR</displayName>
            <description>GPDMA channel 4 linked-list address register</description>
            <addressOffset>0x2CC</addressOffset>
            <size>0x20</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>LA</name>
                <description>pointer (16-bit low-significant address) to the next linked-list data structure
If UT1 = UT2 = UB1 = USA = UDA = ULL = 0 and if LA[15:20] = 0, the current LLI is the last one. The channel transfer is completed without any update of the linked-list GPDMA register file.
Else, this field is the pointer to the memory address offset from which the next linked-list data structure is automatically fetched from, once the data transfer is completed, in order to conditionally update the linked-list GPDMA internal register file (GPDMA_CxCTR1, GPDMA_CxTR2, GPDMA_CxBR1, GPDMA_CxSAR, GPDMA_CxDAR and GPDMA_CxLLR).
Note: The user must program the pointer to be 32-bit aligned. The two low-significant bits are write ignored.</description>
                <bitOffset>2</bitOffset>
                <bitWidth>14</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>ULL</name>
                <description>Update GPDMA_CxLLR register from memory
This bit is used to control the update of GPDMA_CxLLR from the memory during the link transfer.</description>
                <bitOffset>16</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>no GPDMA_CxLLR update</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>GPDMA_CxLLR update</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>UDA</name>
                <description>Update GPDMA_CxDAR register from memory
This bit is used to control the update of GPDMA_CxDAR from the memory during the link transfer.</description>
                <bitOffset>27</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>no GPDMA_CxDAR update</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>GPDMA_CxDAR update</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>USA</name>
                <description>update GPDMA_CxSAR from memory
This bit controls the update of GPDMA_CxSAR from the memory during the link transfer.</description>
                <bitOffset>28</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>no GPDMA_CxSAR update</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>GPDMA_CxSAR update</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>UB1</name>
                <description>Update GPDMA_CxBR1 from memory
This bit controls the update of GPDMA_CxBR1 from the memory during the link transfer. If UB1 = 0 and if GPDMA_CxLLR  0, the linked-list is not completed. GPDMA_CxBR1.BNDT[15:0] is then restored to the programmed value after data transfer is completed and before the link transfer.</description>
                <bitOffset>29</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>no GPDMA_CxBR1 update from memory (GPDMA_CxBR1.BNDT[15:0] restored if any link transfer)</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>GPDMA_CxBR1 update</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>UT2</name>
                <description>Update GPDMA_CxTR2 from memory
This bit controls the update of GPDMA_CxTR2 from the memory during the link transfer.</description>
                <bitOffset>30</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>no GPDMA_CxTR2 update</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>GPDMA_CxTR2 update</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>UT1</name>
                <description>Update GPDMA_CxTR1 from memory
This bit controls the update of GPDMA_CxTR1 from the memory during the link transfer.</description>
                <bitOffset>31</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>no GPDMA_CxTR1 update</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>GPDMA_CxTR1 update</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
            </fields>
          </register>
          <register>
            <name>GPDMA_C5LBAR</name>
            <displayName>GPDMA_C5LBAR</displayName>
            <description>GPDMA channel 5 linked-list base address register</description>
            <addressOffset>0x2D0</addressOffset>
            <size>0x20</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>LBA</name>
                <description>linked-list base address of GPDMA channel x</description>
                <bitOffset>16</bitOffset>
                <bitWidth>16</bitWidth>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>GPDMA_C5FCR</name>
            <displayName>GPDMA_C5FCR</displayName>
            <description>GPDMA channel 5 flag clear register</description>
            <addressOffset>0x2DC</addressOffset>
            <size>0x20</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>TCF</name>
                <description>transfer complete flag clear</description>
                <bitOffset>8</bitOffset>
                <bitWidth>1</bitWidth>
                <access>write-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>no effect</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>corresponding TCF flag cleared</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>HTF</name>
                <description>half transfer flag clear</description>
                <bitOffset>9</bitOffset>
                <bitWidth>1</bitWidth>
                <access>write-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>no effect</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>corresponding HTF flag cleared</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>DTEF</name>
                <description>data transfer error flag clear</description>
                <bitOffset>10</bitOffset>
                <bitWidth>1</bitWidth>
                <access>write-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>no effect</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>corresponding DTEF flag cleared</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>ULEF</name>
                <description>update link transfer error flag clear</description>
                <bitOffset>11</bitOffset>
                <bitWidth>1</bitWidth>
                <access>write-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>no effect</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>corresponding ULEF flag cleared</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>USEF</name>
                <description>user setting error flag clear</description>
                <bitOffset>12</bitOffset>
                <bitWidth>1</bitWidth>
                <access>write-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>no effect</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>corresponding USEF flag cleared</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>SUSPF</name>
                <description>completed suspension flag clear</description>
                <bitOffset>13</bitOffset>
                <bitWidth>1</bitWidth>
                <access>write-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>no effect</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>corresponding SUSPF flag cleared</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>TOF</name>
                <description>trigger overrun flag clear</description>
                <bitOffset>14</bitOffset>
                <bitWidth>1</bitWidth>
                <access>write-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>no effect</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>corresponding TOF flag cleared</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
            </fields>
          </register>
          <register>
            <name>GPDMA_C5SR</name>
            <displayName>GPDMA_C5SR</displayName>
            <description>GPDMA channel 5 status register</description>
            <addressOffset>0x2E0</addressOffset>
            <size>0x20</size>
            <resetValue>0x00000001</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>IDLEF</name>
                <description>idle flag
This idle flag is deasserted by hardware when the channel is enabled (GPDMA_CxCR.EN = 1) with a valid channel configuration (no USEF to be immediately reported).
This idle flag is asserted after hard reset or by hardware when the channel is back in idle state (in suspended or disabled state).</description>
                <bitOffset>0</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>channel not in idle state</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>channel in idle state</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>TCF</name>
                <description>transfer complete flag
A transfer complete event is either a block transfer complete, or a LLI transfer complete including the upload of the next LLI if any, or the full linked-list completion, depending on the transfer complete event mode (GPDMA_CxTR2.TCEM[1:0]).</description>
                <bitOffset>8</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>no transfer complete event</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>a transfer complete event occurred</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>HTF</name>
                <description>half transfer flag
A half block transfer occurs when half of the bytes of the source block size (rounded up integer of GPDMA_CxBR1.BNDT[15:0]/2) has been transferred to the destination.</description>
                <bitOffset>9</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>no half transfer event</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>a half transfer event occurred</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>DTEF</name>
                <description>data transfer error flag</description>
                <bitOffset>10</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>no data transfer error event</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>a master bus error event occurred on a data transfer</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>ULEF</name>
                <description>update link transfer error flag</description>
                <bitOffset>11</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>no update link transfer error event</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>a master bus error event occurred while updating a linked-list register from memory</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>USEF</name>
                <description>user setting error flag</description>
                <bitOffset>12</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>no user setting error event</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>a user setting error event occurred</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>SUSPF</name>
                <description>completed suspension flag</description>
                <bitOffset>13</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>no completed suspension event</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>a completed suspension event occurred</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>TOF</name>
                <description>trigger overrun flag</description>
                <bitOffset>14</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>no trigger overrun event</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>a trigger overrun event occurred</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>FIFOL</name>
                <description>monitored FIFO level
Number of available write beats in the FIFO, in units of the programmed destination data width (see GPDMA_CxTR1.DDW_LOG2[1:0], in units of bytes, half-words, or words).
Note: After having suspended an active transfer, the user may need to read FIFOL[7:0], additionally to GPDMA_CxBR1.BDNT[15:0] to know how many data have been transferred to the destination. Before reading, the user may wait for the transfer to be suspended (GPDMA_CxSR.SUSPF = 1).</description>
                <bitOffset>16</bitOffset>
                <bitWidth>8</bitWidth>
                <access>read-only</access>
              </field>
            </fields>
          </register>
          <register>
            <name>GPDMA_C5CR</name>
            <displayName>GPDMA_C5CR</displayName>
            <description>GPDMA channel 5 control register</description>
            <addressOffset>0x2E4</addressOffset>
            <size>0x20</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>EN</name>
                <description>enable
Writing 1 into the field RESET (bit 1) causes the hardware to de-assert this bit, whatever is written into this bit 0. Else: 
this bit is deasserted by hardware when there is a transfer error (master bus error or user setting error) or when there is a channel transfer complete (channel ready to be configured, for example if LSM=1 at the end of a single execution of the LLI).
Else, this bit can be asserted by software. 
Writing 0 into this EN bit is ignored.</description>
                <bitOffset>0</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>write: ignored, read: channel disabled</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>write: enable channel, read: channel enabled</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>RESET</name>
                <description>reset
This bit is write only. Writing 0 has no impact. Writing 1 implies the reset of the following: the FIFO, the channel internal state, SUSP and EN bits (whatever is written receptively in bit 2 and bit 0).
The reset is effective when the channel is in steady state, meaning one of the following:
- active channel in suspended state (GPDMA_CxSR.SUSPF = 1 and GPDMA_CxSR.IDLEF = GPDMA_CxCR.EN = 1)
- channel in disabled state (GPDMA_CxSR.IDLEF = 1 and GPDMA_CxCR.EN = 0).
After writing a RESET, to continue using this channel, the user must explicitly reconfigure the channel including the hardware-modified configuration registers (GPDMA_CxBR1, GPDMA_CxSAR and GPDMA_CxDAR) before enabling again the channel (see the programming sequence in Figure 44).</description>
                <bitOffset>1</bitOffset>
                <bitWidth>1</bitWidth>
                <access>write-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>no channel reset</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>channel reset</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>SUSP</name>
                <description>suspend
Writing 1 into the field RESET (bit 1) causes the hardware to de-assert this bit, whatever is written into this bit 2. Else:
Software must write 1 in order to suspend an active channel (channel with an ongoing GPDMA transfer over its master ports). 
The software must write 0 in order to resume a suspended channel, following the programming sequence detailed in Figure 43.</description>
                <bitOffset>2</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>write: resume channel, read: channel not suspended</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>write: suspend channel, read: channel suspended.</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>TCIE</name>
                <description>transfer complete interrupt enable</description>
                <bitOffset>8</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>interrupt disabled</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>interrupt enabled</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>HTIE</name>
                <description>half transfer complete interrupt enable</description>
                <bitOffset>9</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>interrupt disabled</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>interrupt enabled</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>DTEIE</name>
                <description>data transfer error interrupt enable</description>
                <bitOffset>10</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>interrupt disabled</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>interrupt enabled</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>ULEIE</name>
                <description>update link transfer error interrupt enable</description>
                <bitOffset>11</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>interrupt disabled</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>interrupt enabled</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>USEIE</name>
                <description>user setting error interrupt enable</description>
                <bitOffset>12</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>interrupt disabled</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>interrupt enabled</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>SUSPIE</name>
                <description>completed suspension interrupt enable</description>
                <bitOffset>13</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>interrupt disabled</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>interrupt enabled</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>TOIE</name>
                <description>trigger overrun interrupt enable</description>
                <bitOffset>14</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>interrupt disabled</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>interrupt enabled</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>LSM</name>
                <description>Link step mode
First the (possible 1D/repeated) block transfer is executed as defined by the current internal register file until GPDMA_CxBR1.BNDT[15:0] = 0. Secondly the next linked-list data structure is conditionally uploaded from memory as defined by GPDMA_CxLLR. Then channel execution is completed.
Note: This bit must be written when EN=0. This bit is read-only when EN=1.</description>
                <bitOffset>16</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>channel executed for the full linked-list and completed at the end of the last LLI (GPDMA_CxLLR = 0). The 16 low-significant bits of the link address are null (LA[15:0] = 0) and all the update bits are null (UT1 =UB1 = UT2 = USA = UDA = ULL = 0). Then GPDMA_CxBR1.BNDT[15:0] = 0.</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>channel executed once for the current LLI</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>LAP</name>
                <description>linked-list allocated port
This bit is used to allocate the master port for the update of the GPDMA linked-list registers from the memory.
Note: This bit must be written when EN=0. This bit is read-only when EN=1.</description>
                <bitOffset>17</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>port 0 (AHB) allocated</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>port 1 (AHB) allocated</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>PRIO</name>
                <description>priority level of the channel x GPDMA transfer versus others
Note: This bit must be written when EN = 0. This bit is read-only when EN = 1.</description>
                <bitOffset>22</bitOffset>
                <bitWidth>2</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>low priority, low weight</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>low priority, mid weight</description>
                    <value>0x1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x2</name>
                    <description>low priority, high weight</description>
                    <value>0x2</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x3</name>
                    <description>high priority</description>
                    <value>0x3</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
            </fields>
          </register>
          <register>
            <name>GPDMA_C5TR1</name>
            <displayName>GPDMA_C5TR1</displayName>
            <description>GPDMA channel 5 transfer register 1</description>
            <addressOffset>0x310</addressOffset>
            <size>0x20</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>SDW_LOG2</name>
                <description>binary logarithm of the source data width of a burst in bytes
Setting a 8-byte data width causes a user setting error to be reported and no transfer is issued.
A source block size must be a multiple of the source data width (GPDMA_CxBR1.BNDT[2:0] versus SDW_LOG2[1:0]). Otherwise, a user setting error is reported and no transfer is issued.
Note: A source burst transfer must have an aligned address with its data width (start address GPDMA_CxSAR[2:0] versus SDW_LOG2[1:0]). Otherwise, a user setting error is reported and none transfer is issued.</description>
                <bitOffset>0</bitOffset>
                <bitWidth>2</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>byte</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>half-word (2 bytes)</description>
                    <value>0x1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x2</name>
                    <description>word (4 bytes)</description>
                    <value>0x2</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x3</name>
                    <description>user setting error reported and no transfer issued</description>
                    <value>0x3</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>SINC</name>
                <description>source incrementing burst
The source address, pointed by GPDMA_CxSAR, is kept constant after a burst beat/single transfer or is incremented by the offset value corresponding to a contiguous data after a burst beat/single transfer.</description>
                <bitOffset>3</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>fixed burst</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>contiguously incremented burst</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>SBL_1</name>
                <description>source burst length minus 1, between 0 and 63
The burst length unit is one data named beat within a burst. If SBL_1[5:0] =0 , the burst can be named as single. Each data/beat has a width defined by the destination data width SDW_LOG2[1:0].
Note: If a burst transfer crossed a 1-Kbyte address boundary on a AHB transfer, the GPDMA modifies and shortens the programmed burst into singles or bursts of lower length, to be compliant with the AHB protocol.
Note: If a burst transfer is of length greater than the FIFO size of the channel x, the GPDMA modifies and shortens the programmed burst into singles or bursts of lower length, to be compliant with the FIFO size. Transfer performance is lower, with GPDMA re-arbitration between effective and lower singles/bursts, but the data integrity is guaranteed.</description>
                <bitOffset>4</bitOffset>
                <bitWidth>6</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>PAM</name>
                <description>padding/alignment mode
If DDW_LOG2[1:0] = SDW_LOG2[1:0]: if the data width of a burst destination transfer is equal to the data width of a burst source transfer, these bits are ignored.
Else, in the following enumerated values, the condition PAM_1 is when destination data width is higher that source data width, and the condition PAM_2 is when destination data width is higher than source data width.
1x: successive source data are FIFO queued and packed at the destination data width, in a left (LSB) to right (MSB) order (named little endian), before a destination transfer
Note: 1x: source data is FIFO queued and unpacked at the destination data width, to be transferred in a left (LSB) to right (MSB) order (named little endian) to the destination</description>
                <bitOffset>11</bitOffset>
                <bitWidth>2</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0_PAM_1</name>
                    <description>source data is transferred as right aligned, padded with 0s up to the destination data width</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1_PAM_1</name>
                    <description>source data is transferred as right aligned, sign extended up to the destination data width</description>
                    <value>0x1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x0_PAM_2</name>
                    <description>source data is transferred as right aligned, left-truncated down to the destination data width</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1_PAM_2</name>
                    <description>source data is transferred as left-aligned, right-truncated down to the destination data width</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>SBX</name>
                <description>source byte exchange within the unaligned half-word of each source word 
If the source data width is shorter than a word, this bit is ignored.
If the source data width is a word:</description>
                <bitOffset>13</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>no byte-based exchange within the unaligned half-word of each source word</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>the two consecutive bytes within the unaligned half-word of each source word are exchanged.</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>SAP</name>
                <description>source allocated port
This bit is used to allocate the master port for the source transfer
Note: This bit must be written when EN = 0. This bit is read-only when EN = 1.</description>
                <bitOffset>14</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>port 0 (AHB) allocated</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>port 1 (AHB) allocated</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>SSEC</name>
                <description>security attribute of the GPDMA transfer from the source
If GPDMA_SECCFGR.SECx = 1 and the access is secure:
This is a secure register bit. This bit can only be read by a secure software. This bit must be written by a secure software when GPDMA_SECCFGR.SECx =1 . A secure write is ignored when GPDMA_SECCFGR.SECx = 0.
When GPDMA_SECCFGR.SECx is deasserted, this SSEC bit is also deasserted by hardware (on a secure reconfiguration of the channel as non-secure), and the GPDMA transfer from the source is non-secure.</description>
                <bitOffset>15</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>GPDMA transfer non-secure</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>GPDMA transfer secure</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>DDW_LOG2</name>
                <description>binary logarithm of the destination data width of a burst, in bytes
Setting a 8-byte data width causes a user setting error to be reported and none transfer is issued.
Note: A destination burst transfer must have an aligned address with its data width (start address GPDMA_CxDAR[2:0] versus DDW_LOG2[1:0]). Otherwise a user setting error is reported and no transfer is issued.</description>
                <bitOffset>16</bitOffset>
                <bitWidth>2</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>byte</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>half-word (2 bytes)</description>
                    <value>0x1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x2</name>
                    <description>word (4 bytes)</description>
                    <value>0x2</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x3</name>
                    <description>user setting error reported and no transfer issued</description>
                    <value>0x3</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>DINC</name>
                <description>destination incrementing burst
The destination address, pointed by GPDMA_CxDAR, is kept constant after a burst beat/single transfer, or is incremented by the offset value corresponding to a contiguous data after a burst beat/single transfer.</description>
                <bitOffset>19</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>fixed burst</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>contiguously incremented burst</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>DBL_1</name>
                <description>destination burst length minus 1, between 0 and 63
The burst length unit is one data named beat within a burst. If DBL_1[5:0] =0 , the burst can be named as single. Each data/beat has a width defined by the destination data width DDW_LOG2[1:0].
Note: If a burst transfer crossed a 1-Kbyte address boundary on a AHB transfer, the GPDMA modifies and shortens the programmed burst into singles or bursts of lower length, to be compliant with the AHB protocol.
Note: If a burst transfer is of length greater than the FIFO size of the channel x, the GPDMA modifies and shortens the programmed burst into singles or bursts of lower length, to be compliant with the FIFO size. Transfer performance is lower, with GPDMA re-arbitration between effective and lower singles/bursts, but the data integrity is guaranteed.</description>
                <bitOffset>20</bitOffset>
                <bitWidth>6</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>DBX</name>
                <description>destination byte exchange
If the destination data size is a byte, this bit is ignored.
If the destination data size is not a byte:</description>
                <bitOffset>26</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>no byte-based exchange within half-word</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>the two consecutive (post PAM) bytes are exchanged in each destination half-word.</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>DHX</name>
                <description>destination half-word exchange
If the destination data size is shorter than a word, this bit is ignored.
If the destination data size is a word:</description>
                <bitOffset>27</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>no halfword-based exchanged within word</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>the two consecutive (post PAM) half-words are exchanged in each destination word.</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>DAP</name>
                <description>destination allocated port
This bit is used to allocate the master port for the destination transfer
Note: This bit must be written when EN = 0. This bit is read-only when EN = 1.</description>
                <bitOffset>30</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>port 0 (AHB) allocated</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>port 1 (AHB) allocated</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>DSEC</name>
                <description>security attribute of the GPDMA transfer to the destination
If GPDMA_SECCFGR.SECx = 1 and the access is secure:
This is a secure register bit. This bit can only be read by a secure software. This bit must be written by a secure software when GPDMA_SECCFGR.SECx = 1. A secure write is ignored when GPDMA_SECCFGR.SECx = 0.
When GPDMA_SECCFGR.SECx is deasserted, this DSEC bit is also deasserted by hardware (on a secure reconfiguration of the channel as non-secure), and the GPDMA transfer to the destination is non-secure.</description>
                <bitOffset>31</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>GPDMA transfer non-secure</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>GPDMA transfer secure</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
            </fields>
          </register>
          <register>
            <name>GPDMA_C5TR2</name>
            <displayName>GPDMA_C5TR2</displayName>
            <description>GPDMA channel 5 transfer register 2</description>
            <addressOffset>0x314</addressOffset>
            <size>0x20</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>REQSEL</name>
                <description>GPDMA hardware request selection
These bits are ignored if channel x is activated (GPDMA_CxCR.EN asserted) with SWREQ = 1 (software request for a memory-to-memory transfer). Else, the selected hardware request is internally taken into account as per Section 16.3.3.
The user must not assign a same input hardware request (same REQSEL[5:0] value) to different active GPDMA channels (GPDMA_CxCR.EN = 1 and GPDMA_CxTR2.SWREQ = 0 for these channels). GPDMA is not intended to hardware support the case of simultaneous enabled channels incorrectly configured with a same hardware peripheral request signal, and there is no user setting error reporting.</description>
                <bitOffset>0</bitOffset>
                <bitWidth>6</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>SWREQ</name>
                <description>software request
This bit is internally taken into account when GPDMA_CxCR.EN is asserted.</description>
                <bitOffset>9</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>no software request. The selected hardware request REQSEL[5:0] is taken into account.</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>software request for a memory-to-memory transfer. The default selected hardware request as per REQSEL[5:0] is ignored.</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>DREQ</name>
                <description>destination hardware request
This bit is ignored if channel x is activated (GPDMA_CxCR.EN asserted) with SWREQ = 1 (software request for a memory-to-memory transfer). Else:</description>
                <bitOffset>10</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>selected hardware request driven by a source peripheral (request signal taken into account by the GPDMA transfer scheduler over the source/read port)</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>selected hardware request driven by a destination peripheral (request signal taken into account by the GPDMA transfer scheduler over the destination/write port)</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>BREQ</name>
                <description>Block hardware request
If the channel x is activated (GPDMA_CxCR.EN asserted) with SWREQ = 1 (software request for a memory-to-memory transfer), this bit is ignored. Else:</description>
                <bitOffset>11</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>the selected hardware request is driven by a peripheral with a hardware request/acknowledge protocol at a burst level.</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>the selected hardware request is driven by a peripheral with a hardware request/acknowledge protocol at a block level (see Section 16.3.3).</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>TRIGM</name>
                <description>trigger mode
These bits define the transfer granularity for its conditioning by the trigger.
If the channel x is enabled (GPDMA_CxCR.EN asserted) with TRIGPOL[1:0] = 00 or 11, these TRIGM[1:0] bits are ignored.
Else, a GPDMA transfer is conditioned by at least one trigger hit: 
 If the peripheral is programmed as a source (DREQ = 0) of the LLI data transfer, each programmed burst read is conditioned.
 If the peripheral is programmed as a destination (DREQ = 1) of the LLI data transfer, each programmed burst write is conditioned. The first memory burst read of a block, also named as the first ready FIFO-based source burst, is gated by the occurrence of both the hardware request and the first trigger hit.
The GPDMA monitoring of a trigger for channel x is started when the channel is enabled/loaded with a new active trigger configuration: rising or falling edge on a selected trigger (TRIGPOL[1:0] = 01 or respectively TRIGPOL[1:0] = 10).
The monitoring of this trigger is kept active during the triggered and uncompleted (data or link) transfer; and if a new trigger is detected then, this hit is internally memorized to grant the next transfer, as long as the defined rising or falling edge is not modified, and the TRIGSEL[4:0] is not modified, and the channel is enabled.
Transferring a next LLI&lt;sub&gt;n+1&lt;/sub&gt; that updates the GPDMA_CxTR2 with a new value for any of TRIGSEL[4:0] or TRIGPOL[1:0], resets the monitoring, trashing the memorized hit of the formerly defined LLI&lt;sub&gt;n &lt;/sub&gt;trigger.
After a first new trigger hit&lt;sub&gt;n+1&lt;/sub&gt; is memorized, if another second trigger hit&lt;sub&gt;n+2&lt;/sub&gt; is detected and if the hit&lt;sub&gt;n&lt;/sub&gt; triggered transfer is still not completed, hit&lt;sub&gt;n+2 &lt;/sub&gt;is lost and not memorized.memorized. A trigger overrun flag is reported (GPDMA_CxSR.TOF =1 ), and an interrupt is generated if enabled (GPDMA_CxCR.TOIE = 1). The channel is not automatically disabled by hardware due to a trigger overrun. 
Note: When the source block size is not a multiple of the source burst size and is a multiple of the source data width, then the last programmed source burst is not completed and is internally shorten to match the block size. In this case, if TRIGM[1:0] = 11 and (SWREQ =1  or (SWREQ = 0 and DREQ =0 )), the shortened burst transfer (by singles or/and by bursts of lower length) is conditioned once by the trigger.
Note: When the programmed destination burst is internally shortened by singles or/and by bursts of lower length (versus FIFO size, versus block size, 1-Kbyte boundary address crossing): if the trigger is conditioning the programmed destination burst (if TRIGM[1:0] = 11 and SWREQ = 0 and DREQ = 1), this shortened destination burst transfer is conditioned once by the trigger.</description>
                <bitOffset>14</bitOffset>
                <bitWidth>2</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>at block level: the first burst read of each block transfer is conditioned by one hit trigger .</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>channel x = 0 to 7, same as 0010: at link level: a LLI link transfer is conditioned by one hit trigger. The LLI data transfer (if any) is not conditioned.</description>
                    <value>0x1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x3</name>
                    <description>at programmed burst level: If SWREQ = 1, each programmed burst read is conditioned by one hit trigger. If SWREQ = 0, each programmed burst that is requested by the selected peripheral, is conditioned by one hit trigger.</description>
                    <value>0x3</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>TRIGSEL</name>
                <description>trigger event input selection
These bits select the trigger event input of the GPDMA transfer (as per Section 16.3.5), with an active trigger event if TRIGPOL[1:0]  00.</description>
                <bitOffset>16</bitOffset>
                <bitWidth>5</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>TRIGPOL</name>
                <description>trigger event polarity
These bits define the polarity of the selected trigger event input defined by TRIGSEL[4:0].</description>
                <bitOffset>24</bitOffset>
                <bitWidth>2</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>no trigger (masked trigger event)</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>trigger on the rising edge</description>
                    <value>0x1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x2</name>
                    <description>trigger on the falling edge</description>
                    <value>0x2</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x3</name>
                    <description>same as 00</description>
                    <value>0x3</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>TCEM</name>
                <description>transfer complete event mode
These bits define the transfer granularity for the transfer complete and half transfer complete events generation.
Note: If the initial LLI&lt;sub&gt;0 &lt;/sub&gt;data transfer is null/void (directly programmed by the internal register file with GPDMA_CxBR1.BNDT[15:0] = 0), then neither the complete transfer event nor the half transfer event is generated.
Note: If the initial LLI&lt;sub&gt;0 &lt;/sub&gt;data transfer is null/void (directly programmed by the internal register file with GPDMA_CxBR1.BNDT[15:0] = 0), then neither the complete transfer event nor the half transfer event is generated.
Note: If the initial LLI&lt;sub&gt;0 &lt;/sub&gt;data transfer is null/void (i.e. directly programmed by the internal register file with GPDMA_CxBR1.BNDT[15:0] =0 ), then the half transfer event is not generated, and the transfer complete event is generated when is completed the loading of the LLI&lt;sub&gt;1&lt;/sub&gt;.</description>
                <bitOffset>30</bitOffset>
                <bitWidth>2</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>at block level (when GPDMA_CxBR1.BNDT[15:0] = 0): the complete (and the half) transfer event is generated at the (respectively half of the) end of a block.</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>channel x (0 to 7, same as 00</description>
                    <value>0x1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x2</name>
                    <description>at LLI level: the complete transfer event is generated at the end of the LLI transfer, including the update of the LLI if any. The half transfer event is generated at the half of the LLI data transfer.</description>
                    <value>0x2</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x3</name>
                    <description>at channel level: the complete transfer event is generated at the end of the last LLI transfer. The half transfer event is generated at the half of the data transfer of the last LLI. The last LLI updates the link address GPDMA_CxLLR.LA[15:2] to zero and clears all the GPDMA_CxLLR update bits (UT1, UT2, UB1, USA, UDA and ULL). If the channel transfer is continuous/infinite, no event is generated.</description>
                    <value>0x3</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
            </fields>
          </register>
          <register>
            <name>GPDMA_C5BR1</name>
            <displayName>GPDMA_C5BR1</displayName>
            <description>GPDMA channel 5 block register 1</description>
            <addressOffset>0x318</addressOffset>
            <size>0x20</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>BNDT</name>
                <description>block number of data bytes to transfer from the source
Block size transferred from the source. When the channel is enabled, this field becomes read-only and is decremented, indicating the remaining number of data items in the current source block to be transferred. BNDT[15:0] is programmed in number of bytes, maximum source block size is 64 Kbytes -1.
Once the last data transfer is completed (BNDT[15:0] = 0):
- if GPDMA_CxLLR.UB1 = 1, this field is updated by the LLI in the memory.
- if GPDMA_CxLLR.UB1 = 0 and if there is at least one non null Uxx update bit, this field is internally restored to the programmed value.
- if all GPDMA_CxLLR.Uxx = 0 and if GPDMA_CxLLR.LA[15:0] = 0, this field is internally restored to the programmed value (infinite/continuous last LLI).
- if GPDMA_CxLLR = 0, this field is kept as zero following the last LLI data transfer.
Note: A non-null source block size must be a multiple of the source data width (BNDT[2:0] versus GPDMA_CxTR1.SDW_LOG2[1:0]). Else a user setting error is reported and no transfer is issued.
Note: When configured in packing mode (GPDMA_CxTR1.PAM[1] = 1 and destination data width different from source data width), a non-null source block size must be a multiple of the destination data width (BNDT[2:0] versus GPDMA_CxTR1.DDW_LOG2[1:0]). Else a user setting error is reported and no transfer is issued.</description>
                <bitOffset>0</bitOffset>
                <bitWidth>16</bitWidth>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>GPDMA_C5SAR</name>
            <displayName>GPDMA_C5SAR</displayName>
            <description>GPDMA channel 5 source address register</description>
            <addressOffset>0x31C</addressOffset>
            <size>0x20</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>SA</name>
                <description>source address
This field is the pointer to the address from which the next data is read.
During the channel activity, depending on the source addressing mode (GPDMA_CxTR1.SINC), this field is kept fixed or incremented by the data width (GPDMA_CxTR1.SDW_LOG2[1:0]) after each burst source data, reflecting the next address from which data is read.
During the channel activity, this address is updated after each completed source burst, consequently to:
the programmed source burst; either in fixed addressing mode or in contiguous-data incremented mode. If contiguously incremented (GPDMA_CxTR1.SINC = 1), then the additional address offset value is the programmed burst size, as defined by GPDMA_CxTR1.SBL_1[5:0] and GPDMA_CxTR1.SDW_LOG2[21:0]
the additional source incremented/decremented offset value as programmed by GPDMA_CxBR1.SDEC
In linked-list mode, after a LLI data transfer is completed, this register is automatically updated by GPDMA from the memory, provided the LLI is set with GPDMA_CxLLR.USA = 1.
Note: A source address must be aligned with the programmed data width of a source burst (SA[2:0] versus GPDMA_CxTR1.SDW_LOG2[1:0]). Else, a user setting error is reported and no transfer is issued.</description>
                <bitOffset>0</bitOffset>
                <bitWidth>32</bitWidth>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>GPDMA_C5DAR</name>
            <displayName>GPDMA_C5DAR</displayName>
            <description>GPDMA channel 5 destination address register</description>
            <addressOffset>0x320</addressOffset>
            <size>0x20</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>DA</name>
                <description>destination address
This field is the pointer to the address from which the next data is written.
During the channel activity, depending on the destination addressing mode (GPDMA_CxTR1.DINC), this field is kept fixed or incremented by the data width (GPDMA_CxTR1.DDW_LOG2[21:0]) after each burst destination data, reflecting the next address from which data is written.
During the channel activity, this address is updated after each completed destination burst, consequently to:
the programmed destination burst; either in fixed addressing mode or in contiguous-data incremented mode. If contiguously incremented (GPDMA_CxTR1.DINC = 1), then the additional address offset value is the programmed burst size, as defined by GPDMA_CxTR1.DBL_1[5:0] and GPDMA_CxTR1.DDW_LOG2[1:0]
the additional destination incremented/decremented offset value as programmed by GPDMA_CxBR1.DDEC.
In linked-list mode, after a LLI data transfer is completed, this register is automatically updated by the GPDMA from the memory, provided the LLI is set with GPDMA_CxLLR.UDA = 1.
Note: A destination address must be aligned with the programmed data width of a destination burst (DA[2:0] versus GPDMA_CxTR1.DDW_LOG2[1:0]). Else, a user setting error is reported and no transfer is issued.</description>
                <bitOffset>0</bitOffset>
                <bitWidth>32</bitWidth>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>GPDMA_C5LLR</name>
            <displayName>GPDMA_C5LLR</displayName>
            <description>GPDMA channel 5 linked-list address register</description>
            <addressOffset>0x34C</addressOffset>
            <size>0x20</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>LA</name>
                <description>pointer (16-bit low-significant address) to the next linked-list data structure
If UT1 = UT2 = UB1 = USA = UDA = ULL = 0 and if LA[15:20] = 0, the current LLI is the last one. The channel transfer is completed without any update of the linked-list GPDMA register file.
Else, this field is the pointer to the memory address offset from which the next linked-list data structure is automatically fetched from, once the data transfer is completed, in order to conditionally update the linked-list GPDMA internal register file (GPDMA_CxCTR1, GPDMA_CxTR2, GPDMA_CxBR1, GPDMA_CxSAR, GPDMA_CxDAR and GPDMA_CxLLR).
Note: The user must program the pointer to be 32-bit aligned. The two low-significant bits are write ignored.</description>
                <bitOffset>2</bitOffset>
                <bitWidth>14</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>ULL</name>
                <description>Update GPDMA_CxLLR register from memory
This bit is used to control the update of GPDMA_CxLLR from the memory during the link transfer.</description>
                <bitOffset>16</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>no GPDMA_CxLLR update</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>GPDMA_CxLLR update</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>UDA</name>
                <description>Update GPDMA_CxDAR register from memory
This bit is used to control the update of GPDMA_CxDAR from the memory during the link transfer.</description>
                <bitOffset>27</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>no GPDMA_CxDAR update</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>GPDMA_CxDAR update</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>USA</name>
                <description>update GPDMA_CxSAR from memory
This bit controls the update of GPDMA_CxSAR from the memory during the link transfer.</description>
                <bitOffset>28</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>no GPDMA_CxSAR update</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>GPDMA_CxSAR update</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>UB1</name>
                <description>Update GPDMA_CxBR1 from memory
This bit controls the update of GPDMA_CxBR1 from the memory during the link transfer. If UB1 = 0 and if GPDMA_CxLLR  0, the linked-list is not completed. GPDMA_CxBR1.BNDT[15:0] is then restored to the programmed value after data transfer is completed and before the link transfer.</description>
                <bitOffset>29</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>no GPDMA_CxBR1 update from memory (GPDMA_CxBR1.BNDT[15:0] restored if any link transfer)</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>GPDMA_CxBR1 update</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>UT2</name>
                <description>Update GPDMA_CxTR2 from memory
This bit controls the update of GPDMA_CxTR2 from the memory during the link transfer.</description>
                <bitOffset>30</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>no GPDMA_CxTR2 update</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>GPDMA_CxTR2 update</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>UT1</name>
                <description>Update GPDMA_CxTR1 from memory
This bit controls the update of GPDMA_CxTR1 from the memory during the link transfer.</description>
                <bitOffset>31</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>no GPDMA_CxTR1 update</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>GPDMA_CxTR1 update</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
            </fields>
          </register>
          <register>
            <name>GPDMA_C6LBAR</name>
            <displayName>GPDMA_C6LBAR</displayName>
            <description>GPDMA channel 6 linked-list base address register</description>
            <addressOffset>0x350</addressOffset>
            <size>0x20</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>LBA</name>
                <description>linked-list base address of GPDMA channel x</description>
                <bitOffset>16</bitOffset>
                <bitWidth>16</bitWidth>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>GPDMA_C6FCR</name>
            <displayName>GPDMA_C6FCR</displayName>
            <description>GPDMA channel 6 flag clear register</description>
            <addressOffset>0x35C</addressOffset>
            <size>0x20</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>TCF</name>
                <description>transfer complete flag clear</description>
                <bitOffset>8</bitOffset>
                <bitWidth>1</bitWidth>
                <access>write-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>no effect</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>corresponding TCF flag cleared</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>HTF</name>
                <description>half transfer flag clear</description>
                <bitOffset>9</bitOffset>
                <bitWidth>1</bitWidth>
                <access>write-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>no effect</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>corresponding HTF flag cleared</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>DTEF</name>
                <description>data transfer error flag clear</description>
                <bitOffset>10</bitOffset>
                <bitWidth>1</bitWidth>
                <access>write-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>no effect</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>corresponding DTEF flag cleared</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>ULEF</name>
                <description>update link transfer error flag clear</description>
                <bitOffset>11</bitOffset>
                <bitWidth>1</bitWidth>
                <access>write-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>no effect</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>corresponding ULEF flag cleared</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>USEF</name>
                <description>user setting error flag clear</description>
                <bitOffset>12</bitOffset>
                <bitWidth>1</bitWidth>
                <access>write-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>no effect</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>corresponding USEF flag cleared</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>SUSPF</name>
                <description>completed suspension flag clear</description>
                <bitOffset>13</bitOffset>
                <bitWidth>1</bitWidth>
                <access>write-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>no effect</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>corresponding SUSPF flag cleared</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>TOF</name>
                <description>trigger overrun flag clear</description>
                <bitOffset>14</bitOffset>
                <bitWidth>1</bitWidth>
                <access>write-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>no effect</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>corresponding TOF flag cleared</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
            </fields>
          </register>
          <register>
            <name>GPDMA_C6SR</name>
            <displayName>GPDMA_C6SR</displayName>
            <description>GPDMA channel 6 status register</description>
            <addressOffset>0x360</addressOffset>
            <size>0x20</size>
            <resetValue>0x00000001</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>IDLEF</name>
                <description>idle flag
This idle flag is deasserted by hardware when the channel is enabled (GPDMA_CxCR.EN = 1) with a valid channel configuration (no USEF to be immediately reported).
This idle flag is asserted after hard reset or by hardware when the channel is back in idle state (in suspended or disabled state).</description>
                <bitOffset>0</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>channel not in idle state</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>channel in idle state</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>TCF</name>
                <description>transfer complete flag
A transfer complete event is either a block transfer complete, or a LLI transfer complete including the upload of the next LLI if any, or the full linked-list completion, depending on the transfer complete event mode (GPDMA_CxTR2.TCEM[1:0]).</description>
                <bitOffset>8</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>no transfer complete event</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>a transfer complete event occurred</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>HTF</name>
                <description>half transfer flag
A half block transfer occurs when half of the bytes of the source block size (rounded up integer of GPDMA_CxBR1.BNDT[15:0]/2) has been transferred to the destination.</description>
                <bitOffset>9</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>no half transfer event</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>a half transfer event occurred</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>DTEF</name>
                <description>data transfer error flag</description>
                <bitOffset>10</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>no data transfer error event</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>a master bus error event occurred on a data transfer</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>ULEF</name>
                <description>update link transfer error flag</description>
                <bitOffset>11</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>no update link transfer error event</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>a master bus error event occurred while updating a linked-list register from memory</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>USEF</name>
                <description>user setting error flag</description>
                <bitOffset>12</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>no user setting error event</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>a user setting error event occurred</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>SUSPF</name>
                <description>completed suspension flag</description>
                <bitOffset>13</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>no completed suspension event</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>a completed suspension event occurred</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>TOF</name>
                <description>trigger overrun flag</description>
                <bitOffset>14</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>no trigger overrun event</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>a trigger overrun event occurred</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>FIFOL</name>
                <description>monitored FIFO level
Number of available write beats in the FIFO, in units of the programmed destination data width (see GPDMA_CxTR1.DDW_LOG2[1:0], in units of bytes, half-words, or words).
Note: After having suspended an active transfer, the user may need to read FIFOL[7:0], additionally to GPDMA_CxBR1.BDNT[15:0] to know how many data have been transferred to the destination. Before reading, the user may wait for the transfer to be suspended (GPDMA_CxSR.SUSPF = 1).</description>
                <bitOffset>16</bitOffset>
                <bitWidth>8</bitWidth>
                <access>read-only</access>
              </field>
            </fields>
          </register>
          <register>
            <name>GPDMA_C6CR</name>
            <displayName>GPDMA_C6CR</displayName>
            <description>GPDMA channel 6 control register</description>
            <addressOffset>0x364</addressOffset>
            <size>0x20</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>EN</name>
                <description>enable
Writing 1 into the field RESET (bit 1) causes the hardware to de-assert this bit, whatever is written into this bit 0. Else: 
this bit is deasserted by hardware when there is a transfer error (master bus error or user setting error) or when there is a channel transfer complete (channel ready to be configured, for example if LSM=1 at the end of a single execution of the LLI).
Else, this bit can be asserted by software. 
Writing 0 into this EN bit is ignored.</description>
                <bitOffset>0</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>write: ignored, read: channel disabled</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>write: enable channel, read: channel enabled</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>RESET</name>
                <description>reset
This bit is write only. Writing 0 has no impact. Writing 1 implies the reset of the following: the FIFO, the channel internal state, SUSP and EN bits (whatever is written receptively in bit 2 and bit 0).
The reset is effective when the channel is in steady state, meaning one of the following:
- active channel in suspended state (GPDMA_CxSR.SUSPF = 1 and GPDMA_CxSR.IDLEF = GPDMA_CxCR.EN = 1)
- channel in disabled state (GPDMA_CxSR.IDLEF = 1 and GPDMA_CxCR.EN = 0).
After writing a RESET, to continue using this channel, the user must explicitly reconfigure the channel including the hardware-modified configuration registers (GPDMA_CxBR1, GPDMA_CxSAR and GPDMA_CxDAR) before enabling again the channel (see the programming sequence in Figure 44).</description>
                <bitOffset>1</bitOffset>
                <bitWidth>1</bitWidth>
                <access>write-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>no channel reset</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>channel reset</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>SUSP</name>
                <description>suspend
Writing 1 into the field RESET (bit 1) causes the hardware to de-assert this bit, whatever is written into this bit 2. Else:
Software must write 1 in order to suspend an active channel (channel with an ongoing GPDMA transfer over its master ports). 
The software must write 0 in order to resume a suspended channel, following the programming sequence detailed in Figure 43.</description>
                <bitOffset>2</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>write: resume channel, read: channel not suspended</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>write: suspend channel, read: channel suspended.</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>TCIE</name>
                <description>transfer complete interrupt enable</description>
                <bitOffset>8</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>interrupt disabled</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>interrupt enabled</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>HTIE</name>
                <description>half transfer complete interrupt enable</description>
                <bitOffset>9</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>interrupt disabled</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>interrupt enabled</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>DTEIE</name>
                <description>data transfer error interrupt enable</description>
                <bitOffset>10</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>interrupt disabled</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>interrupt enabled</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>ULEIE</name>
                <description>update link transfer error interrupt enable</description>
                <bitOffset>11</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>interrupt disabled</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>interrupt enabled</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>USEIE</name>
                <description>user setting error interrupt enable</description>
                <bitOffset>12</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>interrupt disabled</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>interrupt enabled</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>SUSPIE</name>
                <description>completed suspension interrupt enable</description>
                <bitOffset>13</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>interrupt disabled</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>interrupt enabled</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>TOIE</name>
                <description>trigger overrun interrupt enable</description>
                <bitOffset>14</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>interrupt disabled</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>interrupt enabled</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>LSM</name>
                <description>Link step mode
First the (possible 1D/repeated) block transfer is executed as defined by the current internal register file until GPDMA_CxBR1.BNDT[15:0] = 0. Secondly the next linked-list data structure is conditionally uploaded from memory as defined by GPDMA_CxLLR. Then channel execution is completed.
Note: This bit must be written when EN=0. This bit is read-only when EN=1.</description>
                <bitOffset>16</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>channel executed for the full linked-list and completed at the end of the last LLI (GPDMA_CxLLR = 0). The 16 low-significant bits of the link address are null (LA[15:0] = 0) and all the update bits are null (UT1 =UB1 = UT2 = USA = UDA = ULL = 0). Then GPDMA_CxBR1.BNDT[15:0] = 0.</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>channel executed once for the current LLI</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>LAP</name>
                <description>linked-list allocated port
This bit is used to allocate the master port for the update of the GPDMA linked-list registers from the memory.
Note: This bit must be written when EN=0. This bit is read-only when EN=1.</description>
                <bitOffset>17</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>port 0 (AHB) allocated</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>port 1 (AHB) allocated</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>PRIO</name>
                <description>priority level of the channel x GPDMA transfer versus others
Note: This bit must be written when EN = 0. This bit is read-only when EN = 1.</description>
                <bitOffset>22</bitOffset>
                <bitWidth>2</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>low priority, low weight</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>low priority, mid weight</description>
                    <value>0x1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x2</name>
                    <description>low priority, high weight</description>
                    <value>0x2</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x3</name>
                    <description>high priority</description>
                    <value>0x3</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
            </fields>
          </register>
          <register>
            <name>GPDMA_C6TR1</name>
            <displayName>GPDMA_C6TR1</displayName>
            <description>GPDMA channel 6 transfer register 1</description>
            <addressOffset>0x390</addressOffset>
            <size>0x20</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>SDW_LOG2</name>
                <description>binary logarithm of the source data width of a burst in bytes
Setting a 8-byte data width causes a user setting error to be reported and no transfer is issued.
A source block size must be a multiple of the source data width (GPDMA_CxBR1.BNDT[2:0] versus SDW_LOG2[1:0]). Otherwise, a user setting error is reported and no transfer is issued.
Note: A source burst transfer must have an aligned address with its data width (start address GPDMA_CxSAR[2:0] versus SDW_LOG2[1:0]). Otherwise, a user setting error is reported and none transfer is issued.</description>
                <bitOffset>0</bitOffset>
                <bitWidth>2</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>byte</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>half-word (2 bytes)</description>
                    <value>0x1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x2</name>
                    <description>word (4 bytes)</description>
                    <value>0x2</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x3</name>
                    <description>user setting error reported and no transfer issued</description>
                    <value>0x3</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>SINC</name>
                <description>source incrementing burst
The source address, pointed by GPDMA_CxSAR, is kept constant after a burst beat/single transfer or is incremented by the offset value corresponding to a contiguous data after a burst beat/single transfer.</description>
                <bitOffset>3</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>fixed burst</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>contiguously incremented burst</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>SBL_1</name>
                <description>source burst length minus 1, between 0 and 63
The burst length unit is one data named beat within a burst. If SBL_1[5:0] =0 , the burst can be named as single. Each data/beat has a width defined by the destination data width SDW_LOG2[1:0].
Note: If a burst transfer crossed a 1-Kbyte address boundary on a AHB transfer, the GPDMA modifies and shortens the programmed burst into singles or bursts of lower length, to be compliant with the AHB protocol.
Note: If a burst transfer is of length greater than the FIFO size of the channel x, the GPDMA modifies and shortens the programmed burst into singles or bursts of lower length, to be compliant with the FIFO size. Transfer performance is lower, with GPDMA re-arbitration between effective and lower singles/bursts, but the data integrity is guaranteed.</description>
                <bitOffset>4</bitOffset>
                <bitWidth>6</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>PAM</name>
                <description>padding/alignment mode
If DDW_LOG2[1:0] = SDW_LOG2[1:0]: if the data width of a burst destination transfer is equal to the data width of a burst source transfer, these bits are ignored.
Else, in the following enumerated values, the condition PAM_1 is when destination data width is higher that source data width, and the condition PAM_2 is when destination data width is higher than source data width.
1x: successive source data are FIFO queued and packed at the destination data width, in a left (LSB) to right (MSB) order (named little endian), before a destination transfer
Note: 1x: source data is FIFO queued and unpacked at the destination data width, to be transferred in a left (LSB) to right (MSB) order (named little endian) to the destination</description>
                <bitOffset>11</bitOffset>
                <bitWidth>2</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0_PAM_1</name>
                    <description>source data is transferred as right aligned, padded with 0s up to the destination data width</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1_PAM_1</name>
                    <description>source data is transferred as right aligned, sign extended up to the destination data width</description>
                    <value>0x1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x0_PAM_2</name>
                    <description>source data is transferred as right aligned, left-truncated down to the destination data width</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1_PAM_2</name>
                    <description>source data is transferred as left-aligned, right-truncated down to the destination data width</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>SBX</name>
                <description>source byte exchange within the unaligned half-word of each source word 
If the source data width is shorter than a word, this bit is ignored.
If the source data width is a word:</description>
                <bitOffset>13</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>no byte-based exchange within the unaligned half-word of each source word</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>the two consecutive bytes within the unaligned half-word of each source word are exchanged.</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>SAP</name>
                <description>source allocated port
This bit is used to allocate the master port for the source transfer
Note: This bit must be written when EN = 0. This bit is read-only when EN = 1.</description>
                <bitOffset>14</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>port 0 (AHB) allocated</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>port 1 (AHB) allocated</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>SSEC</name>
                <description>security attribute of the GPDMA transfer from the source
If GPDMA_SECCFGR.SECx = 1 and the access is secure:
This is a secure register bit. This bit can only be read by a secure software. This bit must be written by a secure software when GPDMA_SECCFGR.SECx =1 . A secure write is ignored when GPDMA_SECCFGR.SECx = 0.
When GPDMA_SECCFGR.SECx is deasserted, this SSEC bit is also deasserted by hardware (on a secure reconfiguration of the channel as non-secure), and the GPDMA transfer from the source is non-secure.</description>
                <bitOffset>15</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>GPDMA transfer non-secure</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>GPDMA transfer secure</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>DDW_LOG2</name>
                <description>binary logarithm of the destination data width of a burst, in bytes
Setting a 8-byte data width causes a user setting error to be reported and none transfer is issued.
Note: A destination burst transfer must have an aligned address with its data width (start address GPDMA_CxDAR[2:0] versus DDW_LOG2[1:0]). Otherwise a user setting error is reported and no transfer is issued.</description>
                <bitOffset>16</bitOffset>
                <bitWidth>2</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>byte</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>half-word (2 bytes)</description>
                    <value>0x1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x2</name>
                    <description>word (4 bytes)</description>
                    <value>0x2</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x3</name>
                    <description>user setting error reported and no transfer issued</description>
                    <value>0x3</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>DINC</name>
                <description>destination incrementing burst
The destination address, pointed by GPDMA_CxDAR, is kept constant after a burst beat/single transfer, or is incremented by the offset value corresponding to a contiguous data after a burst beat/single transfer.</description>
                <bitOffset>19</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>fixed burst</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>contiguously incremented burst</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>DBL_1</name>
                <description>destination burst length minus 1, between 0 and 63
The burst length unit is one data named beat within a burst. If DBL_1[5:0] =0 , the burst can be named as single. Each data/beat has a width defined by the destination data width DDW_LOG2[1:0].
Note: If a burst transfer crossed a 1-Kbyte address boundary on a AHB transfer, the GPDMA modifies and shortens the programmed burst into singles or bursts of lower length, to be compliant with the AHB protocol.
Note: If a burst transfer is of length greater than the FIFO size of the channel x, the GPDMA modifies and shortens the programmed burst into singles or bursts of lower length, to be compliant with the FIFO size. Transfer performance is lower, with GPDMA re-arbitration between effective and lower singles/bursts, but the data integrity is guaranteed.</description>
                <bitOffset>20</bitOffset>
                <bitWidth>6</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>DBX</name>
                <description>destination byte exchange
If the destination data size is a byte, this bit is ignored.
If the destination data size is not a byte:</description>
                <bitOffset>26</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>no byte-based exchange within half-word</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>the two consecutive (post PAM) bytes are exchanged in each destination half-word.</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>DHX</name>
                <description>destination half-word exchange
If the destination data size is shorter than a word, this bit is ignored.
If the destination data size is a word:</description>
                <bitOffset>27</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>no halfword-based exchanged within word</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>the two consecutive (post PAM) half-words are exchanged in each destination word.</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>DAP</name>
                <description>destination allocated port
This bit is used to allocate the master port for the destination transfer
Note: This bit must be written when EN = 0. This bit is read-only when EN = 1.</description>
                <bitOffset>30</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>port 0 (AHB) allocated</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>port 1 (AHB) allocated</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>DSEC</name>
                <description>security attribute of the GPDMA transfer to the destination
If GPDMA_SECCFGR.SECx = 1 and the access is secure:
This is a secure register bit. This bit can only be read by a secure software. This bit must be written by a secure software when GPDMA_SECCFGR.SECx = 1. A secure write is ignored when GPDMA_SECCFGR.SECx = 0.
When GPDMA_SECCFGR.SECx is deasserted, this DSEC bit is also deasserted by hardware (on a secure reconfiguration of the channel as non-secure), and the GPDMA transfer to the destination is non-secure.</description>
                <bitOffset>31</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>GPDMA transfer non-secure</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>GPDMA transfer secure</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
            </fields>
          </register>
          <register>
            <name>GPDMA_C6TR2</name>
            <displayName>GPDMA_C6TR2</displayName>
            <description>GPDMA channel 6 transfer register 2</description>
            <addressOffset>0x394</addressOffset>
            <size>0x20</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>REQSEL</name>
                <description>GPDMA hardware request selection
These bits are ignored if channel x is activated (GPDMA_CxCR.EN asserted) with SWREQ = 1 (software request for a memory-to-memory transfer). Else, the selected hardware request is internally taken into account as per Section 16.3.3.
The user must not assign a same input hardware request (same REQSEL[5:0] value) to different active GPDMA channels (GPDMA_CxCR.EN = 1 and GPDMA_CxTR2.SWREQ = 0 for these channels). GPDMA is not intended to hardware support the case of simultaneous enabled channels incorrectly configured with a same hardware peripheral request signal, and there is no user setting error reporting.</description>
                <bitOffset>0</bitOffset>
                <bitWidth>6</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>SWREQ</name>
                <description>software request
This bit is internally taken into account when GPDMA_CxCR.EN is asserted.</description>
                <bitOffset>9</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>no software request. The selected hardware request REQSEL[5:0] is taken into account.</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>software request for a memory-to-memory transfer. The default selected hardware request as per REQSEL[5:0] is ignored.</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>DREQ</name>
                <description>destination hardware request
This bit is ignored if channel x is activated (GPDMA_CxCR.EN asserted) with SWREQ = 1 (software request for a memory-to-memory transfer). Else:</description>
                <bitOffset>10</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>selected hardware request driven by a source peripheral (request signal taken into account by the GPDMA transfer scheduler over the source/read port)</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>selected hardware request driven by a destination peripheral (request signal taken into account by the GPDMA transfer scheduler over the destination/write port)</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>BREQ</name>
                <description>Block hardware request
If the channel x is activated (GPDMA_CxCR.EN asserted) with SWREQ = 1 (software request for a memory-to-memory transfer), this bit is ignored. Else:</description>
                <bitOffset>11</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>the selected hardware request is driven by a peripheral with a hardware request/acknowledge protocol at a burst level.</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>the selected hardware request is driven by a peripheral with a hardware request/acknowledge protocol at a block level (see Section 16.3.3).</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>TRIGM</name>
                <description>trigger mode
These bits define the transfer granularity for its conditioning by the trigger.
If the channel x is enabled (GPDMA_CxCR.EN asserted) with TRIGPOL[1:0] = 00 or 11, these TRIGM[1:0] bits are ignored.
Else, a GPDMA transfer is conditioned by at least one trigger hit: 
 If the peripheral is programmed as a source (DREQ = 0) of the LLI data transfer, each programmed burst read is conditioned.
 If the peripheral is programmed as a destination (DREQ = 1) of the LLI data transfer, each programmed burst write is conditioned. The first memory burst read of a block, also named as the first ready FIFO-based source burst, is gated by the occurrence of both the hardware request and the first trigger hit.
The GPDMA monitoring of a trigger for channel x is started when the channel is enabled/loaded with a new active trigger configuration: rising or falling edge on a selected trigger (TRIGPOL[1:0] = 01 or respectively TRIGPOL[1:0] = 10).
The monitoring of this trigger is kept active during the triggered and uncompleted (data or link) transfer; and if a new trigger is detected then, this hit is internally memorized to grant the next transfer, as long as the defined rising or falling edge is not modified, and the TRIGSEL[4:0] is not modified, and the channel is enabled.
Transferring a next LLI&lt;sub&gt;n+1&lt;/sub&gt; that updates the GPDMA_CxTR2 with a new value for any of TRIGSEL[4:0] or TRIGPOL[1:0], resets the monitoring, trashing the memorized hit of the formerly defined LLI&lt;sub&gt;n &lt;/sub&gt;trigger.
After a first new trigger hit&lt;sub&gt;n+1&lt;/sub&gt; is memorized, if another second trigger hit&lt;sub&gt;n+2&lt;/sub&gt; is detected and if the hit&lt;sub&gt;n&lt;/sub&gt; triggered transfer is still not completed, hit&lt;sub&gt;n+2 &lt;/sub&gt;is lost and not memorized.memorized. A trigger overrun flag is reported (GPDMA_CxSR.TOF =1 ), and an interrupt is generated if enabled (GPDMA_CxCR.TOIE = 1). The channel is not automatically disabled by hardware due to a trigger overrun. 
Note: When the source block size is not a multiple of the source burst size and is a multiple of the source data width, then the last programmed source burst is not completed and is internally shorten to match the block size. In this case, if TRIGM[1:0] = 11 and (SWREQ =1  or (SWREQ = 0 and DREQ =0 )), the shortened burst transfer (by singles or/and by bursts of lower length) is conditioned once by the trigger.
Note: When the programmed destination burst is internally shortened by singles or/and by bursts of lower length (versus FIFO size, versus block size, 1-Kbyte boundary address crossing): if the trigger is conditioning the programmed destination burst (if TRIGM[1:0] = 11 and SWREQ = 0 and DREQ = 1), this shortened destination burst transfer is conditioned once by the trigger.</description>
                <bitOffset>14</bitOffset>
                <bitWidth>2</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>at block level: the first burst read of each block transfer is conditioned by one hit trigger .</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>channel x = 0 to 7, same as 0010: at link level: a LLI link transfer is conditioned by one hit trigger. The LLI data transfer (if any) is not conditioned.</description>
                    <value>0x1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x3</name>
                    <description>at programmed burst level: If SWREQ = 1, each programmed burst read is conditioned by one hit trigger. If SWREQ = 0, each programmed burst that is requested by the selected peripheral, is conditioned by one hit trigger.</description>
                    <value>0x3</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>TRIGSEL</name>
                <description>trigger event input selection
These bits select the trigger event input of the GPDMA transfer (as per Section 16.3.5), with an active trigger event if TRIGPOL[1:0]  00.</description>
                <bitOffset>16</bitOffset>
                <bitWidth>5</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>TRIGPOL</name>
                <description>trigger event polarity
These bits define the polarity of the selected trigger event input defined by TRIGSEL[4:0].</description>
                <bitOffset>24</bitOffset>
                <bitWidth>2</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>no trigger (masked trigger event)</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>trigger on the rising edge</description>
                    <value>0x1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x2</name>
                    <description>trigger on the falling edge</description>
                    <value>0x2</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x3</name>
                    <description>same as 00</description>
                    <value>0x3</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>TCEM</name>
                <description>transfer complete event mode
These bits define the transfer granularity for the transfer complete and half transfer complete events generation.
Note: If the initial LLI&lt;sub&gt;0 &lt;/sub&gt;data transfer is null/void (directly programmed by the internal register file with GPDMA_CxBR1.BNDT[15:0] = 0), then neither the complete transfer event nor the half transfer event is generated.
Note: If the initial LLI&lt;sub&gt;0 &lt;/sub&gt;data transfer is null/void (directly programmed by the internal register file with GPDMA_CxBR1.BNDT[15:0] = 0), then neither the complete transfer event nor the half transfer event is generated.
Note: If the initial LLI&lt;sub&gt;0 &lt;/sub&gt;data transfer is null/void (i.e. directly programmed by the internal register file with GPDMA_CxBR1.BNDT[15:0] =0 ), then the half transfer event is not generated, and the transfer complete event is generated when is completed the loading of the LLI&lt;sub&gt;1&lt;/sub&gt;.</description>
                <bitOffset>30</bitOffset>
                <bitWidth>2</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>at block level (when GPDMA_CxBR1.BNDT[15:0] = 0): the complete (and the half) transfer event is generated at the (respectively half of the) end of a block.</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>channel x (0 to 7, same as 00</description>
                    <value>0x1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x2</name>
                    <description>at LLI level: the complete transfer event is generated at the end of the LLI transfer, including the update of the LLI if any. The half transfer event is generated at the half of the LLI data transfer.</description>
                    <value>0x2</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x3</name>
                    <description>at channel level: the complete transfer event is generated at the end of the last LLI transfer. The half transfer event is generated at the half of the data transfer of the last LLI. The last LLI updates the link address GPDMA_CxLLR.LA[15:2] to zero and clears all the GPDMA_CxLLR update bits (UT1, UT2, UB1, USA, UDA and ULL). If the channel transfer is continuous/infinite, no event is generated.</description>
                    <value>0x3</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
            </fields>
          </register>
          <register>
            <name>GPDMA_C6BR1</name>
            <displayName>GPDMA_C6BR1</displayName>
            <description>GPDMA channel 6 block register 1</description>
            <addressOffset>0x398</addressOffset>
            <size>0x20</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>BNDT</name>
                <description>block number of data bytes to transfer from the source
Block size transferred from the source. When the channel is enabled, this field becomes read-only and is decremented, indicating the remaining number of data items in the current source block to be transferred. BNDT[15:0] is programmed in number of bytes, maximum source block size is 64 Kbytes -1.
Once the last data transfer is completed (BNDT[15:0] = 0):
- if GPDMA_CxLLR.UB1 = 1, this field is updated by the LLI in the memory.
- if GPDMA_CxLLR.UB1 = 0 and if there is at least one non null Uxx update bit, this field is internally restored to the programmed value.
- if all GPDMA_CxLLR.Uxx = 0 and if GPDMA_CxLLR.LA[15:0] = 0, this field is internally restored to the programmed value (infinite/continuous last LLI).
- if GPDMA_CxLLR = 0, this field is kept as zero following the last LLI data transfer.
Note: A non-null source block size must be a multiple of the source data width (BNDT[2:0] versus GPDMA_CxTR1.SDW_LOG2[1:0]). Else a user setting error is reported and no transfer is issued.
Note: When configured in packing mode (GPDMA_CxTR1.PAM[1] = 1 and destination data width different from source data width), a non-null source block size must be a multiple of the destination data width (BNDT[2:0] versus GPDMA_CxTR1.DDW_LOG2[1:0]). Else a user setting error is reported and no transfer is issued.</description>
                <bitOffset>0</bitOffset>
                <bitWidth>16</bitWidth>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>GPDMA_C6SAR</name>
            <displayName>GPDMA_C6SAR</displayName>
            <description>GPDMA channel 6 source address register</description>
            <addressOffset>0x39C</addressOffset>
            <size>0x20</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>SA</name>
                <description>source address
This field is the pointer to the address from which the next data is read.
During the channel activity, depending on the source addressing mode (GPDMA_CxTR1.SINC), this field is kept fixed or incremented by the data width (GPDMA_CxTR1.SDW_LOG2[1:0]) after each burst source data, reflecting the next address from which data is read.
During the channel activity, this address is updated after each completed source burst, consequently to:
the programmed source burst; either in fixed addressing mode or in contiguous-data incremented mode. If contiguously incremented (GPDMA_CxTR1.SINC = 1), then the additional address offset value is the programmed burst size, as defined by GPDMA_CxTR1.SBL_1[5:0] and GPDMA_CxTR1.SDW_LOG2[21:0]
the additional source incremented/decremented offset value as programmed by GPDMA_CxBR1.SDEC
In linked-list mode, after a LLI data transfer is completed, this register is automatically updated by GPDMA from the memory, provided the LLI is set with GPDMA_CxLLR.USA = 1.
Note: A source address must be aligned with the programmed data width of a source burst (SA[2:0] versus GPDMA_CxTR1.SDW_LOG2[1:0]). Else, a user setting error is reported and no transfer is issued.</description>
                <bitOffset>0</bitOffset>
                <bitWidth>32</bitWidth>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>GPDMA_C6DAR</name>
            <displayName>GPDMA_C6DAR</displayName>
            <description>GPDMA channel 6 destination address register</description>
            <addressOffset>0x3A0</addressOffset>
            <size>0x20</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>DA</name>
                <description>destination address
This field is the pointer to the address from which the next data is written.
During the channel activity, depending on the destination addressing mode (GPDMA_CxTR1.DINC), this field is kept fixed or incremented by the data width (GPDMA_CxTR1.DDW_LOG2[21:0]) after each burst destination data, reflecting the next address from which data is written.
During the channel activity, this address is updated after each completed destination burst, consequently to:
the programmed destination burst; either in fixed addressing mode or in contiguous-data incremented mode. If contiguously incremented (GPDMA_CxTR1.DINC = 1), then the additional address offset value is the programmed burst size, as defined by GPDMA_CxTR1.DBL_1[5:0] and GPDMA_CxTR1.DDW_LOG2[1:0]
the additional destination incremented/decremented offset value as programmed by GPDMA_CxBR1.DDEC.
In linked-list mode, after a LLI data transfer is completed, this register is automatically updated by the GPDMA from the memory, provided the LLI is set with GPDMA_CxLLR.UDA = 1.
Note: A destination address must be aligned with the programmed data width of a destination burst (DA[2:0] versus GPDMA_CxTR1.DDW_LOG2[1:0]). Else, a user setting error is reported and no transfer is issued.</description>
                <bitOffset>0</bitOffset>
                <bitWidth>32</bitWidth>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>GPDMA_C6LLR</name>
            <displayName>GPDMA_C6LLR</displayName>
            <description>GPDMA channel 6 linked-list address register</description>
            <addressOffset>0x3CC</addressOffset>
            <size>0x20</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>LA</name>
                <description>pointer (16-bit low-significant address) to the next linked-list data structure
If UT1 = UT2 = UB1 = USA = UDA = ULL = 0 and if LA[15:20] = 0, the current LLI is the last one. The channel transfer is completed without any update of the linked-list GPDMA register file.
Else, this field is the pointer to the memory address offset from which the next linked-list data structure is automatically fetched from, once the data transfer is completed, in order to conditionally update the linked-list GPDMA internal register file (GPDMA_CxCTR1, GPDMA_CxTR2, GPDMA_CxBR1, GPDMA_CxSAR, GPDMA_CxDAR and GPDMA_CxLLR).
Note: The user must program the pointer to be 32-bit aligned. The two low-significant bits are write ignored.</description>
                <bitOffset>2</bitOffset>
                <bitWidth>14</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>ULL</name>
                <description>Update GPDMA_CxLLR register from memory
This bit is used to control the update of GPDMA_CxLLR from the memory during the link transfer.</description>
                <bitOffset>16</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>no GPDMA_CxLLR update</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>GPDMA_CxLLR update</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>UDA</name>
                <description>Update GPDMA_CxDAR register from memory
This bit is used to control the update of GPDMA_CxDAR from the memory during the link transfer.</description>
                <bitOffset>27</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>no GPDMA_CxDAR update</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>GPDMA_CxDAR update</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>USA</name>
                <description>update GPDMA_CxSAR from memory
This bit controls the update of GPDMA_CxSAR from the memory during the link transfer.</description>
                <bitOffset>28</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>no GPDMA_CxSAR update</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>GPDMA_CxSAR update</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>UB1</name>
                <description>Update GPDMA_CxBR1 from memory
This bit controls the update of GPDMA_CxBR1 from the memory during the link transfer. If UB1 = 0 and if GPDMA_CxLLR  0, the linked-list is not completed. GPDMA_CxBR1.BNDT[15:0] is then restored to the programmed value after data transfer is completed and before the link transfer.</description>
                <bitOffset>29</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>no GPDMA_CxBR1 update from memory (GPDMA_CxBR1.BNDT[15:0] restored if any link transfer)</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>GPDMA_CxBR1 update</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>UT2</name>
                <description>Update GPDMA_CxTR2 from memory
This bit controls the update of GPDMA_CxTR2 from the memory during the link transfer.</description>
                <bitOffset>30</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>no GPDMA_CxTR2 update</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>GPDMA_CxTR2 update</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>UT1</name>
                <description>Update GPDMA_CxTR1 from memory
This bit controls the update of GPDMA_CxTR1 from the memory during the link transfer.</description>
                <bitOffset>31</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>no GPDMA_CxTR1 update</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>GPDMA_CxTR1 update</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
            </fields>
          </register>
          <register>
            <name>GPDMA_C7LBAR</name>
            <displayName>GPDMA_C7LBAR</displayName>
            <description>GPDMA channel 7 linked-list base address register</description>
            <addressOffset>0x3D0</addressOffset>
            <size>0x20</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>LBA</name>
                <description>linked-list base address of GPDMA channel x</description>
                <bitOffset>16</bitOffset>
                <bitWidth>16</bitWidth>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>GPDMA_C7FCR</name>
            <displayName>GPDMA_C7FCR</displayName>
            <description>GPDMA channel 7 flag clear register</description>
            <addressOffset>0x3DC</addressOffset>
            <size>0x20</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>TCF</name>
                <description>transfer complete flag clear</description>
                <bitOffset>8</bitOffset>
                <bitWidth>1</bitWidth>
                <access>write-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>no effect</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>corresponding TCF flag cleared</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>HTF</name>
                <description>half transfer flag clear</description>
                <bitOffset>9</bitOffset>
                <bitWidth>1</bitWidth>
                <access>write-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>no effect</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>corresponding HTF flag cleared</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>DTEF</name>
                <description>data transfer error flag clear</description>
                <bitOffset>10</bitOffset>
                <bitWidth>1</bitWidth>
                <access>write-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>no effect</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>corresponding DTEF flag cleared</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>ULEF</name>
                <description>update link transfer error flag clear</description>
                <bitOffset>11</bitOffset>
                <bitWidth>1</bitWidth>
                <access>write-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>no effect</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>corresponding ULEF flag cleared</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>USEF</name>
                <description>user setting error flag clear</description>
                <bitOffset>12</bitOffset>
                <bitWidth>1</bitWidth>
                <access>write-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>no effect</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>corresponding USEF flag cleared</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>SUSPF</name>
                <description>completed suspension flag clear</description>
                <bitOffset>13</bitOffset>
                <bitWidth>1</bitWidth>
                <access>write-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>no effect</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>corresponding SUSPF flag cleared</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>TOF</name>
                <description>trigger overrun flag clear</description>
                <bitOffset>14</bitOffset>
                <bitWidth>1</bitWidth>
                <access>write-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>no effect</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>corresponding TOF flag cleared</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
            </fields>
          </register>
          <register>
            <name>GPDMA_C7SR</name>
            <displayName>GPDMA_C7SR</displayName>
            <description>GPDMA channel 7 status register</description>
            <addressOffset>0x3E0</addressOffset>
            <size>0x20</size>
            <resetValue>0x00000001</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>IDLEF</name>
                <description>idle flag
This idle flag is deasserted by hardware when the channel is enabled (GPDMA_CxCR.EN = 1) with a valid channel configuration (no USEF to be immediately reported).
This idle flag is asserted after hard reset or by hardware when the channel is back in idle state (in suspended or disabled state).</description>
                <bitOffset>0</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>channel not in idle state</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>channel in idle state</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>TCF</name>
                <description>transfer complete flag
A transfer complete event is either a block transfer complete, or a LLI transfer complete including the upload of the next LLI if any, or the full linked-list completion, depending on the transfer complete event mode (GPDMA_CxTR2.TCEM[1:0]).</description>
                <bitOffset>8</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>no transfer complete event</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>a transfer complete event occurred</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>HTF</name>
                <description>half transfer flag
A half block transfer occurs when half of the bytes of the source block size (rounded up integer of GPDMA_CxBR1.BNDT[15:0]/2) has been transferred to the destination.</description>
                <bitOffset>9</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>no half transfer event</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>a half transfer event occurred</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>DTEF</name>
                <description>data transfer error flag</description>
                <bitOffset>10</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>no data transfer error event</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>a master bus error event occurred on a data transfer</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>ULEF</name>
                <description>update link transfer error flag</description>
                <bitOffset>11</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>no update link transfer error event</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>a master bus error event occurred while updating a linked-list register from memory</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>USEF</name>
                <description>user setting error flag</description>
                <bitOffset>12</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>no user setting error event</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>a user setting error event occurred</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>SUSPF</name>
                <description>completed suspension flag</description>
                <bitOffset>13</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>no completed suspension event</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>a completed suspension event occurred</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>TOF</name>
                <description>trigger overrun flag</description>
                <bitOffset>14</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>no trigger overrun event</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>a trigger overrun event occurred</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>FIFOL</name>
                <description>monitored FIFO level
Number of available write beats in the FIFO, in units of the programmed destination data width (see GPDMA_CxTR1.DDW_LOG2[1:0], in units of bytes, half-words, or words).
Note: After having suspended an active transfer, the user may need to read FIFOL[7:0], additionally to GPDMA_CxBR1.BDNT[15:0] to know how many data have been transferred to the destination. Before reading, the user may wait for the transfer to be suspended (GPDMA_CxSR.SUSPF = 1).</description>
                <bitOffset>16</bitOffset>
                <bitWidth>8</bitWidth>
                <access>read-only</access>
              </field>
            </fields>
          </register>
          <register>
            <name>GPDMA_C7CR</name>
            <displayName>GPDMA_C7CR</displayName>
            <description>GPDMA channel 7 control register</description>
            <addressOffset>0x3E4</addressOffset>
            <size>0x20</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>EN</name>
                <description>enable
Writing 1 into the field RESET (bit 1) causes the hardware to de-assert this bit, whatever is written into this bit 0. Else: 
this bit is deasserted by hardware when there is a transfer error (master bus error or user setting error) or when there is a channel transfer complete (channel ready to be configured, for example if LSM=1 at the end of a single execution of the LLI).
Else, this bit can be asserted by software. 
Writing 0 into this EN bit is ignored.</description>
                <bitOffset>0</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>write: ignored, read: channel disabled</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>write: enable channel, read: channel enabled</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>RESET</name>
                <description>reset
This bit is write only. Writing 0 has no impact. Writing 1 implies the reset of the following: the FIFO, the channel internal state, SUSP and EN bits (whatever is written receptively in bit 2 and bit 0).
The reset is effective when the channel is in steady state, meaning one of the following:
- active channel in suspended state (GPDMA_CxSR.SUSPF = 1 and GPDMA_CxSR.IDLEF = GPDMA_CxCR.EN = 1)
- channel in disabled state (GPDMA_CxSR.IDLEF = 1 and GPDMA_CxCR.EN = 0).
After writing a RESET, to continue using this channel, the user must explicitly reconfigure the channel including the hardware-modified configuration registers (GPDMA_CxBR1, GPDMA_CxSAR and GPDMA_CxDAR) before enabling again the channel (see the programming sequence in Figure 44).</description>
                <bitOffset>1</bitOffset>
                <bitWidth>1</bitWidth>
                <access>write-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>no channel reset</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>channel reset</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>SUSP</name>
                <description>suspend
Writing 1 into the field RESET (bit 1) causes the hardware to de-assert this bit, whatever is written into this bit 2. Else:
Software must write 1 in order to suspend an active channel (channel with an ongoing GPDMA transfer over its master ports). 
The software must write 0 in order to resume a suspended channel, following the programming sequence detailed in Figure 43.</description>
                <bitOffset>2</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>write: resume channel, read: channel not suspended</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>write: suspend channel, read: channel suspended.</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>TCIE</name>
                <description>transfer complete interrupt enable</description>
                <bitOffset>8</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>interrupt disabled</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>interrupt enabled</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>HTIE</name>
                <description>half transfer complete interrupt enable</description>
                <bitOffset>9</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>interrupt disabled</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>interrupt enabled</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>DTEIE</name>
                <description>data transfer error interrupt enable</description>
                <bitOffset>10</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>interrupt disabled</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>interrupt enabled</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>ULEIE</name>
                <description>update link transfer error interrupt enable</description>
                <bitOffset>11</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>interrupt disabled</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>interrupt enabled</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>USEIE</name>
                <description>user setting error interrupt enable</description>
                <bitOffset>12</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>interrupt disabled</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>interrupt enabled</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>SUSPIE</name>
                <description>completed suspension interrupt enable</description>
                <bitOffset>13</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>interrupt disabled</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>interrupt enabled</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>TOIE</name>
                <description>trigger overrun interrupt enable</description>
                <bitOffset>14</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>interrupt disabled</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>interrupt enabled</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>LSM</name>
                <description>Link step mode
First the (possible 1D/repeated) block transfer is executed as defined by the current internal register file until GPDMA_CxBR1.BNDT[15:0] = 0. Secondly the next linked-list data structure is conditionally uploaded from memory as defined by GPDMA_CxLLR. Then channel execution is completed.
Note: This bit must be written when EN=0. This bit is read-only when EN=1.</description>
                <bitOffset>16</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>channel executed for the full linked-list and completed at the end of the last LLI (GPDMA_CxLLR = 0). The 16 low-significant bits of the link address are null (LA[15:0] = 0) and all the update bits are null (UT1 =UB1 = UT2 = USA = UDA = ULL = 0). Then GPDMA_CxBR1.BNDT[15:0] = 0.</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>channel executed once for the current LLI</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>LAP</name>
                <description>linked-list allocated port
This bit is used to allocate the master port for the update of the GPDMA linked-list registers from the memory.
Note: This bit must be written when EN=0. This bit is read-only when EN=1.</description>
                <bitOffset>17</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>port 0 (AHB) allocated</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>port 1 (AHB) allocated</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>PRIO</name>
                <description>priority level of the channel x GPDMA transfer versus others
Note: This bit must be written when EN = 0. This bit is read-only when EN = 1.</description>
                <bitOffset>22</bitOffset>
                <bitWidth>2</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>low priority, low weight</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>low priority, mid weight</description>
                    <value>0x1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x2</name>
                    <description>low priority, high weight</description>
                    <value>0x2</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x3</name>
                    <description>high priority</description>
                    <value>0x3</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
            </fields>
          </register>
          <register>
            <name>GPDMA_C7TR1</name>
            <displayName>GPDMA_C7TR1</displayName>
            <description>GPDMA channel 7 transfer register 1</description>
            <addressOffset>0x410</addressOffset>
            <size>0x20</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>SDW_LOG2</name>
                <description>binary logarithm of the source data width of a burst in bytes
Setting a 8-byte data width causes a user setting error to be reported and no transfer is issued.
A source block size must be a multiple of the source data width (GPDMA_CxBR1.BNDT[2:0] versus SDW_LOG2[1:0]). Otherwise, a user setting error is reported and no transfer is issued.
Note: A source burst transfer must have an aligned address with its data width (start address GPDMA_CxSAR[2:0] versus SDW_LOG2[1:0]). Otherwise, a user setting error is reported and none transfer is issued.</description>
                <bitOffset>0</bitOffset>
                <bitWidth>2</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>byte</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>half-word (2 bytes)</description>
                    <value>0x1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x2</name>
                    <description>word (4 bytes)</description>
                    <value>0x2</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x3</name>
                    <description>user setting error reported and no transfer issued</description>
                    <value>0x3</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>SINC</name>
                <description>source incrementing burst
The source address, pointed by GPDMA_CxSAR, is kept constant after a burst beat/single transfer or is incremented by the offset value corresponding to a contiguous data after a burst beat/single transfer.</description>
                <bitOffset>3</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>fixed burst</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>contiguously incremented burst</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>SBL_1</name>
                <description>source burst length minus 1, between 0 and 63
The burst length unit is one data named beat within a burst. If SBL_1[5:0] =0 , the burst can be named as single. Each data/beat has a width defined by the destination data width SDW_LOG2[1:0].
Note: If a burst transfer crossed a 1-Kbyte address boundary on a AHB transfer, the GPDMA modifies and shortens the programmed burst into singles or bursts of lower length, to be compliant with the AHB protocol.
Note: If a burst transfer is of length greater than the FIFO size of the channel x, the GPDMA modifies and shortens the programmed burst into singles or bursts of lower length, to be compliant with the FIFO size. Transfer performance is lower, with GPDMA re-arbitration between effective and lower singles/bursts, but the data integrity is guaranteed.</description>
                <bitOffset>4</bitOffset>
                <bitWidth>6</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>PAM</name>
                <description>padding/alignment mode
If DDW_LOG2[1:0] = SDW_LOG2[1:0]: if the data width of a burst destination transfer is equal to the data width of a burst source transfer, these bits are ignored.
Else, in the following enumerated values, the condition PAM_1 is when destination data width is higher that source data width, and the condition PAM_2 is when destination data width is higher than source data width.
1x: successive source data are FIFO queued and packed at the destination data width, in a left (LSB) to right (MSB) order (named little endian), before a destination transfer
Note: 1x: source data is FIFO queued and unpacked at the destination data width, to be transferred in a left (LSB) to right (MSB) order (named little endian) to the destination</description>
                <bitOffset>11</bitOffset>
                <bitWidth>2</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0_PAM_1</name>
                    <description>source data is transferred as right aligned, padded with 0s up to the destination data width</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1_PAM_1</name>
                    <description>source data is transferred as right aligned, sign extended up to the destination data width</description>
                    <value>0x1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x0_PAM_2</name>
                    <description>source data is transferred as right aligned, left-truncated down to the destination data width</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1_PAM_2</name>
                    <description>source data is transferred as left-aligned, right-truncated down to the destination data width</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>SBX</name>
                <description>source byte exchange within the unaligned half-word of each source word 
If the source data width is shorter than a word, this bit is ignored.
If the source data width is a word:</description>
                <bitOffset>13</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>no byte-based exchange within the unaligned half-word of each source word</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>the two consecutive bytes within the unaligned half-word of each source word are exchanged.</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>SAP</name>
                <description>source allocated port
This bit is used to allocate the master port for the source transfer
Note: This bit must be written when EN = 0. This bit is read-only when EN = 1.</description>
                <bitOffset>14</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>port 0 (AHB) allocated</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>port 1 (AHB) allocated</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>SSEC</name>
                <description>security attribute of the GPDMA transfer from the source
If GPDMA_SECCFGR.SECx = 1 and the access is secure:
This is a secure register bit. This bit can only be read by a secure software. This bit must be written by a secure software when GPDMA_SECCFGR.SECx =1 . A secure write is ignored when GPDMA_SECCFGR.SECx = 0.
When GPDMA_SECCFGR.SECx is deasserted, this SSEC bit is also deasserted by hardware (on a secure reconfiguration of the channel as non-secure), and the GPDMA transfer from the source is non-secure.</description>
                <bitOffset>15</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>GPDMA transfer non-secure</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>GPDMA transfer secure</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>DDW_LOG2</name>
                <description>binary logarithm of the destination data width of a burst, in bytes
Setting a 8-byte data width causes a user setting error to be reported and none transfer is issued.
Note: A destination burst transfer must have an aligned address with its data width (start address GPDMA_CxDAR[2:0] versus DDW_LOG2[1:0]). Otherwise a user setting error is reported and no transfer is issued.</description>
                <bitOffset>16</bitOffset>
                <bitWidth>2</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>byte</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>half-word (2 bytes)</description>
                    <value>0x1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x2</name>
                    <description>word (4 bytes)</description>
                    <value>0x2</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x3</name>
                    <description>user setting error reported and no transfer issued</description>
                    <value>0x3</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>DINC</name>
                <description>destination incrementing burst
The destination address, pointed by GPDMA_CxDAR, is kept constant after a burst beat/single transfer, or is incremented by the offset value corresponding to a contiguous data after a burst beat/single transfer.</description>
                <bitOffset>19</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>fixed burst</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>contiguously incremented burst</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>DBL_1</name>
                <description>destination burst length minus 1, between 0 and 63
The burst length unit is one data named beat within a burst. If DBL_1[5:0] =0 , the burst can be named as single. Each data/beat has a width defined by the destination data width DDW_LOG2[1:0].
Note: If a burst transfer crossed a 1-Kbyte address boundary on a AHB transfer, the GPDMA modifies and shortens the programmed burst into singles or bursts of lower length, to be compliant with the AHB protocol.
Note: If a burst transfer is of length greater than the FIFO size of the channel x, the GPDMA modifies and shortens the programmed burst into singles or bursts of lower length, to be compliant with the FIFO size. Transfer performance is lower, with GPDMA re-arbitration between effective and lower singles/bursts, but the data integrity is guaranteed.</description>
                <bitOffset>20</bitOffset>
                <bitWidth>6</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>DBX</name>
                <description>destination byte exchange
If the destination data size is a byte, this bit is ignored.
If the destination data size is not a byte:</description>
                <bitOffset>26</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>no byte-based exchange within half-word</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>the two consecutive (post PAM) bytes are exchanged in each destination half-word.</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>DHX</name>
                <description>destination half-word exchange
If the destination data size is shorter than a word, this bit is ignored.
If the destination data size is a word:</description>
                <bitOffset>27</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>no halfword-based exchanged within word</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>the two consecutive (post PAM) half-words are exchanged in each destination word.</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>DAP</name>
                <description>destination allocated port
This bit is used to allocate the master port for the destination transfer
Note: This bit must be written when EN = 0. This bit is read-only when EN = 1.</description>
                <bitOffset>30</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>port 0 (AHB) allocated</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>port 1 (AHB) allocated</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>DSEC</name>
                <description>security attribute of the GPDMA transfer to the destination
If GPDMA_SECCFGR.SECx = 1 and the access is secure:
This is a secure register bit. This bit can only be read by a secure software. This bit must be written by a secure software when GPDMA_SECCFGR.SECx = 1. A secure write is ignored when GPDMA_SECCFGR.SECx = 0.
When GPDMA_SECCFGR.SECx is deasserted, this DSEC bit is also deasserted by hardware (on a secure reconfiguration of the channel as non-secure), and the GPDMA transfer to the destination is non-secure.</description>
                <bitOffset>31</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>GPDMA transfer non-secure</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>GPDMA transfer secure</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
            </fields>
          </register>
          <register>
            <name>GPDMA_C7TR2</name>
            <displayName>GPDMA_C7TR2</displayName>
            <description>GPDMA channel 7 transfer register 2</description>
            <addressOffset>0x414</addressOffset>
            <size>0x20</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>REQSEL</name>
                <description>GPDMA hardware request selection
These bits are ignored if channel x is activated (GPDMA_CxCR.EN asserted) with SWREQ = 1 (software request for a memory-to-memory transfer). Else, the selected hardware request is internally taken into account as per Section 16.3.3.
The user must not assign a same input hardware request (same REQSEL[5:0] value) to different active GPDMA channels (GPDMA_CxCR.EN = 1 and GPDMA_CxTR2.SWREQ = 0 for these channels). GPDMA is not intended to hardware support the case of simultaneous enabled channels incorrectly configured with a same hardware peripheral request signal, and there is no user setting error reporting.</description>
                <bitOffset>0</bitOffset>
                <bitWidth>6</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>SWREQ</name>
                <description>software request
This bit is internally taken into account when GPDMA_CxCR.EN is asserted.</description>
                <bitOffset>9</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>no software request. The selected hardware request REQSEL[5:0] is taken into account.</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>software request for a memory-to-memory transfer. The default selected hardware request as per REQSEL[5:0] is ignored.</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>DREQ</name>
                <description>destination hardware request
This bit is ignored if channel x is activated (GPDMA_CxCR.EN asserted) with SWREQ = 1 (software request for a memory-to-memory transfer). Else:</description>
                <bitOffset>10</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>selected hardware request driven by a source peripheral (request signal taken into account by the GPDMA transfer scheduler over the source/read port)</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>selected hardware request driven by a destination peripheral (request signal taken into account by the GPDMA transfer scheduler over the destination/write port)</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>BREQ</name>
                <description>Block hardware request
If the channel x is activated (GPDMA_CxCR.EN asserted) with SWREQ = 1 (software request for a memory-to-memory transfer), this bit is ignored. Else:</description>
                <bitOffset>11</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>the selected hardware request is driven by a peripheral with a hardware request/acknowledge protocol at a burst level.</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>the selected hardware request is driven by a peripheral with a hardware request/acknowledge protocol at a block level (see Section 16.3.3).</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>TRIGM</name>
                <description>trigger mode
These bits define the transfer granularity for its conditioning by the trigger.
If the channel x is enabled (GPDMA_CxCR.EN asserted) with TRIGPOL[1:0] = 00 or 11, these TRIGM[1:0] bits are ignored.
Else, a GPDMA transfer is conditioned by at least one trigger hit: 
 If the peripheral is programmed as a source (DREQ = 0) of the LLI data transfer, each programmed burst read is conditioned.
 If the peripheral is programmed as a destination (DREQ = 1) of the LLI data transfer, each programmed burst write is conditioned. The first memory burst read of a block, also named as the first ready FIFO-based source burst, is gated by the occurrence of both the hardware request and the first trigger hit.
The GPDMA monitoring of a trigger for channel x is started when the channel is enabled/loaded with a new active trigger configuration: rising or falling edge on a selected trigger (TRIGPOL[1:0] = 01 or respectively TRIGPOL[1:0] = 10).
The monitoring of this trigger is kept active during the triggered and uncompleted (data or link) transfer; and if a new trigger is detected then, this hit is internally memorized to grant the next transfer, as long as the defined rising or falling edge is not modified, and the TRIGSEL[4:0] is not modified, and the channel is enabled.
Transferring a next LLI&lt;sub&gt;n+1&lt;/sub&gt; that updates the GPDMA_CxTR2 with a new value for any of TRIGSEL[4:0] or TRIGPOL[1:0], resets the monitoring, trashing the memorized hit of the formerly defined LLI&lt;sub&gt;n &lt;/sub&gt;trigger.
After a first new trigger hit&lt;sub&gt;n+1&lt;/sub&gt; is memorized, if another second trigger hit&lt;sub&gt;n+2&lt;/sub&gt; is detected and if the hit&lt;sub&gt;n&lt;/sub&gt; triggered transfer is still not completed, hit&lt;sub&gt;n+2 &lt;/sub&gt;is lost and not memorized.memorized. A trigger overrun flag is reported (GPDMA_CxSR.TOF =1 ), and an interrupt is generated if enabled (GPDMA_CxCR.TOIE = 1). The channel is not automatically disabled by hardware due to a trigger overrun. 
Note: When the source block size is not a multiple of the source burst size and is a multiple of the source data width, then the last programmed source burst is not completed and is internally shorten to match the block size. In this case, if TRIGM[1:0] = 11 and (SWREQ =1  or (SWREQ = 0 and DREQ =0 )), the shortened burst transfer (by singles or/and by bursts of lower length) is conditioned once by the trigger.
Note: When the programmed destination burst is internally shortened by singles or/and by bursts of lower length (versus FIFO size, versus block size, 1-Kbyte boundary address crossing): if the trigger is conditioning the programmed destination burst (if TRIGM[1:0] = 11 and SWREQ = 0 and DREQ = 1), this shortened destination burst transfer is conditioned once by the trigger.</description>
                <bitOffset>14</bitOffset>
                <bitWidth>2</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>at block level: the first burst read of each block transfer is conditioned by one hit trigger .</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>channel x = 0 to 7, same as 0010: at link level: a LLI link transfer is conditioned by one hit trigger. The LLI data transfer (if any) is not conditioned.</description>
                    <value>0x1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x3</name>
                    <description>at programmed burst level: If SWREQ = 1, each programmed burst read is conditioned by one hit trigger. If SWREQ = 0, each programmed burst that is requested by the selected peripheral, is conditioned by one hit trigger.</description>
                    <value>0x3</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>TRIGSEL</name>
                <description>trigger event input selection
These bits select the trigger event input of the GPDMA transfer (as per Section 16.3.5), with an active trigger event if TRIGPOL[1:0]  00.</description>
                <bitOffset>16</bitOffset>
                <bitWidth>5</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>TRIGPOL</name>
                <description>trigger event polarity
These bits define the polarity of the selected trigger event input defined by TRIGSEL[4:0].</description>
                <bitOffset>24</bitOffset>
                <bitWidth>2</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>no trigger (masked trigger event)</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>trigger on the rising edge</description>
                    <value>0x1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x2</name>
                    <description>trigger on the falling edge</description>
                    <value>0x2</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x3</name>
                    <description>same as 00</description>
                    <value>0x3</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>TCEM</name>
                <description>transfer complete event mode
These bits define the transfer granularity for the transfer complete and half transfer complete events generation.
Note: If the initial LLI&lt;sub&gt;0 &lt;/sub&gt;data transfer is null/void (directly programmed by the internal register file with GPDMA_CxBR1.BNDT[15:0] = 0), then neither the complete transfer event nor the half transfer event is generated.
Note: If the initial LLI&lt;sub&gt;0 &lt;/sub&gt;data transfer is null/void (directly programmed by the internal register file with GPDMA_CxBR1.BNDT[15:0] = 0), then neither the complete transfer event nor the half transfer event is generated.
Note: If the initial LLI&lt;sub&gt;0 &lt;/sub&gt;data transfer is null/void (i.e. directly programmed by the internal register file with GPDMA_CxBR1.BNDT[15:0] =0 ), then the half transfer event is not generated, and the transfer complete event is generated when is completed the loading of the LLI&lt;sub&gt;1&lt;/sub&gt;.</description>
                <bitOffset>30</bitOffset>
                <bitWidth>2</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>at block level (when GPDMA_CxBR1.BNDT[15:0] = 0): the complete (and the half) transfer event is generated at the (respectively half of the) end of a block.</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>channel x (0 to 7, same as 00</description>
                    <value>0x1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x2</name>
                    <description>at LLI level: the complete transfer event is generated at the end of the LLI transfer, including the update of the LLI if any. The half transfer event is generated at the half of the LLI data transfer.</description>
                    <value>0x2</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x3</name>
                    <description>at channel level: the complete transfer event is generated at the end of the last LLI transfer. The half transfer event is generated at the half of the data transfer of the last LLI. The last LLI updates the link address GPDMA_CxLLR.LA[15:2] to zero and clears all the GPDMA_CxLLR update bits (UT1, UT2, UB1, USA, UDA and ULL). If the channel transfer is continuous/infinite, no event is generated.</description>
                    <value>0x3</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
            </fields>
          </register>
          <register>
            <name>GPDMA_C7BR1</name>
            <displayName>GPDMA_C7BR1</displayName>
            <description>GPDMA channel 7 block register 1</description>
            <addressOffset>0x418</addressOffset>
            <size>0x20</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>BNDT</name>
                <description>block number of data bytes to transfer from the source
Block size transferred from the source. When the channel is enabled, this field becomes read-only and is decremented, indicating the remaining number of data items in the current source block to be transferred. BNDT[15:0] is programmed in number of bytes, maximum source block size is 64 Kbytes -1.
Once the last data transfer is completed (BNDT[15:0] = 0):
- if GPDMA_CxLLR.UB1 = 1, this field is updated by the LLI in the memory.
- if GPDMA_CxLLR.UB1 = 0 and if there is at least one non null Uxx update bit, this field is internally restored to the programmed value.
- if all GPDMA_CxLLR.Uxx = 0 and if GPDMA_CxLLR.LA[15:0] = 0, this field is internally restored to the programmed value (infinite/continuous last LLI).
- if GPDMA_CxLLR = 0, this field is kept as zero following the last LLI data transfer.
Note: A non-null source block size must be a multiple of the source data width (BNDT[2:0] versus GPDMA_CxTR1.SDW_LOG2[1:0]). Else a user setting error is reported and no transfer is issued.
Note: When configured in packing mode (GPDMA_CxTR1.PAM[1] = 1 and destination data width different from source data width), a non-null source block size must be a multiple of the destination data width (BNDT[2:0] versus GPDMA_CxTR1.DDW_LOG2[1:0]). Else a user setting error is reported and no transfer is issued.</description>
                <bitOffset>0</bitOffset>
                <bitWidth>16</bitWidth>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>GPDMA_C7SAR</name>
            <displayName>GPDMA_C7SAR</displayName>
            <description>GPDMA channel 7 source address register</description>
            <addressOffset>0x41C</addressOffset>
            <size>0x20</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>SA</name>
                <description>source address
This field is the pointer to the address from which the next data is read.
During the channel activity, depending on the source addressing mode (GPDMA_CxTR1.SINC), this field is kept fixed or incremented by the data width (GPDMA_CxTR1.SDW_LOG2[1:0]) after each burst source data, reflecting the next address from which data is read.
During the channel activity, this address is updated after each completed source burst, consequently to:
the programmed source burst; either in fixed addressing mode or in contiguous-data incremented mode. If contiguously incremented (GPDMA_CxTR1.SINC = 1), then the additional address offset value is the programmed burst size, as defined by GPDMA_CxTR1.SBL_1[5:0] and GPDMA_CxTR1.SDW_LOG2[21:0]
the additional source incremented/decremented offset value as programmed by GPDMA_CxBR1.SDEC
In linked-list mode, after a LLI data transfer is completed, this register is automatically updated by GPDMA from the memory, provided the LLI is set with GPDMA_CxLLR.USA = 1.
Note: A source address must be aligned with the programmed data width of a source burst (SA[2:0] versus GPDMA_CxTR1.SDW_LOG2[1:0]). Else, a user setting error is reported and no transfer is issued.</description>
                <bitOffset>0</bitOffset>
                <bitWidth>32</bitWidth>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>GPDMA_C7DAR</name>
            <displayName>GPDMA_C7DAR</displayName>
            <description>GPDMA channel 7 destination address register</description>
            <addressOffset>0x420</addressOffset>
            <size>0x20</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>DA</name>
                <description>destination address
This field is the pointer to the address from which the next data is written.
During the channel activity, depending on the destination addressing mode (GPDMA_CxTR1.DINC), this field is kept fixed or incremented by the data width (GPDMA_CxTR1.DDW_LOG2[21:0]) after each burst destination data, reflecting the next address from which data is written.
During the channel activity, this address is updated after each completed destination burst, consequently to:
the programmed destination burst; either in fixed addressing mode or in contiguous-data incremented mode. If contiguously incremented (GPDMA_CxTR1.DINC = 1), then the additional address offset value is the programmed burst size, as defined by GPDMA_CxTR1.DBL_1[5:0] and GPDMA_CxTR1.DDW_LOG2[1:0]
the additional destination incremented/decremented offset value as programmed by GPDMA_CxBR1.DDEC.
In linked-list mode, after a LLI data transfer is completed, this register is automatically updated by the GPDMA from the memory, provided the LLI is set with GPDMA_CxLLR.UDA = 1.
Note: A destination address must be aligned with the programmed data width of a destination burst (DA[2:0] versus GPDMA_CxTR1.DDW_LOG2[1:0]). Else, a user setting error is reported and no transfer is issued.</description>
                <bitOffset>0</bitOffset>
                <bitWidth>32</bitWidth>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>GPDMA_C7LLR</name>
            <displayName>GPDMA_C7LLR</displayName>
            <description>GPDMA channel 7 linked-list address register</description>
            <addressOffset>0x44C</addressOffset>
            <size>0x20</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>LA</name>
                <description>pointer (16-bit low-significant address) to the next linked-list data structure
If UT1 = UT2 = UB1 = USA = UDA = ULL = 0 and if LA[15:20] = 0, the current LLI is the last one. The channel transfer is completed without any update of the linked-list GPDMA register file.
Else, this field is the pointer to the memory address offset from which the next linked-list data structure is automatically fetched from, once the data transfer is completed, in order to conditionally update the linked-list GPDMA internal register file (GPDMA_CxCTR1, GPDMA_CxTR2, GPDMA_CxBR1, GPDMA_CxSAR, GPDMA_CxDAR and GPDMA_CxLLR).
Note: The user must program the pointer to be 32-bit aligned. The two low-significant bits are write ignored.</description>
                <bitOffset>2</bitOffset>
                <bitWidth>14</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>ULL</name>
                <description>Update GPDMA_CxLLR register from memory
This bit is used to control the update of GPDMA_CxLLR from the memory during the link transfer.</description>
                <bitOffset>16</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>no GPDMA_CxLLR update</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>GPDMA_CxLLR update</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>UDA</name>
                <description>Update GPDMA_CxDAR register from memory
This bit is used to control the update of GPDMA_CxDAR from the memory during the link transfer.</description>
                <bitOffset>27</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>no GPDMA_CxDAR update</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>GPDMA_CxDAR update</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>USA</name>
                <description>update GPDMA_CxSAR from memory
This bit controls the update of GPDMA_CxSAR from the memory during the link transfer.</description>
                <bitOffset>28</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>no GPDMA_CxSAR update</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>GPDMA_CxSAR update</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>UB1</name>
                <description>Update GPDMA_CxBR1 from memory
This bit controls the update of GPDMA_CxBR1 from the memory during the link transfer. If UB1 = 0 and if GPDMA_CxLLR  0, the linked-list is not completed. GPDMA_CxBR1.BNDT[15:0] is then restored to the programmed value after data transfer is completed and before the link transfer.</description>
                <bitOffset>29</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>no GPDMA_CxBR1 update from memory (GPDMA_CxBR1.BNDT[15:0] restored if any link transfer)</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>GPDMA_CxBR1 update</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>UT2</name>
                <description>Update GPDMA_CxTR2 from memory
This bit controls the update of GPDMA_CxTR2 from the memory during the link transfer.</description>
                <bitOffset>30</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>no GPDMA_CxTR2 update</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>GPDMA_CxTR2 update</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>UT1</name>
                <description>Update GPDMA_CxTR1 from memory
This bit controls the update of GPDMA_CxTR1 from the memory during the link transfer.</description>
                <bitOffset>31</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>no GPDMA_CxTR1 update</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>GPDMA_CxTR1 update</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
            </fields>
          </register>
        </registers>
    </peripheral>
	<peripheral derivedFrom="GPDMA">
      <name>SEC_GPDMA</name>
      <baseAddress>0x50020000</baseAddress>
    </peripheral>
	<peripheral>
        <name>GPIOA</name>
        <description>General-purpose I/Os</description>
        <groupName>GPIO</groupName>
        <baseAddress>0x42020000</baseAddress>
        <addressBlock>
          <offset>0x0</offset>
          <size>0x400</size>
          <usage>registers</usage>
        </addressBlock>
        <registers>
          <register>
            <name>GPIOA_MODER</name>
            <displayName>GPIOA_MODER</displayName>
            <description>GPIO port A mode register</description>
            <addressOffset>0x000</addressOffset>
            <size>0x20</size>
            <resetValue>0xABFFFFFF</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>MODE0</name>
                <description>Port configuration I/O pin 0</description>
                <bitOffset>0</bitOffset>
                <bitWidth>2</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>MODE1</name>
                <description>Port configuration I/O pin 1</description>
                <bitOffset>2</bitOffset>
                <bitWidth>2</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>MODE2</name>
                <description>Port configuration I/O pin 2</description>
                <bitOffset>4</bitOffset>
                <bitWidth>2</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>MODE3</name>
                <description>Port configuration I/O pin 3</description>
                <bitOffset>6</bitOffset>
                <bitWidth>2</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>MODE5</name>
                <description>Port configuration I/O pin 5</description>
                <bitOffset>10</bitOffset>
                <bitWidth>2</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>MODE6</name>
                <description>Port configuration I/O pin 6</description>
                <bitOffset>12</bitOffset>
                <bitWidth>2</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>MODE7</name>
                <description>Port configuration I/O pin 7</description>
                <bitOffset>14</bitOffset>
                <bitWidth>2</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>MODE8</name>
                <description>Port configuration I/O pin 8</description>
                <bitOffset>16</bitOffset>
                <bitWidth>2</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>MODE9</name>
                <description>Port configuration I/O pin 9</description>
                <bitOffset>18</bitOffset>
                <bitWidth>2</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>MODE10</name>
                <description>Port configuration I/O pin 10</description>
                <bitOffset>20</bitOffset>
                <bitWidth>2</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>MODE11</name>
                <description>Port configuration I/O pin 11</description>
                <bitOffset>22</bitOffset>
                <bitWidth>2</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>MODE12</name>
                <description>Port configuration I/O pin 12</description>
                <bitOffset>24</bitOffset>
                <bitWidth>2</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>MODE13</name>
                <description>Port configuration I/O pin 13</description>
                <bitOffset>26</bitOffset>
                <bitWidth>2</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>MODE14</name>
                <description>Port configuration I/O pin 14</description>
                <bitOffset>28</bitOffset>
                <bitWidth>2</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>MODE15</name>
                <description>Port configuration I/O pin 15
These bits are written by software to configure the I/O mode.
Access can be protected by GPIOA SEC15.</description>
                <bitOffset>30</bitOffset>
                <bitWidth>2</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Input mode</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>General purpose output mode</description>
                    <value>0x1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x2</name>
                    <description>Alternate function mode</description>
                    <value>0x2</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x3</name>
                    <description>Analog mode (reset state)</description>
                    <value>0x3</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
            </fields>
          </register>
          <register>
            <name>GPIOA_OTYPER</name>
            <displayName>GPIOA_OTYPER</displayName>
            <description>GPIO port A output type register</description>
            <addressOffset>0x004</addressOffset>
            <size>0x20</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>OT0</name>
                <description>Port configuration I/O pin y
These bits are written by software to configure the I/O output type.
Access can be protected by GPIOA SECy.</description>
                <bitOffset>0</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Output push-pull (reset state)</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Output open-drain</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>OT1</name>
                <description>Port configuration I/O pin y
These bits are written by software to configure the I/O output type.
Access can be protected by GPIOA SECy.</description>
                <bitOffset>1</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Output push-pull (reset state)</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Output open-drain</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>OT2</name>
                <description>Port configuration I/O pin y
These bits are written by software to configure the I/O output type.
Access can be protected by GPIOA SECy.</description>
                <bitOffset>2</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Output push-pull (reset state)</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Output open-drain</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>OT3</name>
                <description>Port configuration I/O pin y
These bits are written by software to configure the I/O output type.
Access can be protected by GPIOA SECy.</description>
                <bitOffset>3</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Output push-pull (reset state)</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Output open-drain</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>OT5</name>
                <description>Port configuration I/O pin y
These bits are written by software to configure the I/O output type.
Access can be protected by GPIOA SECy.</description>
                <bitOffset>5</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Output push-pull (reset state)</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Output open-drain</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>OT6</name>
                <description>Port configuration I/O pin y
These bits are written by software to configure the I/O output type.
Access can be protected by GPIOA SECy.</description>
                <bitOffset>6</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Output push-pull (reset state)</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Output open-drain</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>OT7</name>
                <description>Port configuration I/O pin y
These bits are written by software to configure the I/O output type.
Access can be protected by GPIOA SECy.</description>
                <bitOffset>7</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Output push-pull (reset state)</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Output open-drain</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>OT8</name>
                <description>Port configuration I/O pin y
These bits are written by software to configure the I/O output type.
Access can be protected by GPIOA SECy.</description>
                <bitOffset>8</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Output push-pull (reset state)</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Output open-drain</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>OT9</name>
                <description>Port configuration I/O pin y
These bits are written by software to configure the I/O output type.
Access can be protected by GPIOA SECy.</description>
                <bitOffset>9</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Output push-pull (reset state)</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Output open-drain</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>OT10</name>
                <description>Port configuration I/O pin y
These bits are written by software to configure the I/O output type.
Access can be protected by GPIOA SECy.</description>
                <bitOffset>10</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Output push-pull (reset state)</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Output open-drain</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>OT11</name>
                <description>Port configuration I/O pin y
These bits are written by software to configure the I/O output type.
Access can be protected by GPIOA SECy.</description>
                <bitOffset>11</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Output push-pull (reset state)</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Output open-drain</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>OT12</name>
                <description>Port configuration I/O pin y
These bits are written by software to configure the I/O output type.
Access can be protected by GPIOA SECy.</description>
                <bitOffset>12</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Output push-pull (reset state)</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Output open-drain</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>OT13</name>
                <description>Port configuration I/O pin y
These bits are written by software to configure the I/O output type.
Access can be protected by GPIOA SECy.</description>
                <bitOffset>13</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Output push-pull (reset state)</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Output open-drain</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>OT14</name>
                <description>Port configuration I/O pin y
These bits are written by software to configure the I/O output type.
Access can be protected by GPIOA SECy.</description>
                <bitOffset>14</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Output push-pull (reset state)</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Output open-drain</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>OT15</name>
                <description>Port configuration I/O pin y
These bits are written by software to configure the I/O output type.
Access can be protected by GPIOA SECy.</description>
                <bitOffset>15</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Output push-pull (reset state)</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Output open-drain</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
            </fields>
          </register>
          <register>
            <name>GPIOA_OSPEEDR</name>
            <displayName>GPIOA_OSPEEDR</displayName>
            <description>GPIO port A output speed register</description>
            <addressOffset>0x008</addressOffset>
            <size>0x20</size>
            <resetValue>0x08000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>OSPEED0</name>
                <description>Port configuration I/O pin 0</description>
                <bitOffset>0</bitOffset>
                <bitWidth>2</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>OSPEED1</name>
                <description>Port configuration I/O pin 1</description>
                <bitOffset>2</bitOffset>
                <bitWidth>2</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>OSPEED2</name>
                <description>Port configuration I/O pin 2</description>
                <bitOffset>4</bitOffset>
                <bitWidth>2</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>OSPEED3</name>
                <description>Port configuration I/O pin 3</description>
                <bitOffset>6</bitOffset>
                <bitWidth>2</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>OSPEED5</name>
                <description>Port configuration I/O pin 5</description>
                <bitOffset>10</bitOffset>
                <bitWidth>2</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>OSPEED6</name>
                <description>Port configuration I/O pin 6</description>
                <bitOffset>12</bitOffset>
                <bitWidth>2</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>OSPEED7</name>
                <description>Port configuration I/O pin 7</description>
                <bitOffset>14</bitOffset>
                <bitWidth>2</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>OSPEED8</name>
                <description>Port configuration I/O pin 8</description>
                <bitOffset>16</bitOffset>
                <bitWidth>2</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>OSPEED9</name>
                <description>Port configuration I/O pin 9</description>
                <bitOffset>18</bitOffset>
                <bitWidth>2</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>OSPEED10</name>
                <description>Port configuration I/O pin 10</description>
                <bitOffset>20</bitOffset>
                <bitWidth>2</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>OSPEED11</name>
                <description>Port configuration I/O pin 11</description>
                <bitOffset>22</bitOffset>
                <bitWidth>2</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>OSPEED12</name>
                <description>Port configuration I/O pin 12</description>
                <bitOffset>24</bitOffset>
                <bitWidth>2</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>OSPEED13</name>
                <description>Port configuration I/O pin 13</description>
                <bitOffset>26</bitOffset>
                <bitWidth>2</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>OSPEED14</name>
                <description>Port configuration I/O pin 14</description>
                <bitOffset>28</bitOffset>
                <bitWidth>2</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>OSPEED15</name>
                <description>Port configuration I/O pin 15
These bits are written by software to configure the I/O output speed.
Access can be protected by GPIOA SEC15.
Note: Refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed.</description>
                <bitOffset>30</bitOffset>
                <bitWidth>2</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Low speed</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Medium speed</description>
                    <value>0x1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x2</name>
                    <description>High speed</description>
                    <value>0x2</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x3</name>
                    <description>Reserved</description>
                    <value>0x3</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
            </fields>
          </register>
          <register>
            <name>GPIOA_PUPDR</name>
            <displayName>GPIOA_PUPDR</displayName>
            <description>GPIO port A pull-up/pull-down register</description>
            <addressOffset>0x00C</addressOffset>
            <size>0x20</size>
            <resetValue>0x64000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>PUPD0</name>
                <description>Port configuration I/O pin 0</description>
                <bitOffset>0</bitOffset>
                <bitWidth>2</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>PUPD1</name>
                <description>Port configuration I/O pin 1</description>
                <bitOffset>2</bitOffset>
                <bitWidth>2</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>PUPD2</name>
                <description>Port configuration I/O pin 2</description>
                <bitOffset>4</bitOffset>
                <bitWidth>2</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>PUPD3</name>
                <description>Port configuration I/O pin 3</description>
                <bitOffset>6</bitOffset>
                <bitWidth>2</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>PUPD5</name>
                <description>Port configuration I/O pin 5</description>
                <bitOffset>10</bitOffset>
                <bitWidth>2</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>PUPD6</name>
                <description>Port configuration I/O pin 6</description>
                <bitOffset>12</bitOffset>
                <bitWidth>2</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>PUPD7</name>
                <description>Port configuration I/O pin 7</description>
                <bitOffset>14</bitOffset>
                <bitWidth>2</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>PUPD8</name>
                <description>Port configuration I/O pin 8</description>
                <bitOffset>16</bitOffset>
                <bitWidth>2</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>PUPD9</name>
                <description>Port configuration I/O pin 9</description>
                <bitOffset>18</bitOffset>
                <bitWidth>2</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>PUPD10</name>
                <description>Port configuration I/O pin 10</description>
                <bitOffset>20</bitOffset>
                <bitWidth>2</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>PUPD11</name>
                <description>Port configuration I/O pin 11</description>
                <bitOffset>22</bitOffset>
                <bitWidth>2</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>PUPD12</name>
                <description>Port configuration I/O pin 12</description>
                <bitOffset>24</bitOffset>
                <bitWidth>2</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>PUPD13</name>
                <description>Port configuration I/O pin 13</description>
                <bitOffset>26</bitOffset>
                <bitWidth>2</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>PUPD14</name>
                <description>Port configuration I/O pin 14</description>
                <bitOffset>28</bitOffset>
                <bitWidth>2</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>PUPD15</name>
                <description>Port configuration I/O pin 15
These bits are written by software to configure the I/O pull-up or pull-down
Access can be protected by GPIOA SEC15.</description>
                <bitOffset>30</bitOffset>
                <bitWidth>2</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>No pull-up, pull-down</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Pull-up</description>
                    <value>0x1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x2</name>
                    <description>Pull-down</description>
                    <value>0x2</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x3</name>
                    <description>Reserved</description>
                    <value>0x3</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
            </fields>
          </register>
          <register>
            <name>GPIOA_IDR</name>
            <displayName>GPIOA_IDR</displayName>
            <description>GPIO port A input data register</description>
            <addressOffset>0x010</addressOffset>
            <size>0x20</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFF0000</resetMask>
            <fields>
              <field>
                <name>ID0</name>
                <description>Port input data I/O pin y
These bits are read-only. They contain the input value of the corresponding I/O port.
Access can be protected by GPIOA SECy.</description>
                <bitOffset>0</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-only</access>
              </field>
              <field>
                <name>ID1</name>
                <description>Port input data I/O pin y
These bits are read-only. They contain the input value of the corresponding I/O port.
Access can be protected by GPIOA SECy.</description>
                <bitOffset>1</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-only</access>
              </field>
              <field>
                <name>ID2</name>
                <description>Port input data I/O pin y
These bits are read-only. They contain the input value of the corresponding I/O port.
Access can be protected by GPIOA SECy.</description>
                <bitOffset>2</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-only</access>
              </field>
              <field>
                <name>ID3</name>
                <description>Port input data I/O pin y
These bits are read-only. They contain the input value of the corresponding I/O port.
Access can be protected by GPIOA SECy.</description>
                <bitOffset>3</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-only</access>
              </field>
              <field>
                <name>ID5</name>
                <description>Port input data I/O pin y
These bits are read-only. They contain the input value of the corresponding I/O port.
Access can be protected by GPIOA SECy.</description>
                <bitOffset>5</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-only</access>
              </field>
              <field>
                <name>ID6</name>
                <description>Port input data I/O pin y
These bits are read-only. They contain the input value of the corresponding I/O port.
Access can be protected by GPIOA SECy.</description>
                <bitOffset>6</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-only</access>
              </field>
              <field>
                <name>ID7</name>
                <description>Port input data I/O pin y
These bits are read-only. They contain the input value of the corresponding I/O port.
Access can be protected by GPIOA SECy.</description>
                <bitOffset>7</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-only</access>
              </field>
              <field>
                <name>ID8</name>
                <description>Port input data I/O pin y
These bits are read-only. They contain the input value of the corresponding I/O port.
Access can be protected by GPIOA SECy.</description>
                <bitOffset>8</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-only</access>
              </field>
              <field>
                <name>ID9</name>
                <description>Port input data I/O pin y
These bits are read-only. They contain the input value of the corresponding I/O port.
Access can be protected by GPIOA SECy.</description>
                <bitOffset>9</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-only</access>
              </field>
              <field>
                <name>ID10</name>
                <description>Port input data I/O pin y
These bits are read-only. They contain the input value of the corresponding I/O port.
Access can be protected by GPIOA SECy.</description>
                <bitOffset>10</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-only</access>
              </field>
              <field>
                <name>ID11</name>
                <description>Port input data I/O pin y
These bits are read-only. They contain the input value of the corresponding I/O port.
Access can be protected by GPIOA SECy.</description>
                <bitOffset>11</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-only</access>
              </field>
              <field>
                <name>ID12</name>
                <description>Port input data I/O pin y
These bits are read-only. They contain the input value of the corresponding I/O port.
Access can be protected by GPIOA SECy.</description>
                <bitOffset>12</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-only</access>
              </field>
              <field>
                <name>ID13</name>
                <description>Port input data I/O pin y
These bits are read-only. They contain the input value of the corresponding I/O port.
Access can be protected by GPIOA SECy.</description>
                <bitOffset>13</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-only</access>
              </field>
              <field>
                <name>ID14</name>
                <description>Port input data I/O pin y
These bits are read-only. They contain the input value of the corresponding I/O port.
Access can be protected by GPIOA SECy.</description>
                <bitOffset>14</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-only</access>
              </field>
              <field>
                <name>ID15</name>
                <description>Port input data I/O pin y
These bits are read-only. They contain the input value of the corresponding I/O port.
Access can be protected by GPIOA SECy.</description>
                <bitOffset>15</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-only</access>
              </field>
            </fields>
          </register>
          <register>
            <name>GPIOA_ODR</name>
            <displayName>GPIOA_ODR</displayName>
            <description>GPIO port A output data register</description>
            <addressOffset>0x014</addressOffset>
            <size>0x20</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>OD0</name>
                <description>Port output data I/O pin y
These bits can be read and written by software.
Access can be protected by GPIOA SECy.
Note: For atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the GPIOA_BSRR or GPIOA_BRR registers.</description>
                <bitOffset>0</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>OD1</name>
                <description>Port output data I/O pin y
These bits can be read and written by software.
Access can be protected by GPIOA SECy.
Note: For atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the GPIOA_BSRR or GPIOA_BRR registers.</description>
                <bitOffset>1</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>OD2</name>
                <description>Port output data I/O pin y
These bits can be read and written by software.
Access can be protected by GPIOA SECy.
Note: For atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the GPIOA_BSRR or GPIOA_BRR registers.</description>
                <bitOffset>2</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>OD3</name>
                <description>Port output data I/O pin y
These bits can be read and written by software.
Access can be protected by GPIOA SECy.
Note: For atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the GPIOA_BSRR or GPIOA_BRR registers.</description>
                <bitOffset>3</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>OD5</name>
                <description>Port output data I/O pin y
These bits can be read and written by software.
Access can be protected by GPIOA SECy.
Note: For atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the GPIOA_BSRR or GPIOA_BRR registers .</description>
                <bitOffset>5</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>OD6</name>
                <description>Port output data I/O pin y
These bits can be read and written by software.
Access can be protected by GPIOA SECy.
Note: For atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the GPIOA_BSRR or GPIOA_BRR registers .</description>
                <bitOffset>6</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>OD7</name>
                <description>Port output data I/O pin y
These bits can be read and written by software.
Access can be protected by GPIOA SECy.
Note: For atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the GPIOA_BSRR or GPIOA_BRR registers .</description>
                <bitOffset>7</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>OD8</name>
                <description>Port output data I/O pin y
These bits can be read and written by software.
Access can be protected by GPIOA SECy.
Note: For atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the GPIOA_BSRR or GPIOA_BRR registers .</description>
                <bitOffset>8</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>OD9</name>
                <description>Port output data I/O pin y
These bits can be read and written by software.
Access can be protected by GPIOA SECy.
Note: For atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the GPIOA_BSRR or GPIOA_BRR registers .</description>
                <bitOffset>9</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>OD10</name>
                <description>Port output data I/O pin y
These bits can be read and written by software.
Access can be protected by GPIOA SECy.
Note: For atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the GPIOA_BSRR or GPIOA_BRR registers .</description>
                <bitOffset>10</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>OD11</name>
                <description>Port output data I/O pin y
These bits can be read and written by software.
Access can be protected by GPIOA SECy.
Note: For atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the GPIOA_BSRR or GPIOA_BRR registers .</description>
                <bitOffset>11</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>OD12</name>
                <description>Port output data I/O pin y
These bits can be read and written by software.
Access can be protected by GPIOA SECy.
Note: For atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the GPIOA_BSRR or GPIOA_BRR registers .</description>
                <bitOffset>12</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>OD13</name>
                <description>Port output data I/O pin y
These bits can be read and written by software.
Access can be protected by GPIOA SECy.
Note: For atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the GPIOA_BSRR or GPIOA_BRR registers .</description>
                <bitOffset>13</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>OD14</name>
                <description>Port output data I/O pin y
These bits can be read and written by software.
Access can be protected by GPIOA SECy.
Note: For atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the GPIOA_BSRR or GPIOA_BRR registers .</description>
                <bitOffset>14</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>OD15</name>
                <description>Port output data I/O pin y
These bits can be read and written by software.
Access can be protected by GPIOA SECy.
Note: For atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the GPIOA_BSRR or GPIOA_BRR registers .</description>
                <bitOffset>15</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>GPIOA_BSRR</name>
            <displayName>GPIOA_BSRR</displayName>
            <description>GPIO port A bit set/reset register</description>
            <addressOffset>0x018</addressOffset>
            <size>0x20</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>BS0</name>
                <description>Port set I/O pin y
These bits are write-only. A read to these bits returns the value 0.
Access can be protected by GPIOA SECy</description>
                <bitOffset>0</bitOffset>
                <bitWidth>1</bitWidth>
                <access>write-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>No action on the corresponding ODy bit</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Sets the corresponding ODy bit</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>BS1</name>
                <description>Port set I/O pin y
These bits are write-only. A read to these bits returns the value 0.
Access can be protected by GPIOA SECy</description>
                <bitOffset>1</bitOffset>
                <bitWidth>1</bitWidth>
                <access>write-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>No action on the corresponding ODy bit</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Sets the corresponding ODy bit</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>BS2</name>
                <description>Port set I/O pin y
These bits are write-only. A read to these bits returns the value 0.
Access can be protected by GPIOA SECy</description>
                <bitOffset>2</bitOffset>
                <bitWidth>1</bitWidth>
                <access>write-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>No action on the corresponding ODy bit</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Sets the corresponding ODy bit</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>BS3</name>
                <description>Port set I/O pin y
These bits are write-only. A read to these bits returns the value 0.
Access can be protected by GPIOA SECy</description>
                <bitOffset>3</bitOffset>
                <bitWidth>1</bitWidth>
                <access>write-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>No action on the corresponding ODy bit</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Sets the corresponding ODy bit</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>BS5</name>
                <description>Port set I/O pin y
These bits are write-only. A read to these bits returns the value 0.
Access can be protected by GPIOA SECy</description>
                <bitOffset>5</bitOffset>
                <bitWidth>1</bitWidth>
                <access>write-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>No action on the corresponding ODy bit</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Sets the corresponding ODy bit</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>BS6</name>
                <description>Port set I/O pin y
These bits are write-only. A read to these bits returns the value 0.
Access can be protected by GPIOA SECy</description>
                <bitOffset>6</bitOffset>
                <bitWidth>1</bitWidth>
                <access>write-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>No action on the corresponding ODy bit</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Sets the corresponding ODy bit</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>BS7</name>
                <description>Port set I/O pin y
These bits are write-only. A read to these bits returns the value 0.
Access can be protected by GPIOA SECy</description>
                <bitOffset>7</bitOffset>
                <bitWidth>1</bitWidth>
                <access>write-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>No action on the corresponding ODy bit</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Sets the corresponding ODy bit</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>BS8</name>
                <description>Port set I/O pin y
These bits are write-only. A read to these bits returns the value 0.
Access can be protected by GPIOA SECy</description>
                <bitOffset>8</bitOffset>
                <bitWidth>1</bitWidth>
                <access>write-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>No action on the corresponding ODy bit</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Sets the corresponding ODy bit</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>BS9</name>
                <description>Port set I/O pin y
These bits are write-only. A read to these bits returns the value 0.
Access can be protected by GPIOA SECy</description>
                <bitOffset>9</bitOffset>
                <bitWidth>1</bitWidth>
                <access>write-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>No action on the corresponding ODy bit</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Sets the corresponding ODy bit</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>BS10</name>
                <description>Port set I/O pin y
These bits are write-only. A read to these bits returns the value 0.
Access can be protected by GPIOA SECy</description>
                <bitOffset>10</bitOffset>
                <bitWidth>1</bitWidth>
                <access>write-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>No action on the corresponding ODy bit</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Sets the corresponding ODy bit</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>BS11</name>
                <description>Port set I/O pin y
These bits are write-only. A read to these bits returns the value 0.
Access can be protected by GPIOA SECy</description>
                <bitOffset>11</bitOffset>
                <bitWidth>1</bitWidth>
                <access>write-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>No action on the corresponding ODy bit</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Sets the corresponding ODy bit</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>BS12</name>
                <description>Port set I/O pin y
These bits are write-only. A read to these bits returns the value 0.
Access can be protected by GPIOA SECy</description>
                <bitOffset>12</bitOffset>
                <bitWidth>1</bitWidth>
                <access>write-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>No action on the corresponding ODy bit</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Sets the corresponding ODy bit</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>BS13</name>
                <description>Port set I/O pin y
These bits are write-only. A read to these bits returns the value 0.
Access can be protected by GPIOA SECy</description>
                <bitOffset>13</bitOffset>
                <bitWidth>1</bitWidth>
                <access>write-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>No action on the corresponding ODy bit</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Sets the corresponding ODy bit</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>BS14</name>
                <description>Port set I/O pin y
These bits are write-only. A read to these bits returns the value 0.
Access can be protected by GPIOA SECy</description>
                <bitOffset>14</bitOffset>
                <bitWidth>1</bitWidth>
                <access>write-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>No action on the corresponding ODy bit</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Sets the corresponding ODy bit</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>BS15</name>
                <description>Port set I/O pin y
These bits are write-only. A read to these bits returns the value 0.
Access can be protected by GPIOA SECy</description>
                <bitOffset>15</bitOffset>
                <bitWidth>1</bitWidth>
                <access>write-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>No action on the corresponding ODy bit</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Sets the corresponding ODy bit</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>BR0</name>
                <description>Port reset I/O pin y
These bits are write-only. A read to these bits returns the value 0.
Access can be protected by GPIOA SECy.
Note: If both BSy and BRy are set, BSy has priority.</description>
                <bitOffset>16</bitOffset>
                <bitWidth>1</bitWidth>
                <access>write-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>No action on the corresponding ODy bit</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Resets the corresponding ODy bit</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>BR1</name>
                <description>Port reset I/O pin y
These bits are write-only. A read to these bits returns the value 0.
Access can be protected by GPIOA SECy.
Note: If both BSy and BRy are set, BSy has priority.</description>
                <bitOffset>17</bitOffset>
                <bitWidth>1</bitWidth>
                <access>write-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>No action on the corresponding ODy bit</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Resets the corresponding ODy bit</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>BR2</name>
                <description>Port reset I/O pin y
These bits are write-only. A read to these bits returns the value 0.
Access can be protected by GPIOA SECy.
Note: If both BSy and BRy are set, BSy has priority.</description>
                <bitOffset>18</bitOffset>
                <bitWidth>1</bitWidth>
                <access>write-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>No action on the corresponding ODy bit</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Resets the corresponding ODy bit</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>BR3</name>
                <description>Port reset I/O pin y
These bits are write-only. A read to these bits returns the value 0.
Access can be protected by GPIOA SECy.
Note: If both BSy and BRy are set, BSy has priority.</description>
                <bitOffset>19</bitOffset>
                <bitWidth>1</bitWidth>
                <access>write-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>No action on the corresponding ODy bit</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Resets the corresponding ODy bit</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>BR5</name>
                <description>Port reset I/O pin y
These bits are write-only. A read to these bits returns the value 0.
Access can be protected by GPIOA SECy.
Note: If both BSy and BRy are set, BSy has priority.</description>
                <bitOffset>21</bitOffset>
                <bitWidth>1</bitWidth>
                <access>write-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>No action on the corresponding ODy bit</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Resets the corresponding ODy bit</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>BR6</name>
                <description>Port reset I/O pin y
These bits are write-only. A read to these bits returns the value 0.
Access can be protected by GPIOA SECy.
Note: If both BSy and BRy are set, BSy has priority.</description>
                <bitOffset>22</bitOffset>
                <bitWidth>1</bitWidth>
                <access>write-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>No action on the corresponding ODy bit</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Resets the corresponding ODy bit</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>BR7</name>
                <description>Port reset I/O pin y
These bits are write-only. A read to these bits returns the value 0.
Access can be protected by GPIOA SECy.
Note: If both BSy and BRy are set, BSy has priority.</description>
                <bitOffset>23</bitOffset>
                <bitWidth>1</bitWidth>
                <access>write-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>No action on the corresponding ODy bit</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Resets the corresponding ODy bit</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>BR8</name>
                <description>Port reset I/O pin y
These bits are write-only. A read to these bits returns the value 0.
Access can be protected by GPIOA SECy.
Note: If both BSy and BRy are set, BSy has priority.</description>
                <bitOffset>24</bitOffset>
                <bitWidth>1</bitWidth>
                <access>write-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>No action on the corresponding ODy bit</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Resets the corresponding ODy bit</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>BR9</name>
                <description>Port reset I/O pin y
These bits are write-only. A read to these bits returns the value 0.
Access can be protected by GPIOA SECy.
Note: If both BSy and BRy are set, BSy has priority.</description>
                <bitOffset>25</bitOffset>
                <bitWidth>1</bitWidth>
                <access>write-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>No action on the corresponding ODy bit</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Resets the corresponding ODy bit</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>BR10</name>
                <description>Port reset I/O pin y
These bits are write-only. A read to these bits returns the value 0.
Access can be protected by GPIOA SECy.
Note: If both BSy and BRy are set, BSy has priority.</description>
                <bitOffset>26</bitOffset>
                <bitWidth>1</bitWidth>
                <access>write-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>No action on the corresponding ODy bit</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Resets the corresponding ODy bit</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>BR11</name>
                <description>Port reset I/O pin y
These bits are write-only. A read to these bits returns the value 0.
Access can be protected by GPIOA SECy.
Note: If both BSy and BRy are set, BSy has priority.</description>
                <bitOffset>27</bitOffset>
                <bitWidth>1</bitWidth>
                <access>write-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>No action on the corresponding ODy bit</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Resets the corresponding ODy bit</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>BR12</name>
                <description>Port reset I/O pin y
These bits are write-only. A read to these bits returns the value 0.
Access can be protected by GPIOA SECy.
Note: If both BSy and BRy are set, BSy has priority.</description>
                <bitOffset>28</bitOffset>
                <bitWidth>1</bitWidth>
                <access>write-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>No action on the corresponding ODy bit</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Resets the corresponding ODy bit</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>BR13</name>
                <description>Port reset I/O pin y
These bits are write-only. A read to these bits returns the value 0.
Access can be protected by GPIOA SECy.
Note: If both BSy and BRy are set, BSy has priority.</description>
                <bitOffset>29</bitOffset>
                <bitWidth>1</bitWidth>
                <access>write-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>No action on the corresponding ODy bit</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Resets the corresponding ODy bit</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>BR14</name>
                <description>Port reset I/O pin y
These bits are write-only. A read to these bits returns the value 0.
Access can be protected by GPIOA SECy.
Note: If both BSy and BRy are set, BSy has priority.</description>
                <bitOffset>30</bitOffset>
                <bitWidth>1</bitWidth>
                <access>write-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>No action on the corresponding ODy bit</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Resets the corresponding ODy bit</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>BR15</name>
                <description>Port reset I/O pin y
These bits are write-only. A read to these bits returns the value 0.
Access can be protected by GPIOA SECy.
Note: If both BSy and BRy are set, BSy has priority.</description>
                <bitOffset>31</bitOffset>
                <bitWidth>1</bitWidth>
                <access>write-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>No action on the corresponding ODy bit</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Resets the corresponding ODy bit</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
            </fields>
          </register>
          <register>
            <name>GPIOA_LCKR</name>
            <displayName>GPIOA_LCKR</displayName>
            <description>GPIO port A configuration lock register</description>
            <addressOffset>0x01C</addressOffset>
            <size>0x20</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>LCK0</name>
                <description>Port lock I/O pin y
These bits are read/write but can only be written when the LCKK bit is 0\
Access can be protected by GPIOA SECy.</description>
                <bitOffset>0</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Port configuration not locked</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Port configuration locked</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>LCK1</name>
                <description>Port lock I/O pin y
These bits are read/write but can only be written when the LCKK bit is 0\
Access can be protected by GPIOA SECy.</description>
                <bitOffset>1</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Port configuration not locked</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Port configuration locked</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>LCK2</name>
                <description>Port lock I/O pin y
These bits are read/write but can only be written when the LCKK bit is 0\
Access can be protected by GPIOA SECy.</description>
                <bitOffset>2</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Port configuration not locked</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Port configuration locked</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>LCK3</name>
                <description>Port lock I/O pin y
These bits are read/write but can only be written when the LCKK bit is 0\
Access can be protected by GPIOA SECy.</description>
                <bitOffset>3</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Port configuration not locked</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Port configuration locked</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>LCK5</name>
                <description>Port lock I/O pin y
These bits are read/write but can only be written when the LCKK bit is 0
Access can be protected by GPIOA SECy.</description>
                <bitOffset>5</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Port configuration not locked</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Port configuration locked</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>LCK6</name>
                <description>Port lock I/O pin y
These bits are read/write but can only be written when the LCKK bit is 0
Access can be protected by GPIOA SECy.</description>
                <bitOffset>6</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Port configuration not locked</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Port configuration locked</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>LCK7</name>
                <description>Port lock I/O pin y
These bits are read/write but can only be written when the LCKK bit is 0
Access can be protected by GPIOA SECy.</description>
                <bitOffset>7</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Port configuration not locked</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Port configuration locked</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>LCK8</name>
                <description>Port lock I/O pin y
These bits are read/write but can only be written when the LCKK bit is 0
Access can be protected by GPIOA SECy.</description>
                <bitOffset>8</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Port configuration not locked</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Port configuration locked</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>LCK9</name>
                <description>Port lock I/O pin y
These bits are read/write but can only be written when the LCKK bit is 0
Access can be protected by GPIOA SECy.</description>
                <bitOffset>9</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Port configuration not locked</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Port configuration locked</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>LCK10</name>
                <description>Port lock I/O pin y
These bits are read/write but can only be written when the LCKK bit is 0
Access can be protected by GPIOA SECy.</description>
                <bitOffset>10</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Port configuration not locked</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Port configuration locked</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>LCK11</name>
                <description>Port lock I/O pin y
These bits are read/write but can only be written when the LCKK bit is 0
Access can be protected by GPIOA SECy.</description>
                <bitOffset>11</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Port configuration not locked</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Port configuration locked</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>LCK12</name>
                <description>Port lock I/O pin y
These bits are read/write but can only be written when the LCKK bit is 0
Access can be protected by GPIOA SECy.</description>
                <bitOffset>12</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Port configuration not locked</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Port configuration locked</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>LCK13</name>
                <description>Port lock I/O pin y
These bits are read/write but can only be written when the LCKK bit is 0
Access can be protected by GPIOA SECy.</description>
                <bitOffset>13</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Port configuration not locked</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Port configuration locked</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>LCK14</name>
                <description>Port lock I/O pin y
These bits are read/write but can only be written when the LCKK bit is 0
Access can be protected by GPIOA SECy.</description>
                <bitOffset>14</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Port configuration not locked</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Port configuration locked</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>LCK15</name>
                <description>Port lock I/O pin y
These bits are read/write but can only be written when the LCKK bit is 0
Access can be protected by GPIOA SECy.</description>
                <bitOffset>15</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Port configuration not locked</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Port configuration locked</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>LCKK</name>
                <description>Lock key
This bit can be read any time. It can only be modified using the lock key write sequence.
Access can be protected by any GPIOA SECy.
- LOCK key write sequence:
WR LCKR[16] = 1 + LCKR[15:0]
WR LCKR[16] = 0 + LCKR[15:0]
WR LCKR[16] = 1 + LCKR[15:0]
- LOCK key read
RD LCKR[16] = 1 (this read operation is optional but it confirms that the lock is active)
Note: During the LOCK key write sequence, the value of LCKR[15:0] must not change.
Note: Any error in the lock sequence aborts the LOCK.
Note: After the first LOCK sequence on any bit of the port, any read access on the LCKK bit returns 1 until the next MCU reset or peripheral reset.</description>
                <bitOffset>16</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Port configuration lock key not active</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Port configuration lock key active. The GPIOx_LCKR register is locked until the next MCU reset or peripheral reset.</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
            </fields>
          </register>
          <register>
            <name>GPIOA_AFRL</name>
            <displayName>GPIOA_AFRL</displayName>
            <description>GPIO port A alternate function low register</description>
            <addressOffset>0x020</addressOffset>
            <size>0x20</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>AFSEL0</name>
                <description>Alternate function selection for port I/O pin 0</description>
                <bitOffset>0</bitOffset>
                <bitWidth>4</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>AFSEL1</name>
                <description>Alternate function selection for port I/O pin 1</description>
                <bitOffset>4</bitOffset>
                <bitWidth>4</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>AFSEL2</name>
                <description>Alternate function selection for port I/O pin 2</description>
                <bitOffset>8</bitOffset>
                <bitWidth>4</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>AFSEL3</name>
                <description>Alternate function selection for port I/O pin 3</description>
                <bitOffset>12</bitOffset>
                <bitWidth>4</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>AFSEL5</name>
                <description>Alternate function selection for port I/O pin 5</description>
                <bitOffset>20</bitOffset>
                <bitWidth>4</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>AFSEL6</name>
                <description>Alternate function selection for port I/O pin 6</description>
                <bitOffset>24</bitOffset>
                <bitWidth>4</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>AFSEL7</name>
                <description>Alternate function selection for port I/O pin 7
These bits are written by software to configure alternate function I/Os.
Access can be protected by GPIOA SECy.</description>
                <bitOffset>28</bitOffset>
                <bitWidth>4</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>AF0</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>AF1</description>
                    <value>0x1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x2</name>
                    <description>AF2</description>
                    <value>0x2</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x3</name>
                    <description>AF3</description>
                    <value>0x3</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x4</name>
                    <description>AF4</description>
                    <value>0x4</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x5</name>
                    <description>AF5</description>
                    <value>0x5</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x6</name>
                    <description>AF6</description>
                    <value>0x6</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x7</name>
                    <description>AF7</description>
                    <value>0x7</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x8</name>
                    <description>AF8</description>
                    <value>0x8</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x9</name>
                    <description>AF9</description>
                    <value>0x9</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0xA</name>
                    <description>AF10</description>
                    <value>0xA</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0xB</name>
                    <description>AF11</description>
                    <value>0xB</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0xC</name>
                    <description>AF12</description>
                    <value>0xC</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0xD</name>
                    <description>AF13</description>
                    <value>0xD</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0xE</name>
                    <description>AF14</description>
                    <value>0xE</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0xF</name>
                    <description>AF15</description>
                    <value>0xF</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
            </fields>
          </register>
          <register>
            <name>GPIOA_AFRH</name>
            <displayName>GPIOA_AFRH</displayName>
            <description>GPIO port A alternate function high register</description>
            <addressOffset>0x024</addressOffset>
            <size>0x20</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>AFSEL8</name>
                <description>Alternate function selection for port I/O pin 8</description>
                <bitOffset>0</bitOffset>
                <bitWidth>4</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>AFSEL9</name>
                <description>Alternate function selection for port I/O pin 9</description>
                <bitOffset>4</bitOffset>
                <bitWidth>4</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>AFSEL10</name>
                <description>Alternate function selection for port I/O pin 10</description>
                <bitOffset>8</bitOffset>
                <bitWidth>4</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>AFSEL11</name>
                <description>Alternate function selection for port I/O pin 11</description>
                <bitOffset>12</bitOffset>
                <bitWidth>4</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>AFSEL12</name>
                <description>Alternate function selection for port I/O pin 12</description>
                <bitOffset>16</bitOffset>
                <bitWidth>4</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>AFSEL13</name>
                <description>Alternate function selection for port I/O pin 13</description>
                <bitOffset>20</bitOffset>
                <bitWidth>4</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>AFSEL14</name>
                <description>Alternate function selection for port I/O pin 14</description>
                <bitOffset>24</bitOffset>
                <bitWidth>4</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>AFSEL15</name>
                <description>Alternate function selection for port I/O pin 15
These bits are written by software to configure alternate function I/Os.
Access can be protected by GPIOA SEC15.</description>
                <bitOffset>28</bitOffset>
                <bitWidth>4</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>AF0</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>AF1</description>
                    <value>0x1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x2</name>
                    <description>AF2</description>
                    <value>0x2</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x3</name>
                    <description>AF3</description>
                    <value>0x3</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x4</name>
                    <description>AF4</description>
                    <value>0x4</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x5</name>
                    <description>AF5</description>
                    <value>0x5</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x6</name>
                    <description>AF6</description>
                    <value>0x6</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x7</name>
                    <description>AF7</description>
                    <value>0x7</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x8</name>
                    <description>AF8</description>
                    <value>0x8</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x9</name>
                    <description>AF9</description>
                    <value>0x9</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0xA</name>
                    <description>AF10</description>
                    <value>0xA</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0xB</name>
                    <description>AF11</description>
                    <value>0xB</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0xC</name>
                    <description>AF12</description>
                    <value>0xC</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0xD</name>
                    <description>AF13</description>
                    <value>0xD</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0xE</name>
                    <description>AF14</description>
                    <value>0xE</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0xF</name>
                    <description>AF15</description>
                    <value>0xF</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
            </fields>
          </register>
          <register>
            <name>GPIOA_BRR</name>
            <displayName>GPIOA_BRR</displayName>
            <description>GPIO port A bit reset register</description>
            <addressOffset>0x028</addressOffset>
            <size>0x20</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>BR0</name>
                <description>Port reset I/O pin y
These bits are write-only. A read to these bits returns the value 0.
Access can be protected by GPIOA SECy.</description>
                <bitOffset>0</bitOffset>
                <bitWidth>1</bitWidth>
                <access>write-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>No action on the corresponding ODy bit</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Reset the corresponding ODy bit</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>BR1</name>
                <description>Port reset I/O pin y
These bits are write-only. A read to these bits returns the value 0.
Access can be protected by GPIOA SECy.</description>
                <bitOffset>1</bitOffset>
                <bitWidth>1</bitWidth>
                <access>write-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>No action on the corresponding ODy bit</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Reset the corresponding ODy bit</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>BR2</name>
                <description>Port reset I/O pin y
These bits are write-only. A read to these bits returns the value 0.
Access can be protected by GPIOA SECy.</description>
                <bitOffset>2</bitOffset>
                <bitWidth>1</bitWidth>
                <access>write-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>No action on the corresponding ODy bit</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Reset the corresponding ODy bit</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>BR3</name>
                <description>Port reset I/O pin y
These bits are write-only. A read to these bits returns the value 0.
Access can be protected by GPIOA SECy.</description>
                <bitOffset>3</bitOffset>
                <bitWidth>1</bitWidth>
                <access>write-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>No action on the corresponding ODy bit</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Reset the corresponding ODy bit</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>BR5</name>
                <description>Port reset I/O pin y
These bits are write-only. A read to these bits returns the value 0.
Access can be protected by GPIOA SECy.</description>
                <bitOffset>5</bitOffset>
                <bitWidth>1</bitWidth>
                <access>write-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>No action on the corresponding ODy bit</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Reset the corresponding ODy bit</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>BR6</name>
                <description>Port reset I/O pin y
These bits are write-only. A read to these bits returns the value 0.
Access can be protected by GPIOA SECy.</description>
                <bitOffset>6</bitOffset>
                <bitWidth>1</bitWidth>
                <access>write-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>No action on the corresponding ODy bit</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Reset the corresponding ODy bit</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>BR7</name>
                <description>Port reset I/O pin y
These bits are write-only. A read to these bits returns the value 0.
Access can be protected by GPIOA SECy.</description>
                <bitOffset>7</bitOffset>
                <bitWidth>1</bitWidth>
                <access>write-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>No action on the corresponding ODy bit</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Reset the corresponding ODy bit</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>BR8</name>
                <description>Port reset I/O pin y
These bits are write-only. A read to these bits returns the value 0.
Access can be protected by GPIOA SECy.</description>
                <bitOffset>8</bitOffset>
                <bitWidth>1</bitWidth>
                <access>write-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>No action on the corresponding ODy bit</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Reset the corresponding ODy bit</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>BR9</name>
                <description>Port reset I/O pin y
These bits are write-only. A read to these bits returns the value 0.
Access can be protected by GPIOA SECy.</description>
                <bitOffset>9</bitOffset>
                <bitWidth>1</bitWidth>
                <access>write-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>No action on the corresponding ODy bit</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Reset the corresponding ODy bit</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>BR10</name>
                <description>Port reset I/O pin y
These bits are write-only. A read to these bits returns the value 0.
Access can be protected by GPIOA SECy.</description>
                <bitOffset>10</bitOffset>
                <bitWidth>1</bitWidth>
                <access>write-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>No action on the corresponding ODy bit</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Reset the corresponding ODy bit</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>BR11</name>
                <description>Port reset I/O pin y
These bits are write-only. A read to these bits returns the value 0.
Access can be protected by GPIOA SECy.</description>
                <bitOffset>11</bitOffset>
                <bitWidth>1</bitWidth>
                <access>write-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>No action on the corresponding ODy bit</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Reset the corresponding ODy bit</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>BR12</name>
                <description>Port reset I/O pin y
These bits are write-only. A read to these bits returns the value 0.
Access can be protected by GPIOA SECy.</description>
                <bitOffset>12</bitOffset>
                <bitWidth>1</bitWidth>
                <access>write-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>No action on the corresponding ODy bit</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Reset the corresponding ODy bit</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>BR13</name>
                <description>Port reset I/O pin y
These bits are write-only. A read to these bits returns the value 0.
Access can be protected by GPIOA SECy.</description>
                <bitOffset>13</bitOffset>
                <bitWidth>1</bitWidth>
                <access>write-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>No action on the corresponding ODy bit</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Reset the corresponding ODy bit</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>BR14</name>
                <description>Port reset I/O pin y
These bits are write-only. A read to these bits returns the value 0.
Access can be protected by GPIOA SECy.</description>
                <bitOffset>14</bitOffset>
                <bitWidth>1</bitWidth>
                <access>write-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>No action on the corresponding ODy bit</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Reset the corresponding ODy bit</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>BR15</name>
                <description>Port reset I/O pin y
These bits are write-only. A read to these bits returns the value 0.
Access can be protected by GPIOA SECy.</description>
                <bitOffset>15</bitOffset>
                <bitWidth>1</bitWidth>
                <access>write-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>No action on the corresponding ODy bit</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Reset the corresponding ODy bit</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
            </fields>
          </register>
          <register>
            <name>GPIOA_SECCFGR</name>
            <displayName>GPIOA_SECCFGR</displayName>
            <description>GPIO port A secure configuration register</description>
            <addressOffset>0x030</addressOffset>
            <size>0x20</size>
            <resetValue>0x0000FFFF</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>SEC0</name>
                <description>I/O pin of port secure bit enable y
These bits are written by software to enabled the security I/O port pin.</description>
                <bitOffset>0</bitOffset>
                <bitWidth>1</bitWidth>
                <access>write-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>The I/O pin is non-secure</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>The I/O pin is secure. Refer to Table 112 for all corresponding secured bits.</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>SEC1</name>
                <description>I/O pin of port secure bit enable y
These bits are written by software to enabled the security I/O port pin.</description>
                <bitOffset>1</bitOffset>
                <bitWidth>1</bitWidth>
                <access>write-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>The I/O pin is non-secure</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>The I/O pin is secure. Refer to Table 112 for all corresponding secured bits.</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>SEC2</name>
                <description>I/O pin of port secure bit enable y
These bits are written by software to enabled the security I/O port pin.</description>
                <bitOffset>2</bitOffset>
                <bitWidth>1</bitWidth>
                <access>write-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>The I/O pin is non-secure</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>The I/O pin is secure. Refer to Table 112 for all corresponding secured bits.</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>SEC3</name>
                <description>I/O pin of port secure bit enable y
These bits are written by software to enabled the security I/O port pin.</description>
                <bitOffset>3</bitOffset>
                <bitWidth>1</bitWidth>
                <access>write-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>The I/O pin is non-secure</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>The I/O pin is secure. Refer to Table 112 for all corresponding secured bits.</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>SEC5</name>
                <description>I/O pin of port secure bit enable y
These bits are written by software to enabled the security I/O port pin.</description>
                <bitOffset>5</bitOffset>
                <bitWidth>1</bitWidth>
                <access>write-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>The I/O pin is non-secure</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>The I/O pin is secure. Refer to Table 112 for all corresponding secured bits.</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>SEC6</name>
                <description>I/O pin of port secure bit enable y
These bits are written by software to enabled the security I/O port pin.</description>
                <bitOffset>6</bitOffset>
                <bitWidth>1</bitWidth>
                <access>write-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>The I/O pin is non-secure</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>The I/O pin is secure. Refer to Table 112 for all corresponding secured bits.</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>SEC7</name>
                <description>I/O pin of port secure bit enable y
These bits are written by software to enabled the security I/O port pin.</description>
                <bitOffset>7</bitOffset>
                <bitWidth>1</bitWidth>
                <access>write-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>The I/O pin is non-secure</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>The I/O pin is secure. Refer to Table 112 for all corresponding secured bits.</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>SEC8</name>
                <description>I/O pin of port secure bit enable y
These bits are written by software to enabled the security I/O port pin.</description>
                <bitOffset>8</bitOffset>
                <bitWidth>1</bitWidth>
                <access>write-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>The I/O pin is non-secure</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>The I/O pin is secure. Refer to Table 112 for all corresponding secured bits.</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>SEC9</name>
                <description>I/O pin of port secure bit enable y
These bits are written by software to enabled the security I/O port pin.</description>
                <bitOffset>9</bitOffset>
                <bitWidth>1</bitWidth>
                <access>write-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>The I/O pin is non-secure</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>The I/O pin is secure. Refer to Table 112 for all corresponding secured bits.</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>SEC10</name>
                <description>I/O pin of port secure bit enable y
These bits are written by software to enabled the security I/O port pin.</description>
                <bitOffset>10</bitOffset>
                <bitWidth>1</bitWidth>
                <access>write-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>The I/O pin is non-secure</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>The I/O pin is secure. Refer to Table 112 for all corresponding secured bits.</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>SEC11</name>
                <description>I/O pin of port secure bit enable y
These bits are written by software to enabled the security I/O port pin.</description>
                <bitOffset>11</bitOffset>
                <bitWidth>1</bitWidth>
                <access>write-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>The I/O pin is non-secure</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>The I/O pin is secure. Refer to Table 112 for all corresponding secured bits.</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>SEC12</name>
                <description>I/O pin of port secure bit enable y
These bits are written by software to enabled the security I/O port pin.</description>
                <bitOffset>12</bitOffset>
                <bitWidth>1</bitWidth>
                <access>write-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>The I/O pin is non-secure</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>The I/O pin is secure. Refer to Table 112 for all corresponding secured bits.</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>SEC13</name>
                <description>I/O pin of port secure bit enable y
These bits are written by software to enabled the security I/O port pin.</description>
                <bitOffset>13</bitOffset>
                <bitWidth>1</bitWidth>
                <access>write-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>The I/O pin is non-secure</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>The I/O pin is secure. Refer to Table 112 for all corresponding secured bits.</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>SEC14</name>
                <description>I/O pin of port secure bit enable y
These bits are written by software to enabled the security I/O port pin.</description>
                <bitOffset>14</bitOffset>
                <bitWidth>1</bitWidth>
                <access>write-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>The I/O pin is non-secure</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>The I/O pin is secure. Refer to Table 112 for all corresponding secured bits.</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>SEC15</name>
                <description>I/O pin of port secure bit enable y
These bits are written by software to enabled the security I/O port pin.</description>
                <bitOffset>15</bitOffset>
                <bitWidth>1</bitWidth>
                <access>write-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>The I/O pin is non-secure</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>The I/O pin is secure. Refer to Table 112 for all corresponding secured bits.</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
            </fields>
          </register>
        </registers>
    </peripheral>
	<peripheral derivedFrom="GPIOA">
        <name>SEC_GPIOA</name>
        <baseAddress>0x52020000</baseAddress>
    </peripheral>
    <peripheral>
        <name>GPIOB</name>
        <description>General-purpose I/Os</description>
        <groupName>GPIO</groupName>
        <baseAddress>0x42020400</baseAddress>
        <addressBlock>
          <offset>0x0</offset>
          <size>0x400</size>
          <usage>registers</usage>
        </addressBlock>
        <registers>
          <register>
            <name>GPIOB_MODER</name>
            <displayName>GPIOB_MODER</displayName>
            <description>GPIO port B mode register</description>
            <addressOffset>0x000</addressOffset>
            <size>0x20</size>
            <resetValue>0xFFFFFEBF</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>MODE0</name>
                <description>Port configuration I/O pin 0</description>
                <bitOffset>0</bitOffset>
                <bitWidth>2</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>MODE1</name>
                <description>Port configuration I/O pin 1</description>
                <bitOffset>2</bitOffset>
                <bitWidth>2</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>MODE2</name>
                <description>Port configuration I/O pin 2</description>
                <bitOffset>4</bitOffset>
                <bitWidth>2</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>MODE3</name>
                <description>Port configuration I/O pin 3</description>
                <bitOffset>6</bitOffset>
                <bitWidth>2</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>MODE4</name>
                <description>Port configuration I/O pin 4</description>
                <bitOffset>8</bitOffset>
                <bitWidth>2</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>MODE5</name>
                <description>Port configuration I/O pin 5</description>
                <bitOffset>10</bitOffset>
                <bitWidth>2</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>MODE6</name>
                <description>Port configuration I/O pin 6</description>
                <bitOffset>12</bitOffset>
                <bitWidth>2</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>MODE7</name>
                <description>Port configuration I/O pin 7</description>
                <bitOffset>14</bitOffset>
                <bitWidth>2</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>MODE8</name>
                <description>Port configuration I/O pin 8</description>
                <bitOffset>16</bitOffset>
                <bitWidth>2</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>MODE9</name>
                <description>Port configuration I/O pin 9</description>
                <bitOffset>18</bitOffset>
                <bitWidth>2</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>MODE10</name>
                <description>Port configuration I/O pin 10
Note that bits 21:20 are reserved on STM32WBA55xx devices.</description>
                <bitOffset>20</bitOffset>
                <bitWidth>2</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>MODE11</name>
                <description>Port configuration I/O pin 11</description>
                <bitOffset>22</bitOffset>
                <bitWidth>2</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>MODE12</name>
                <description>Port configuration I/O pin 12</description>
                <bitOffset>24</bitOffset>
                <bitWidth>2</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>MODE13</name>
                <description>Port configuration I/O pin 13</description>
                <bitOffset>26</bitOffset>
                <bitWidth>2</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>MODE14</name>
                <description>Port configuration I/O pin 14</description>
                <bitOffset>28</bitOffset>
                <bitWidth>2</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>MODE15</name>
                <description>Port configuration I/O pin 15
These bits are written by software to configure the I/O mode.
Access can be protected by GPIOB SEC15.</description>
                <bitOffset>30</bitOffset>
                <bitWidth>2</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Input mode</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>General purpose output mode</description>
                    <value>0x1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x2</name>
                    <description>Alternate function mode</description>
                    <value>0x2</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x3</name>
                    <description>Analog mode (reset state)</description>
                    <value>0x3</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
            </fields>
          </register>
          <register>
            <name>GPIOB_OTYPER</name>
            <displayName>GPIOB_OTYPER</displayName>
            <description>GPIO port B output type register</description>
            <addressOffset>0x004</addressOffset>
            <size>0x20</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>OT0</name>
                <description>Port configuration I/O pin y
These bits are written by software to configure the I/O output type.
Access can be protected by GPIOB SECy.
Note that bit 10 is reserved on STM32WBA55xx devices.</description>
                <bitOffset>0</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Output push-pull (reset state)</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Output open-drain</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>OT1</name>
                <description>Port configuration I/O pin y
These bits are written by software to configure the I/O output type.
Access can be protected by GPIOB SECy.
Note that bit 10 is reserved on STM32WBA55xx devices.</description>
                <bitOffset>1</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Output push-pull (reset state)</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Output open-drain</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>OT2</name>
                <description>Port configuration I/O pin y
These bits are written by software to configure the I/O output type.
Access can be protected by GPIOB SECy.
Note that bit 10 is reserved on STM32WBA55xx devices.</description>
                <bitOffset>2</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Output push-pull (reset state)</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Output open-drain</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>OT3</name>
                <description>Port configuration I/O pin y
These bits are written by software to configure the I/O output type.
Access can be protected by GPIOB SECy.
Note that bit 10 is reserved on STM32WBA55xx devices.</description>
                <bitOffset>3</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Output push-pull (reset state)</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Output open-drain</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>OT4</name>
                <description>Port configuration I/O pin y
These bits are written by software to configure the I/O output type.
Access can be protected by GPIOB SECy.
Note that bit 10 is reserved on STM32WBA55xx devices.</description>
                <bitOffset>4</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Output push-pull (reset state)</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Output open-drain</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>OT5</name>
                <description>Port configuration I/O pin y
These bits are written by software to configure the I/O output type.
Access can be protected by GPIOB SECy.
Note that bit 10 is reserved on STM32WBA55xx devices.</description>
                <bitOffset>5</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Output push-pull (reset state)</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Output open-drain</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>OT6</name>
                <description>Port configuration I/O pin y
These bits are written by software to configure the I/O output type.
Access can be protected by GPIOB SECy.
Note that bit 10 is reserved on STM32WBA55xx devices.</description>
                <bitOffset>6</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Output push-pull (reset state)</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Output open-drain</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>OT7</name>
                <description>Port configuration I/O pin y
These bits are written by software to configure the I/O output type.
Access can be protected by GPIOB SECy.
Note that bit 10 is reserved on STM32WBA55xx devices.</description>
                <bitOffset>7</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Output push-pull (reset state)</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Output open-drain</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>OT8</name>
                <description>Port configuration I/O pin y
These bits are written by software to configure the I/O output type.
Access can be protected by GPIOB SECy.
Note that bit 10 is reserved on STM32WBA55xx devices.</description>
                <bitOffset>8</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Output push-pull (reset state)</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Output open-drain</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>OT9</name>
                <description>Port configuration I/O pin y
These bits are written by software to configure the I/O output type.
Access can be protected by GPIOB SECy.
Note that bit 10 is reserved on STM32WBA55xx devices.</description>
                <bitOffset>9</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Output push-pull (reset state)</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Output open-drain</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>OT10</name>
                <description>Port configuration I/O pin y
These bits are written by software to configure the I/O output type.
Access can be protected by GPIOB SECy.
Note that bit 10 is reserved on STM32WBA55xx devices.</description>
                <bitOffset>10</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Output push-pull (reset state)</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Output open-drain</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>OT11</name>
                <description>Port configuration I/O pin y
These bits are written by software to configure the I/O output type.
Access can be protected by GPIOB SECy.
Note that bit 10 is reserved on STM32WBA55xx devices.</description>
                <bitOffset>11</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Output push-pull (reset state)</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Output open-drain</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>OT12</name>
                <description>Port configuration I/O pin y
These bits are written by software to configure the I/O output type.
Access can be protected by GPIOB SECy.
Note that bit 10 is reserved on STM32WBA55xx devices.</description>
                <bitOffset>12</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Output push-pull (reset state)</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Output open-drain</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>OT13</name>
                <description>Port configuration I/O pin y
These bits are written by software to configure the I/O output type.
Access can be protected by GPIOB SECy.
Note that bit 10 is reserved on STM32WBA55xx devices.</description>
                <bitOffset>13</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Output push-pull (reset state)</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Output open-drain</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>OT14</name>
                <description>Port configuration I/O pin y
These bits are written by software to configure the I/O output type.
Access can be protected by GPIOB SECy.
Note that bit 10 is reserved on STM32WBA55xx devices.</description>
                <bitOffset>14</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Output push-pull (reset state)</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Output open-drain</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>OT15</name>
                <description>Port configuration I/O pin y
These bits are written by software to configure the I/O output type.
Access can be protected by GPIOB SECy.
Note that bit 10 is reserved on STM32WBA55xx devices.</description>
                <bitOffset>15</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Output push-pull (reset state)</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Output open-drain</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
            </fields>
          </register>
          <register>
            <name>GPIOB_OSPEEDR</name>
            <displayName>GPIOB_OSPEEDR</displayName>
            <description>GPIO port B output speed register</description>
            <addressOffset>0x008</addressOffset>
            <size>0x20</size>
            <resetValue>0x00000080</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>OSPEED0</name>
                <description>Port configuration I/O pin 0</description>
                <bitOffset>0</bitOffset>
                <bitWidth>2</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>OSPEED1</name>
                <description>Port configuration I/O pin 1</description>
                <bitOffset>2</bitOffset>
                <bitWidth>2</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>OSPEED2</name>
                <description>Port configuration I/O pin 2</description>
                <bitOffset>4</bitOffset>
                <bitWidth>2</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>OSPEED3</name>
                <description>Port configuration I/O pin 3</description>
                <bitOffset>6</bitOffset>
                <bitWidth>2</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>OSPEED4</name>
                <description>Port configuration I/O pin 4</description>
                <bitOffset>8</bitOffset>
                <bitWidth>2</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>OSPEED5</name>
                <description>Port configuration I/O pin 5</description>
                <bitOffset>10</bitOffset>
                <bitWidth>2</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>OSPEED6</name>
                <description>Port configuration I/O pin 6</description>
                <bitOffset>12</bitOffset>
                <bitWidth>2</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>OSPEED7</name>
                <description>Port configuration I/O pin 7</description>
                <bitOffset>14</bitOffset>
                <bitWidth>2</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>OSPEED8</name>
                <description>Port configuration I/O pin 8</description>
                <bitOffset>16</bitOffset>
                <bitWidth>2</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>OSPEED9</name>
                <description>Port configuration I/O pin 9</description>
                <bitOffset>18</bitOffset>
                <bitWidth>2</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>OSPEED10</name>
                <description>Port configuration I/O pin 10
Note that bits 21:20 are reserved on STM32WBA55xx devices.</description>
                <bitOffset>20</bitOffset>
                <bitWidth>2</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>OSPEED11</name>
                <description>Port configuration I/O pin 11</description>
                <bitOffset>22</bitOffset>
                <bitWidth>2</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>OSPEED12</name>
                <description>Port configuration I/O pin 12</description>
                <bitOffset>24</bitOffset>
                <bitWidth>2</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>OSPEED13</name>
                <description>Port configuration I/O pin 13</description>
                <bitOffset>26</bitOffset>
                <bitWidth>2</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>OSPEED14</name>
                <description>Port configuration I/O pin 14</description>
                <bitOffset>28</bitOffset>
                <bitWidth>2</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>OSPEED15</name>
                <description>Port configuration I/O pin 15
These bits are written by software to configure the I/O output speed.
Access can be protected by GPIOB SEC15.
Note: Refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed.</description>
                <bitOffset>30</bitOffset>
                <bitWidth>2</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Low speed</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Medium speed</description>
                    <value>0x1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x2</name>
                    <description>High speed</description>
                    <value>0x2</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x3</name>
                    <description>Reserved</description>
                    <value>0x3</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
            </fields>
          </register>
          <register>
            <name>GPIOB_PUPDR</name>
            <displayName>GPIOB_PUPDR</displayName>
            <description>GPIO port B pull-up/pull-down register</description>
            <addressOffset>0x00C</addressOffset>
            <size>0x20</size>
            <resetValue>0x00000100</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>PUPD0</name>
                <description>Port configuration I/O pin 0</description>
                <bitOffset>0</bitOffset>
                <bitWidth>2</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>PUPD1</name>
                <description>Port configuration I/O pin 1</description>
                <bitOffset>2</bitOffset>
                <bitWidth>2</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>PUPD2</name>
                <description>Port configuration I/O pin 2</description>
                <bitOffset>4</bitOffset>
                <bitWidth>2</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>PUPD3</name>
                <description>Port configuration I/O pin 3</description>
                <bitOffset>6</bitOffset>
                <bitWidth>2</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>PUPD4</name>
                <description>Port configuration I/O pin 4</description>
                <bitOffset>8</bitOffset>
                <bitWidth>2</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>PUPD5</name>
                <description>Port configuration I/O pin 5</description>
                <bitOffset>10</bitOffset>
                <bitWidth>2</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>PUPD6</name>
                <description>Port configuration I/O pin 6</description>
                <bitOffset>12</bitOffset>
                <bitWidth>2</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>PUPD7</name>
                <description>Port configuration I/O pin 7</description>
                <bitOffset>14</bitOffset>
                <bitWidth>2</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>PUPD8</name>
                <description>Port configuration I/O pin 8</description>
                <bitOffset>16</bitOffset>
                <bitWidth>2</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>PUPD9</name>
                <description>Port configuration I/O pin 9</description>
                <bitOffset>18</bitOffset>
                <bitWidth>2</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>PUPD10</name>
                <description>Port configuration I/O pin 10
Note that bits 21:20 are reserved on STM32WBA55xx devices.</description>
                <bitOffset>20</bitOffset>
                <bitWidth>2</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>PUPD11</name>
                <description>Port configuration I/O pin 11</description>
                <bitOffset>22</bitOffset>
                <bitWidth>2</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>PUPD12</name>
                <description>Port configuration I/O pin 12</description>
                <bitOffset>24</bitOffset>
                <bitWidth>2</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>PUPD13</name>
                <description>Port configuration I/O pin 13</description>
                <bitOffset>26</bitOffset>
                <bitWidth>2</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>PUPD14</name>
                <description>Port configuration I/O pin 14</description>
                <bitOffset>28</bitOffset>
                <bitWidth>2</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>PUPD15</name>
                <description>Port configuration I/O pin 15
These bits are written by software to configure the I/O pull-up or pull-down
Access can be protected by GPIOB SEC15.</description>
                <bitOffset>30</bitOffset>
                <bitWidth>2</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>No pull-up, pull-down</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Pull-up</description>
                    <value>0x1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x2</name>
                    <description>Pull-down</description>
                    <value>0x2</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x3</name>
                    <description>Reserved</description>
                    <value>0x3</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
            </fields>
          </register>
          <register>
            <name>GPIOB_IDR</name>
            <displayName>GPIOB_IDR</displayName>
            <description>GPIO port B input data register</description>
            <addressOffset>0x010</addressOffset>
            <size>0x20</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFF0000</resetMask>
            <fields>
              <field>
                <name>ID0</name>
                <description>Port input data I/O pin y
These bits are read-only. They contain the input value of the corresponding I/O port.
Access can be protected by GPIOB SECy.
Note that bit 10 is reserved on STM32WBA55xx devices.</description>
                <bitOffset>0</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-only</access>
              </field>
              <field>
                <name>ID1</name>
                <description>Port input data I/O pin y
These bits are read-only. They contain the input value of the corresponding I/O port.
Access can be protected by GPIOB SECy.
Note that bit 10 is reserved on STM32WBA55xx devices.</description>
                <bitOffset>1</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-only</access>
              </field>
              <field>
                <name>ID2</name>
                <description>Port input data I/O pin y
These bits are read-only. They contain the input value of the corresponding I/O port.
Access can be protected by GPIOB SECy.
Note that bit 10 is reserved on STM32WBA55xx devices.</description>
                <bitOffset>2</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-only</access>
              </field>
              <field>
                <name>ID3</name>
                <description>Port input data I/O pin y
These bits are read-only. They contain the input value of the corresponding I/O port.
Access can be protected by GPIOB SECy.
Note that bit 10 is reserved on STM32WBA55xx devices.</description>
                <bitOffset>3</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-only</access>
              </field>
              <field>
                <name>ID4</name>
                <description>Port input data I/O pin y
These bits are read-only. They contain the input value of the corresponding I/O port.
Access can be protected by GPIOB SECy.
Note that bit 10 is reserved on STM32WBA55xx devices.</description>
                <bitOffset>4</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-only</access>
              </field>
              <field>
                <name>ID5</name>
                <description>Port input data I/O pin y
These bits are read-only. They contain the input value of the corresponding I/O port.
Access can be protected by GPIOB SECy.
Note that bit 10 is reserved on STM32WBA55xx devices.</description>
                <bitOffset>5</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-only</access>
              </field>
              <field>
                <name>ID6</name>
                <description>Port input data I/O pin y
These bits are read-only. They contain the input value of the corresponding I/O port.
Access can be protected by GPIOB SECy.
Note that bit 10 is reserved on STM32WBA55xx devices.</description>
                <bitOffset>6</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-only</access>
              </field>
              <field>
                <name>ID7</name>
                <description>Port input data I/O pin y
These bits are read-only. They contain the input value of the corresponding I/O port.
Access can be protected by GPIOB SECy.
Note that bit 10 is reserved on STM32WBA55xx devices.</description>
                <bitOffset>7</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-only</access>
              </field>
              <field>
                <name>ID8</name>
                <description>Port input data I/O pin y
These bits are read-only. They contain the input value of the corresponding I/O port.
Access can be protected by GPIOB SECy.
Note that bit 10 is reserved on STM32WBA55xx devices.</description>
                <bitOffset>8</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-only</access>
              </field>
              <field>
                <name>ID9</name>
                <description>Port input data I/O pin y
These bits are read-only. They contain the input value of the corresponding I/O port.
Access can be protected by GPIOB SECy.
Note that bit 10 is reserved on STM32WBA55xx devices.</description>
                <bitOffset>9</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-only</access>
              </field>
              <field>
                <name>ID10</name>
                <description>Port input data I/O pin y
These bits are read-only. They contain the input value of the corresponding I/O port.
Access can be protected by GPIOB SECy.
Note that bit 10 is reserved on STM32WBA55xx devices.</description>
                <bitOffset>10</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-only</access>
              </field>
              <field>
                <name>ID11</name>
                <description>Port input data I/O pin y
These bits are read-only. They contain the input value of the corresponding I/O port.
Access can be protected by GPIOB SECy.
Note that bit 10 is reserved on STM32WBA55xx devices.</description>
                <bitOffset>11</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-only</access>
              </field>
              <field>
                <name>ID12</name>
                <description>Port input data I/O pin y
These bits are read-only. They contain the input value of the corresponding I/O port.
Access can be protected by GPIOB SECy.
Note that bit 10 is reserved on STM32WBA55xx devices.</description>
                <bitOffset>12</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-only</access>
              </field>
              <field>
                <name>ID13</name>
                <description>Port input data I/O pin y
These bits are read-only. They contain the input value of the corresponding I/O port.
Access can be protected by GPIOB SECy.
Note that bit 10 is reserved on STM32WBA55xx devices.</description>
                <bitOffset>13</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-only</access>
              </field>
              <field>
                <name>ID14</name>
                <description>Port input data I/O pin y
These bits are read-only. They contain the input value of the corresponding I/O port.
Access can be protected by GPIOB SECy.
Note that bit 10 is reserved on STM32WBA55xx devices.</description>
                <bitOffset>14</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-only</access>
              </field>
              <field>
                <name>ID15</name>
                <description>Port input data I/O pin y
These bits are read-only. They contain the input value of the corresponding I/O port.
Access can be protected by GPIOB SECy.
Note that bit 10 is reserved on STM32WBA55xx devices.</description>
                <bitOffset>15</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-only</access>
              </field>
            </fields>
          </register>
          <register>
            <name>GPIOB_ODR</name>
            <displayName>GPIOB_ODR</displayName>
            <description>GPIO port B output data register</description>
            <addressOffset>0x014</addressOffset>
            <size>0x20</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>OD0</name>
                <description>Port output data I/O pin y
These bits can be read and written by software.
Access can be protected by GPIOB SECy.
Note that bit 10 is reserved on STM32WBA55xx devices.
Note: For atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the GPIOB_BSRR or GPIOB_BRR registers.</description>
                <bitOffset>0</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>OD1</name>
                <description>Port output data I/O pin y
These bits can be read and written by software.
Access can be protected by GPIOB SECy.
Note that bit 10 is reserved on STM32WBA55xx devices.
Note: For atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the GPIOB_BSRR or GPIOB_BRR registers.</description>
                <bitOffset>1</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>OD2</name>
                <description>Port output data I/O pin y
These bits can be read and written by software.
Access can be protected by GPIOB SECy.
Note that bit 10 is reserved on STM32WBA55xx devices.
Note: For atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the GPIOB_BSRR or GPIOB_BRR registers.</description>
                <bitOffset>2</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>OD3</name>
                <description>Port output data I/O pin y
These bits can be read and written by software.
Access can be protected by GPIOB SECy.
Note that bit 10 is reserved on STM32WBA55xx devices.
Note: For atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the GPIOB_BSRR or GPIOB_BRR registers.</description>
                <bitOffset>3</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>OD4</name>
                <description>Port output data I/O pin y
These bits can be read and written by software.
Access can be protected by GPIOB SECy.
Note that bit 10 is reserved on STM32WBA55xx devices.
Note: For atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the GPIOB_BSRR or GPIOB_BRR registers.</description>
                <bitOffset>4</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>OD5</name>
                <description>Port output data I/O pin y
These bits can be read and written by software.
Access can be protected by GPIOB SECy.
Note that bit 10 is reserved on STM32WBA55xx devices.
Note: For atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the GPIOB_BSRR or GPIOB_BRR registers.</description>
                <bitOffset>5</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>OD6</name>
                <description>Port output data I/O pin y
These bits can be read and written by software.
Access can be protected by GPIOB SECy.
Note that bit 10 is reserved on STM32WBA55xx devices.
Note: For atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the GPIOB_BSRR or GPIOB_BRR registers.</description>
                <bitOffset>6</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>OD7</name>
                <description>Port output data I/O pin y
These bits can be read and written by software.
Access can be protected by GPIOB SECy.
Note that bit 10 is reserved on STM32WBA55xx devices.
Note: For atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the GPIOB_BSRR or GPIOB_BRR registers.</description>
                <bitOffset>7</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>OD8</name>
                <description>Port output data I/O pin y
These bits can be read and written by software.
Access can be protected by GPIOB SECy.
Note that bit 10 is reserved on STM32WBA55xx devices.
Note: For atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the GPIOB_BSRR or GPIOB_BRR registers.</description>
                <bitOffset>8</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>OD9</name>
                <description>Port output data I/O pin y
These bits can be read and written by software.
Access can be protected by GPIOB SECy.
Note that bit 10 is reserved on STM32WBA55xx devices.
Note: For atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the GPIOB_BSRR or GPIOB_BRR registers.</description>
                <bitOffset>9</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>OD10</name>
                <description>Port output data I/O pin y
These bits can be read and written by software.
Access can be protected by GPIOB SECy.
Note that bit 10 is reserved on STM32WBA55xx devices.
Note: For atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the GPIOB_BSRR or GPIOB_BRR registers.</description>
                <bitOffset>10</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>OD11</name>
                <description>Port output data I/O pin y
These bits can be read and written by software.
Access can be protected by GPIOB SECy.
Note that bit 10 is reserved on STM32WBA55xx devices.
Note: For atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the GPIOB_BSRR or GPIOB_BRR registers.</description>
                <bitOffset>11</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>OD12</name>
                <description>Port output data I/O pin y
These bits can be read and written by software.
Access can be protected by GPIOB SECy.
Note that bit 10 is reserved on STM32WBA55xx devices.
Note: For atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the GPIOB_BSRR or GPIOB_BRR registers.</description>
                <bitOffset>12</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>OD13</name>
                <description>Port output data I/O pin y
These bits can be read and written by software.
Access can be protected by GPIOB SECy.
Note that bit 10 is reserved on STM32WBA55xx devices.
Note: For atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the GPIOB_BSRR or GPIOB_BRR registers.</description>
                <bitOffset>13</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>OD14</name>
                <description>Port output data I/O pin y
These bits can be read and written by software.
Access can be protected by GPIOB SECy.
Note that bit 10 is reserved on STM32WBA55xx devices.
Note: For atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the GPIOB_BSRR or GPIOB_BRR registers.</description>
                <bitOffset>14</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>OD15</name>
                <description>Port output data I/O pin y
These bits can be read and written by software.
Access can be protected by GPIOB SECy.
Note that bit 10 is reserved on STM32WBA55xx devices.
Note: For atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the GPIOB_BSRR or GPIOB_BRR registers.</description>
                <bitOffset>15</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>GPIOB_BSRR</name>
            <displayName>GPIOB_BSRR</displayName>
            <description>GPIO port B bit set/reset register</description>
            <addressOffset>0x018</addressOffset>
            <size>0x20</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>BS0</name>
                <description>Port set I/O pin y
These bits are write-only. A read to these bits returns the value 0.
Access can be protected by GPIOB SECy.
Note that bit 10 is reserved on STM32WBA55xx devices.</description>
                <bitOffset>0</bitOffset>
                <bitWidth>1</bitWidth>
                <access>write-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>No action on the corresponding ODy bit</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Sets the corresponding ODy bit</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>BS1</name>
                <description>Port set I/O pin y
These bits are write-only. A read to these bits returns the value 0.
Access can be protected by GPIOB SECy.
Note that bit 10 is reserved on STM32WBA55xx devices.</description>
                <bitOffset>1</bitOffset>
                <bitWidth>1</bitWidth>
                <access>write-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>No action on the corresponding ODy bit</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Sets the corresponding ODy bit</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>BS2</name>
                <description>Port set I/O pin y
These bits are write-only. A read to these bits returns the value 0.
Access can be protected by GPIOB SECy.
Note that bit 10 is reserved on STM32WBA55xx devices.</description>
                <bitOffset>2</bitOffset>
                <bitWidth>1</bitWidth>
                <access>write-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>No action on the corresponding ODy bit</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Sets the corresponding ODy bit</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>BS3</name>
                <description>Port set I/O pin y
These bits are write-only. A read to these bits returns the value 0.
Access can be protected by GPIOB SECy.
Note that bit 10 is reserved on STM32WBA55xx devices.</description>
                <bitOffset>3</bitOffset>
                <bitWidth>1</bitWidth>
                <access>write-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>No action on the corresponding ODy bit</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Sets the corresponding ODy bit</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>BS4</name>
                <description>Port set I/O pin y
These bits are write-only. A read to these bits returns the value 0.
Access can be protected by GPIOB SECy.
Note that bit 10 is reserved on STM32WBA55xx devices.</description>
                <bitOffset>4</bitOffset>
                <bitWidth>1</bitWidth>
                <access>write-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>No action on the corresponding ODy bit</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Sets the corresponding ODy bit</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>BS5</name>
                <description>Port set I/O pin y
These bits are write-only. A read to these bits returns the value 0.
Access can be protected by GPIOB SECy.
Note that bit 10 is reserved on STM32WBA55xx devices.</description>
                <bitOffset>5</bitOffset>
                <bitWidth>1</bitWidth>
                <access>write-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>No action on the corresponding ODy bit</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Sets the corresponding ODy bit</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>BS6</name>
                <description>Port set I/O pin y
These bits are write-only. A read to these bits returns the value 0.
Access can be protected by GPIOB SECy.
Note that bit 10 is reserved on STM32WBA55xx devices.</description>
                <bitOffset>6</bitOffset>
                <bitWidth>1</bitWidth>
                <access>write-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>No action on the corresponding ODy bit</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Sets the corresponding ODy bit</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>BS7</name>
                <description>Port set I/O pin y
These bits are write-only. A read to these bits returns the value 0.
Access can be protected by GPIOB SECy.
Note that bit 10 is reserved on STM32WBA55xx devices.</description>
                <bitOffset>7</bitOffset>
                <bitWidth>1</bitWidth>
                <access>write-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>No action on the corresponding ODy bit</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Sets the corresponding ODy bit</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>BS8</name>
                <description>Port set I/O pin y
These bits are write-only. A read to these bits returns the value 0.
Access can be protected by GPIOB SECy.
Note that bit 10 is reserved on STM32WBA55xx devices.</description>
                <bitOffset>8</bitOffset>
                <bitWidth>1</bitWidth>
                <access>write-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>No action on the corresponding ODy bit</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Sets the corresponding ODy bit</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>BS9</name>
                <description>Port set I/O pin y
These bits are write-only. A read to these bits returns the value 0.
Access can be protected by GPIOB SECy.
Note that bit 10 is reserved on STM32WBA55xx devices.</description>
                <bitOffset>9</bitOffset>
                <bitWidth>1</bitWidth>
                <access>write-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>No action on the corresponding ODy bit</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Sets the corresponding ODy bit</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>BS10</name>
                <description>Port set I/O pin y
These bits are write-only. A read to these bits returns the value 0.
Access can be protected by GPIOB SECy.
Note that bit 10 is reserved on STM32WBA55xx devices.</description>
                <bitOffset>10</bitOffset>
                <bitWidth>1</bitWidth>
                <access>write-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>No action on the corresponding ODy bit</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Sets the corresponding ODy bit</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>BS11</name>
                <description>Port set I/O pin y
These bits are write-only. A read to these bits returns the value 0.
Access can be protected by GPIOB SECy.
Note that bit 10 is reserved on STM32WBA55xx devices.</description>
                <bitOffset>11</bitOffset>
                <bitWidth>1</bitWidth>
                <access>write-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>No action on the corresponding ODy bit</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Sets the corresponding ODy bit</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>BS12</name>
                <description>Port set I/O pin y
These bits are write-only. A read to these bits returns the value 0.
Access can be protected by GPIOB SECy.
Note that bit 10 is reserved on STM32WBA55xx devices.</description>
                <bitOffset>12</bitOffset>
                <bitWidth>1</bitWidth>
                <access>write-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>No action on the corresponding ODy bit</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Sets the corresponding ODy bit</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>BS13</name>
                <description>Port set I/O pin y
These bits are write-only. A read to these bits returns the value 0.
Access can be protected by GPIOB SECy.
Note that bit 10 is reserved on STM32WBA55xx devices.</description>
                <bitOffset>13</bitOffset>
                <bitWidth>1</bitWidth>
                <access>write-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>No action on the corresponding ODy bit</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Sets the corresponding ODy bit</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>BS14</name>
                <description>Port set I/O pin y
These bits are write-only. A read to these bits returns the value 0.
Access can be protected by GPIOB SECy.
Note that bit 10 is reserved on STM32WBA55xx devices.</description>
                <bitOffset>14</bitOffset>
                <bitWidth>1</bitWidth>
                <access>write-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>No action on the corresponding ODy bit</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Sets the corresponding ODy bit</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>BS15</name>
                <description>Port set I/O pin y
These bits are write-only. A read to these bits returns the value 0.
Access can be protected by GPIOB SECy.
Note that bit 10 is reserved on STM32WBA55xx devices.</description>
                <bitOffset>15</bitOffset>
                <bitWidth>1</bitWidth>
                <access>write-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>No action on the corresponding ODy bit</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Sets the corresponding ODy bit</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>BR0</name>
                <description>Port reset I/O pin y
These bits are write-only. A read to these bits returns the value 0.
Access can be protected by GPIOB SECy.
Note that bit 26 is reserved on STM32WBA55xx devices.
Note: If both BSy and BRy are set, BSy has priority.</description>
                <bitOffset>16</bitOffset>
                <bitWidth>1</bitWidth>
                <access>write-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>No action on the corresponding ODy bit</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Resets the corresponding ODy bit</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>BR1</name>
                <description>Port reset I/O pin y
These bits are write-only. A read to these bits returns the value 0.
Access can be protected by GPIOB SECy.
Note that bit 26 is reserved on STM32WBA55xx devices.
Note: If both BSy and BRy are set, BSy has priority.</description>
                <bitOffset>17</bitOffset>
                <bitWidth>1</bitWidth>
                <access>write-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>No action on the corresponding ODy bit</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Resets the corresponding ODy bit</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>BR2</name>
                <description>Port reset I/O pin y
These bits are write-only. A read to these bits returns the value 0.
Access can be protected by GPIOB SECy.
Note that bit 26 is reserved on STM32WBA55xx devices.
Note: If both BSy and BRy are set, BSy has priority.</description>
                <bitOffset>18</bitOffset>
                <bitWidth>1</bitWidth>
                <access>write-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>No action on the corresponding ODy bit</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Resets the corresponding ODy bit</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>BR3</name>
                <description>Port reset I/O pin y
These bits are write-only. A read to these bits returns the value 0.
Access can be protected by GPIOB SECy.
Note that bit 26 is reserved on STM32WBA55xx devices.
Note: If both BSy and BRy are set, BSy has priority.</description>
                <bitOffset>19</bitOffset>
                <bitWidth>1</bitWidth>
                <access>write-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>No action on the corresponding ODy bit</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Resets the corresponding ODy bit</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>BR4</name>
                <description>Port reset I/O pin y
These bits are write-only. A read to these bits returns the value 0.
Access can be protected by GPIOB SECy.
Note that bit 26 is reserved on STM32WBA55xx devices.
Note: If both BSy and BRy are set, BSy has priority.</description>
                <bitOffset>20</bitOffset>
                <bitWidth>1</bitWidth>
                <access>write-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>No action on the corresponding ODy bit</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Resets the corresponding ODy bit</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>BR5</name>
                <description>Port reset I/O pin y
These bits are write-only. A read to these bits returns the value 0.
Access can be protected by GPIOB SECy.
Note that bit 26 is reserved on STM32WBA55xx devices.
Note: If both BSy and BRy are set, BSy has priority.</description>
                <bitOffset>21</bitOffset>
                <bitWidth>1</bitWidth>
                <access>write-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>No action on the corresponding ODy bit</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Resets the corresponding ODy bit</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>BR6</name>
                <description>Port reset I/O pin y
These bits are write-only. A read to these bits returns the value 0.
Access can be protected by GPIOB SECy.
Note that bit 26 is reserved on STM32WBA55xx devices.
Note: If both BSy and BRy are set, BSy has priority.</description>
                <bitOffset>22</bitOffset>
                <bitWidth>1</bitWidth>
                <access>write-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>No action on the corresponding ODy bit</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Resets the corresponding ODy bit</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>BR7</name>
                <description>Port reset I/O pin y
These bits are write-only. A read to these bits returns the value 0.
Access can be protected by GPIOB SECy.
Note that bit 26 is reserved on STM32WBA55xx devices.
Note: If both BSy and BRy are set, BSy has priority.</description>
                <bitOffset>23</bitOffset>
                <bitWidth>1</bitWidth>
                <access>write-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>No action on the corresponding ODy bit</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Resets the corresponding ODy bit</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>BR8</name>
                <description>Port reset I/O pin y
These bits are write-only. A read to these bits returns the value 0.
Access can be protected by GPIOB SECy.
Note that bit 26 is reserved on STM32WBA55xx devices.
Note: If both BSy and BRy are set, BSy has priority.</description>
                <bitOffset>24</bitOffset>
                <bitWidth>1</bitWidth>
                <access>write-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>No action on the corresponding ODy bit</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Resets the corresponding ODy bit</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>BR9</name>
                <description>Port reset I/O pin y
These bits are write-only. A read to these bits returns the value 0.
Access can be protected by GPIOB SECy.
Note that bit 26 is reserved on STM32WBA55xx devices.
Note: If both BSy and BRy are set, BSy has priority.</description>
                <bitOffset>25</bitOffset>
                <bitWidth>1</bitWidth>
                <access>write-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>No action on the corresponding ODy bit</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Resets the corresponding ODy bit</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>BR10</name>
                <description>Port reset I/O pin y
These bits are write-only. A read to these bits returns the value 0.
Access can be protected by GPIOB SECy.
Note that bit 26 is reserved on STM32WBA55xx devices.
Note: If both BSy and BRy are set, BSy has priority.</description>
                <bitOffset>26</bitOffset>
                <bitWidth>1</bitWidth>
                <access>write-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>No action on the corresponding ODy bit</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Resets the corresponding ODy bit</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>BR11</name>
                <description>Port reset I/O pin y
These bits are write-only. A read to these bits returns the value 0.
Access can be protected by GPIOB SECy.
Note that bit 26 is reserved on STM32WBA55xx devices.
Note: If both BSy and BRy are set, BSy has priority.</description>
                <bitOffset>27</bitOffset>
                <bitWidth>1</bitWidth>
                <access>write-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>No action on the corresponding ODy bit</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Resets the corresponding ODy bit</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>BR12</name>
                <description>Port reset I/O pin y
These bits are write-only. A read to these bits returns the value 0.
Access can be protected by GPIOB SECy.
Note that bit 26 is reserved on STM32WBA55xx devices.
Note: If both BSy and BRy are set, BSy has priority.</description>
                <bitOffset>28</bitOffset>
                <bitWidth>1</bitWidth>
                <access>write-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>No action on the corresponding ODy bit</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Resets the corresponding ODy bit</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>BR13</name>
                <description>Port reset I/O pin y
These bits are write-only. A read to these bits returns the value 0.
Access can be protected by GPIOB SECy.
Note that bit 26 is reserved on STM32WBA55xx devices.
Note: If both BSy and BRy are set, BSy has priority.</description>
                <bitOffset>29</bitOffset>
                <bitWidth>1</bitWidth>
                <access>write-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>No action on the corresponding ODy bit</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Resets the corresponding ODy bit</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>BR14</name>
                <description>Port reset I/O pin y
These bits are write-only. A read to these bits returns the value 0.
Access can be protected by GPIOB SECy.
Note that bit 26 is reserved on STM32WBA55xx devices.
Note: If both BSy and BRy are set, BSy has priority.</description>
                <bitOffset>30</bitOffset>
                <bitWidth>1</bitWidth>
                <access>write-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>No action on the corresponding ODy bit</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Resets the corresponding ODy bit</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>BR15</name>
                <description>Port reset I/O pin y
These bits are write-only. A read to these bits returns the value 0.
Access can be protected by GPIOB SECy.
Note that bit 26 is reserved on STM32WBA55xx devices.
Note: If both BSy and BRy are set, BSy has priority.</description>
                <bitOffset>31</bitOffset>
                <bitWidth>1</bitWidth>
                <access>write-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>No action on the corresponding ODy bit</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Resets the corresponding ODy bit</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
            </fields>
          </register>
          <register>
            <name>GPIOB_LCKR</name>
            <displayName>GPIOB_LCKR</displayName>
            <description>GPIO port B configuration lock register</description>
            <addressOffset>0x01C</addressOffset>
            <size>0x20</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>LCK0</name>
                <description>Port lock I/O pin y
These bits are read/write but can only be written when the LCKK bit is 0
Access can be protected by GPIOB SECy.
Note that bit 10 is reserved on STM32WBA55xx devices.</description>
                <bitOffset>0</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Port configuration not locked</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Port configuration locked</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>LCK1</name>
                <description>Port lock I/O pin y
These bits are read/write but can only be written when the LCKK bit is 0
Access can be protected by GPIOB SECy.
Note that bit 10 is reserved on STM32WBA55xx devices.</description>
                <bitOffset>1</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Port configuration not locked</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Port configuration locked</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>LCK2</name>
                <description>Port lock I/O pin y
These bits are read/write but can only be written when the LCKK bit is 0
Access can be protected by GPIOB SECy.
Note that bit 10 is reserved on STM32WBA55xx devices.</description>
                <bitOffset>2</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Port configuration not locked</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Port configuration locked</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>LCK3</name>
                <description>Port lock I/O pin y
These bits are read/write but can only be written when the LCKK bit is 0
Access can be protected by GPIOB SECy.
Note that bit 10 is reserved on STM32WBA55xx devices.</description>
                <bitOffset>3</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Port configuration not locked</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Port configuration locked</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>LCK4</name>
                <description>Port lock I/O pin y
These bits are read/write but can only be written when the LCKK bit is 0
Access can be protected by GPIOB SECy.
Note that bit 10 is reserved on STM32WBA55xx devices.</description>
                <bitOffset>4</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Port configuration not locked</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Port configuration locked</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>LCK5</name>
                <description>Port lock I/O pin y
These bits are read/write but can only be written when the LCKK bit is 0
Access can be protected by GPIOB SECy.
Note that bit 10 is reserved on STM32WBA55xx devices.</description>
                <bitOffset>5</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Port configuration not locked</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Port configuration locked</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>LCK6</name>
                <description>Port lock I/O pin y
These bits are read/write but can only be written when the LCKK bit is 0
Access can be protected by GPIOB SECy.
Note that bit 10 is reserved on STM32WBA55xx devices.</description>
                <bitOffset>6</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Port configuration not locked</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Port configuration locked</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>LCK7</name>
                <description>Port lock I/O pin y
These bits are read/write but can only be written when the LCKK bit is 0
Access can be protected by GPIOB SECy.
Note that bit 10 is reserved on STM32WBA55xx devices.</description>
                <bitOffset>7</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Port configuration not locked</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Port configuration locked</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>LCK8</name>
                <description>Port lock I/O pin y
These bits are read/write but can only be written when the LCKK bit is 0
Access can be protected by GPIOB SECy.
Note that bit 10 is reserved on STM32WBA55xx devices.</description>
                <bitOffset>8</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Port configuration not locked</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Port configuration locked</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>LCK9</name>
                <description>Port lock I/O pin y
These bits are read/write but can only be written when the LCKK bit is 0
Access can be protected by GPIOB SECy.
Note that bit 10 is reserved on STM32WBA55xx devices.</description>
                <bitOffset>9</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Port configuration not locked</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Port configuration locked</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>LCK10</name>
                <description>Port lock I/O pin y
These bits are read/write but can only be written when the LCKK bit is 0
Access can be protected by GPIOB SECy.
Note that bit 10 is reserved on STM32WBA55xx devices.</description>
                <bitOffset>10</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Port configuration not locked</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Port configuration locked</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>LCK11</name>
                <description>Port lock I/O pin y
These bits are read/write but can only be written when the LCKK bit is 0
Access can be protected by GPIOB SECy.
Note that bit 10 is reserved on STM32WBA55xx devices.</description>
                <bitOffset>11</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Port configuration not locked</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Port configuration locked</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>LCK12</name>
                <description>Port lock I/O pin y
These bits are read/write but can only be written when the LCKK bit is 0
Access can be protected by GPIOB SECy.
Note that bit 10 is reserved on STM32WBA55xx devices.</description>
                <bitOffset>12</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Port configuration not locked</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Port configuration locked</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>LCK13</name>
                <description>Port lock I/O pin y
These bits are read/write but can only be written when the LCKK bit is 0
Access can be protected by GPIOB SECy.
Note that bit 10 is reserved on STM32WBA55xx devices.</description>
                <bitOffset>13</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Port configuration not locked</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Port configuration locked</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>LCK14</name>
                <description>Port lock I/O pin y
These bits are read/write but can only be written when the LCKK bit is 0
Access can be protected by GPIOB SECy.
Note that bit 10 is reserved on STM32WBA55xx devices.</description>
                <bitOffset>14</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Port configuration not locked</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Port configuration locked</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>LCK15</name>
                <description>Port lock I/O pin y
These bits are read/write but can only be written when the LCKK bit is 0
Access can be protected by GPIOB SECy.
Note that bit 10 is reserved on STM32WBA55xx devices.</description>
                <bitOffset>15</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Port configuration not locked</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Port configuration locked</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>LCKK</name>
                <description>Lock key
This bit can be read any time. It can only be modified using the lock key write sequence.
Access can be protected by any GPIOB SECy.
- LOCK key write sequence:
WR LCKR[16] = 1 + LCKR[15:0]
WR LCKR[16] = 0 + LCKR[15:0]
WR LCKR[16] = 1 + LCKR[15:0]
- LOCK key read
RD LCKR[16] = 1 (this read operation is optional but it confirms that the lock is active)
Note: During the LOCK key write sequence, the value of LCKR[15:0] must not change.
Note: Any error in the lock sequence aborts the LOCK.
Note: After the first LOCK sequence on any bit of the port, any read access on the LCKK bit returns 1 until the next MCU reset or peripheral reset.</description>
                <bitOffset>16</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Port configuration lock key not active</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Port configuration lock key active. The GPIOx_LCKR register is locked until the next MCU reset or peripheral reset.</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
            </fields>
          </register>
          <register>
            <name>GPIOB_AFRL</name>
            <displayName>GPIOB_AFRL</displayName>
            <description>GPIO port B alternate function low register</description>
            <addressOffset>0x020</addressOffset>
            <size>0x20</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>AFSEL0</name>
                <description>Alternate function selection for port I/O pin 0</description>
                <bitOffset>0</bitOffset>
                <bitWidth>4</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>AFSEL1</name>
                <description>Alternate function selection for port I/O pin 1</description>
                <bitOffset>4</bitOffset>
                <bitWidth>4</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>AFSEL2</name>
                <description>Alternate function selection for port I/O pin 2</description>
                <bitOffset>8</bitOffset>
                <bitWidth>4</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>AFSEL3</name>
                <description>Alternate function selection for port I/O pin 3</description>
                <bitOffset>12</bitOffset>
                <bitWidth>4</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>AFSEL4</name>
                <description>Alternate function selection for port I/O pin 4</description>
                <bitOffset>16</bitOffset>
                <bitWidth>4</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>AFSEL5</name>
                <description>Alternate function selection for port I/O pin 5</description>
                <bitOffset>20</bitOffset>
                <bitWidth>4</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>AFSEL6</name>
                <description>Alternate function selection for port I/O pin 6</description>
                <bitOffset>24</bitOffset>
                <bitWidth>4</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>AFSEL7</name>
                <description>Alternate function selection for port I/O pin 7
These bits are written by software to configure alternate function I/Os.
Access can be protected by GPIOB SEC7.</description>
                <bitOffset>28</bitOffset>
                <bitWidth>4</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>AF0</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>AF1</description>
                    <value>0x1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x2</name>
                    <description>AF2</description>
                    <value>0x2</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x3</name>
                    <description>AF3</description>
                    <value>0x3</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x4</name>
                    <description>AF4</description>
                    <value>0x4</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x5</name>
                    <description>AF5</description>
                    <value>0x5</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x6</name>
                    <description>AF6</description>
                    <value>0x6</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x7</name>
                    <description>AF7</description>
                    <value>0x7</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x8</name>
                    <description>AF8</description>
                    <value>0x8</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x9</name>
                    <description>AF9</description>
                    <value>0x9</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0xA</name>
                    <description>AF10</description>
                    <value>0xA</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0xB</name>
                    <description>AF11</description>
                    <value>0xB</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0xC</name>
                    <description>AF12</description>
                    <value>0xC</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0xD</name>
                    <description>AF13</description>
                    <value>0xD</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0xE</name>
                    <description>AF14</description>
                    <value>0xE</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0xF</name>
                    <description>AF15</description>
                    <value>0xF</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
            </fields>
          </register>
          <register>
            <name>GPIOB_AFRH</name>
            <displayName>GPIOB_AFRH</displayName>
            <description>GPIO port B alternate function high register</description>
            <addressOffset>0x024</addressOffset>
            <size>0x20</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>AFSEL8</name>
                <description>Alternate function selection for port I/O pin 8</description>
                <bitOffset>0</bitOffset>
                <bitWidth>4</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>AFSEL9</name>
                <description>Alternate function selection for port I/O pin 9</description>
                <bitOffset>4</bitOffset>
                <bitWidth>4</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>AFSEL10</name>
                <description>Alternate function selection for port I/O pin 10
Note that bit 11:8 are reserved on STM32WBA55xx devices.</description>
                <bitOffset>8</bitOffset>
                <bitWidth>4</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>AFSEL11</name>
                <description>Alternate function selection for port I/O pin 11</description>
                <bitOffset>12</bitOffset>
                <bitWidth>4</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>AFSEL12</name>
                <description>Alternate function selection for port I/O pin 12</description>
                <bitOffset>16</bitOffset>
                <bitWidth>4</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>AFSEL13</name>
                <description>Alternate function selection for port I/O pin 13</description>
                <bitOffset>20</bitOffset>
                <bitWidth>4</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>AFSEL14</name>
                <description>Alternate function selection for port I/O pin 14</description>
                <bitOffset>24</bitOffset>
                <bitWidth>4</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>AFSEL15</name>
                <description>Alternate function selection for port I/O pin 15
These bits are written by software to configure alternate function I/Os.
Access can be protected by GPIOB SEC15.</description>
                <bitOffset>28</bitOffset>
                <bitWidth>4</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>AF0</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>AF1</description>
                    <value>0x1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x2</name>
                    <description>AF2</description>
                    <value>0x2</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x3</name>
                    <description>AF3</description>
                    <value>0x3</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x4</name>
                    <description>AF4</description>
                    <value>0x4</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x5</name>
                    <description>AF5</description>
                    <value>0x5</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x6</name>
                    <description>AF6</description>
                    <value>0x6</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x7</name>
                    <description>AF7</description>
                    <value>0x7</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x8</name>
                    <description>AF8</description>
                    <value>0x8</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x9</name>
                    <description>AF9</description>
                    <value>0x9</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0xA</name>
                    <description>AF10</description>
                    <value>0xA</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0xB</name>
                    <description>AF11</description>
                    <value>0xB</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0xC</name>
                    <description>AF12</description>
                    <value>0xC</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0xD</name>
                    <description>AF13</description>
                    <value>0xD</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0xE</name>
                    <description>AF14</description>
                    <value>0xE</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0xF</name>
                    <description>AF15</description>
                    <value>0xF</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
            </fields>
          </register>
          <register>
            <name>GPIOB_BRR</name>
            <displayName>GPIOB_BRR</displayName>
            <description>GPIO port B bit reset register</description>
            <addressOffset>0x028</addressOffset>
            <size>0x20</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>BR0</name>
                <description>Port reset I/O pin y
These bits are write-only. A read to these bits returns the value 0.
Access can be protected by GPIOB SECy.
Note that bit 10 is reserved on STM32WBA55xx devices.</description>
                <bitOffset>0</bitOffset>
                <bitWidth>1</bitWidth>
                <access>write-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>No action on the corresponding ODy bit</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Reset the corresponding ODy bit</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>BR1</name>
                <description>Port reset I/O pin y
These bits are write-only. A read to these bits returns the value 0.
Access can be protected by GPIOB SECy.
Note that bit 10 is reserved on STM32WBA55xx devices.</description>
                <bitOffset>1</bitOffset>
                <bitWidth>1</bitWidth>
                <access>write-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>No action on the corresponding ODy bit</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Reset the corresponding ODy bit</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>BR2</name>
                <description>Port reset I/O pin y
These bits are write-only. A read to these bits returns the value 0.
Access can be protected by GPIOB SECy.
Note that bit 10 is reserved on STM32WBA55xx devices.</description>
                <bitOffset>2</bitOffset>
                <bitWidth>1</bitWidth>
                <access>write-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>No action on the corresponding ODy bit</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Reset the corresponding ODy bit</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>BR3</name>
                <description>Port reset I/O pin y
These bits are write-only. A read to these bits returns the value 0.
Access can be protected by GPIOB SECy.
Note that bit 10 is reserved on STM32WBA55xx devices.</description>
                <bitOffset>3</bitOffset>
                <bitWidth>1</bitWidth>
                <access>write-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>No action on the corresponding ODy bit</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Reset the corresponding ODy bit</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>BR4</name>
                <description>Port reset I/O pin y
These bits are write-only. A read to these bits returns the value 0.
Access can be protected by GPIOB SECy.
Note that bit 10 is reserved on STM32WBA55xx devices.</description>
                <bitOffset>4</bitOffset>
                <bitWidth>1</bitWidth>
                <access>write-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>No action on the corresponding ODy bit</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Reset the corresponding ODy bit</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>BR5</name>
                <description>Port reset I/O pin y
These bits are write-only. A read to these bits returns the value 0.
Access can be protected by GPIOB SECy.
Note that bit 10 is reserved on STM32WBA55xx devices.</description>
                <bitOffset>5</bitOffset>
                <bitWidth>1</bitWidth>
                <access>write-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>No action on the corresponding ODy bit</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Reset the corresponding ODy bit</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>BR6</name>
                <description>Port reset I/O pin y
These bits are write-only. A read to these bits returns the value 0.
Access can be protected by GPIOB SECy.
Note that bit 10 is reserved on STM32WBA55xx devices.</description>
                <bitOffset>6</bitOffset>
                <bitWidth>1</bitWidth>
                <access>write-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>No action on the corresponding ODy bit</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Reset the corresponding ODy bit</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>BR7</name>
                <description>Port reset I/O pin y
These bits are write-only. A read to these bits returns the value 0.
Access can be protected by GPIOB SECy.
Note that bit 10 is reserved on STM32WBA55xx devices.</description>
                <bitOffset>7</bitOffset>
                <bitWidth>1</bitWidth>
                <access>write-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>No action on the corresponding ODy bit</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Reset the corresponding ODy bit</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>BR8</name>
                <description>Port reset I/O pin y
These bits are write-only. A read to these bits returns the value 0.
Access can be protected by GPIOB SECy.
Note that bit 10 is reserved on STM32WBA55xx devices.</description>
                <bitOffset>8</bitOffset>
                <bitWidth>1</bitWidth>
                <access>write-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>No action on the corresponding ODy bit</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Reset the corresponding ODy bit</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>BR9</name>
                <description>Port reset I/O pin y
These bits are write-only. A read to these bits returns the value 0.
Access can be protected by GPIOB SECy.
Note that bit 10 is reserved on STM32WBA55xx devices.</description>
                <bitOffset>9</bitOffset>
                <bitWidth>1</bitWidth>
                <access>write-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>No action on the corresponding ODy bit</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Reset the corresponding ODy bit</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>BR10</name>
                <description>Port reset I/O pin y
These bits are write-only. A read to these bits returns the value 0.
Access can be protected by GPIOB SECy.
Note that bit 10 is reserved on STM32WBA55xx devices.</description>
                <bitOffset>10</bitOffset>
                <bitWidth>1</bitWidth>
                <access>write-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>No action on the corresponding ODy bit</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Reset the corresponding ODy bit</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>BR11</name>
                <description>Port reset I/O pin y
These bits are write-only. A read to these bits returns the value 0.
Access can be protected by GPIOB SECy.
Note that bit 10 is reserved on STM32WBA55xx devices.</description>
                <bitOffset>11</bitOffset>
                <bitWidth>1</bitWidth>
                <access>write-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>No action on the corresponding ODy bit</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Reset the corresponding ODy bit</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>BR12</name>
                <description>Port reset I/O pin y
These bits are write-only. A read to these bits returns the value 0.
Access can be protected by GPIOB SECy.
Note that bit 10 is reserved on STM32WBA55xx devices.</description>
                <bitOffset>12</bitOffset>
                <bitWidth>1</bitWidth>
                <access>write-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>No action on the corresponding ODy bit</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Reset the corresponding ODy bit</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>BR13</name>
                <description>Port reset I/O pin y
These bits are write-only. A read to these bits returns the value 0.
Access can be protected by GPIOB SECy.
Note that bit 10 is reserved on STM32WBA55xx devices.</description>
                <bitOffset>13</bitOffset>
                <bitWidth>1</bitWidth>
                <access>write-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>No action on the corresponding ODy bit</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Reset the corresponding ODy bit</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>BR14</name>
                <description>Port reset I/O pin y
These bits are write-only. A read to these bits returns the value 0.
Access can be protected by GPIOB SECy.
Note that bit 10 is reserved on STM32WBA55xx devices.</description>
                <bitOffset>14</bitOffset>
                <bitWidth>1</bitWidth>
                <access>write-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>No action on the corresponding ODy bit</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Reset the corresponding ODy bit</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>BR15</name>
                <description>Port reset I/O pin y
These bits are write-only. A read to these bits returns the value 0.
Access can be protected by GPIOB SECy.
Note that bit 10 is reserved on STM32WBA55xx devices.</description>
                <bitOffset>15</bitOffset>
                <bitWidth>1</bitWidth>
                <access>write-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>No action on the corresponding ODy bit</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Reset the corresponding ODy bit</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
            </fields>
          </register>
          <register>
            <name>GPIOB_SECCFGR</name>
            <displayName>GPIOB_SECCFGR</displayName>
            <description>GPIO port B secure configuration register</description>
            <addressOffset>0x030</addressOffset>
            <size>0x20</size>
            <resetValue>0x0000FFFF</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>SEC0</name>
                <description>I/O pin of port secure bit enable y
These bits are written by software to enabled the security I/O port pin. 
Note that bit 10 is reserved on STM32WBA55xx devices.</description>
                <bitOffset>0</bitOffset>
                <bitWidth>1</bitWidth>
                <access>write-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>The I/O pin is non-secure</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>The I/O pin is secure. Refer to Table 112 for all corresponding secured bits.</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>SEC1</name>
                <description>I/O pin of port secure bit enable y
These bits are written by software to enabled the security I/O port pin. 
Note that bit 10 is reserved on STM32WBA55xx devices.</description>
                <bitOffset>1</bitOffset>
                <bitWidth>1</bitWidth>
                <access>write-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>The I/O pin is non-secure</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>The I/O pin is secure. Refer to Table 112 for all corresponding secured bits.</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>SEC2</name>
                <description>I/O pin of port secure bit enable y
These bits are written by software to enabled the security I/O port pin. 
Note that bit 10 is reserved on STM32WBA55xx devices.</description>
                <bitOffset>2</bitOffset>
                <bitWidth>1</bitWidth>
                <access>write-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>The I/O pin is non-secure</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>The I/O pin is secure. Refer to Table 112 for all corresponding secured bits.</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>SEC3</name>
                <description>I/O pin of port secure bit enable y
These bits are written by software to enabled the security I/O port pin. 
Note that bit 10 is reserved on STM32WBA55xx devices.</description>
                <bitOffset>3</bitOffset>
                <bitWidth>1</bitWidth>
                <access>write-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>The I/O pin is non-secure</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>The I/O pin is secure. Refer to Table 112 for all corresponding secured bits.</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>SEC4</name>
                <description>I/O pin of port secure bit enable y
These bits are written by software to enabled the security I/O port pin. 
Note that bit 10 is reserved on STM32WBA55xx devices.</description>
                <bitOffset>4</bitOffset>
                <bitWidth>1</bitWidth>
                <access>write-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>The I/O pin is non-secure</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>The I/O pin is secure. Refer to Table 112 for all corresponding secured bits.</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>SEC5</name>
                <description>I/O pin of port secure bit enable y
These bits are written by software to enabled the security I/O port pin. 
Note that bit 10 is reserved on STM32WBA55xx devices.</description>
                <bitOffset>5</bitOffset>
                <bitWidth>1</bitWidth>
                <access>write-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>The I/O pin is non-secure</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>The I/O pin is secure. Refer to Table 112 for all corresponding secured bits.</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>SEC6</name>
                <description>I/O pin of port secure bit enable y
These bits are written by software to enabled the security I/O port pin. 
Note that bit 10 is reserved on STM32WBA55xx devices.</description>
                <bitOffset>6</bitOffset>
                <bitWidth>1</bitWidth>
                <access>write-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>The I/O pin is non-secure</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>The I/O pin is secure. Refer to Table 112 for all corresponding secured bits.</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>SEC7</name>
                <description>I/O pin of port secure bit enable y
These bits are written by software to enabled the security I/O port pin. 
Note that bit 10 is reserved on STM32WBA55xx devices.</description>
                <bitOffset>7</bitOffset>
                <bitWidth>1</bitWidth>
                <access>write-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>The I/O pin is non-secure</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>The I/O pin is secure. Refer to Table 112 for all corresponding secured bits.</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>SEC8</name>
                <description>I/O pin of port secure bit enable y
These bits are written by software to enabled the security I/O port pin. 
Note that bit 10 is reserved on STM32WBA55xx devices.</description>
                <bitOffset>8</bitOffset>
                <bitWidth>1</bitWidth>
                <access>write-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>The I/O pin is non-secure</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>The I/O pin is secure. Refer to Table 112 for all corresponding secured bits.</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>SEC9</name>
                <description>I/O pin of port secure bit enable y
These bits are written by software to enabled the security I/O port pin. 
Note that bit 10 is reserved on STM32WBA55xx devices.</description>
                <bitOffset>9</bitOffset>
                <bitWidth>1</bitWidth>
                <access>write-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>The I/O pin is non-secure</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>The I/O pin is secure. Refer to Table 112 for all corresponding secured bits.</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>SEC10</name>
                <description>I/O pin of port secure bit enable y
These bits are written by software to enabled the security I/O port pin. 
Note that bit 10 is reserved on STM32WBA55xx devices.</description>
                <bitOffset>10</bitOffset>
                <bitWidth>1</bitWidth>
                <access>write-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>The I/O pin is non-secure</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>The I/O pin is secure. Refer to Table 112 for all corresponding secured bits.</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>SEC11</name>
                <description>I/O pin of port secure bit enable y
These bits are written by software to enabled the security I/O port pin. 
Note that bit 10 is reserved on STM32WBA55xx devices.</description>
                <bitOffset>11</bitOffset>
                <bitWidth>1</bitWidth>
                <access>write-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>The I/O pin is non-secure</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>The I/O pin is secure. Refer to Table 112 for all corresponding secured bits.</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>SEC12</name>
                <description>I/O pin of port secure bit enable y
These bits are written by software to enabled the security I/O port pin. 
Note that bit 10 is reserved on STM32WBA55xx devices.</description>
                <bitOffset>12</bitOffset>
                <bitWidth>1</bitWidth>
                <access>write-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>The I/O pin is non-secure</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>The I/O pin is secure. Refer to Table 112 for all corresponding secured bits.</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>SEC13</name>
                <description>I/O pin of port secure bit enable y
These bits are written by software to enabled the security I/O port pin. 
Note that bit 10 is reserved on STM32WBA55xx devices.</description>
                <bitOffset>13</bitOffset>
                <bitWidth>1</bitWidth>
                <access>write-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>The I/O pin is non-secure</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>The I/O pin is secure. Refer to Table 112 for all corresponding secured bits.</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>SEC14</name>
                <description>I/O pin of port secure bit enable y
These bits are written by software to enabled the security I/O port pin. 
Note that bit 10 is reserved on STM32WBA55xx devices.</description>
                <bitOffset>14</bitOffset>
                <bitWidth>1</bitWidth>
                <access>write-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>The I/O pin is non-secure</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>The I/O pin is secure. Refer to Table 112 for all corresponding secured bits.</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>SEC15</name>
                <description>I/O pin of port secure bit enable y
These bits are written by software to enabled the security I/O port pin. 
Note that bit 10 is reserved on STM32WBA55xx devices.</description>
                <bitOffset>15</bitOffset>
                <bitWidth>1</bitWidth>
                <access>write-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>The I/O pin is non-secure</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>The I/O pin is secure. Refer to Table 112 for all corresponding secured bits.</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
            </fields>
          </register>
        </registers>
    </peripheral>
	<peripheral derivedFrom="GPIOB">
        <name>SEC_GPIOB</name>
        <baseAddress>0x52020400</baseAddress>
    </peripheral>
    <peripheral>
        <name>GPIOC</name>
        <description>General-purpose I/Os</description>
        <groupName>GPIO</groupName>
        <baseAddress>0x42020800</baseAddress>
        <addressBlock>
          <offset>0x0</offset>
          <size>0x400</size>
          <usage>registers</usage>
        </addressBlock>
        <registers>
          <register>
            <name>GPIOC_MODER</name>
            <displayName>GPIOC_MODER</displayName>
            <description>GPIO port C mode register</description>
            <addressOffset>0x000</addressOffset>
            <size>0x20</size>
            <resetValue>0xFC000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>MODE13</name>
                <description>Port C configuration I/O pin 13</description>
                <bitOffset>26</bitOffset>
                <bitWidth>2</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>MODE14</name>
                <description>Port C configuration I/O pin 14</description>
                <bitOffset>28</bitOffset>
                <bitWidth>2</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>MODE15</name>
                <description>Port C configuration I/O pin 15
These bits are written by software to configure the I/O mode.
Access can be protected by GPIOC SEC15.</description>
                <bitOffset>30</bitOffset>
                <bitWidth>2</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Input mode</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>General purpose output mode</description>
                    <value>0x1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x2</name>
                    <description>Alternate function mode</description>
                    <value>0x2</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x3</name>
                    <description>Analog mode (reset state)</description>
                    <value>0x3</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
            </fields>
          </register>
          <register>
            <name>GPIOC_OTYPER</name>
            <displayName>GPIOC_OTYPER</displayName>
            <description>GPIO port C output type register</description>
            <addressOffset>0x004</addressOffset>
            <size>0x20</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>OT13</name>
                <description>Port C configuration I/O pin y
These bits are written by software to configure the I/O output type.
Access can be protected by GPIOC SECy.</description>
                <bitOffset>13</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Output push-pull (reset state)</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Output open-drain</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>OT14</name>
                <description>Port C configuration I/O pin y
These bits are written by software to configure the I/O output type.
Access can be protected by GPIOC SECy.</description>
                <bitOffset>14</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Output push-pull (reset state)</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Output open-drain</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>OT15</name>
                <description>Port C configuration I/O pin y
These bits are written by software to configure the I/O output type.
Access can be protected by GPIOC SECy.</description>
                <bitOffset>15</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Output push-pull (reset state)</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Output open-drain</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
            </fields>
          </register>
          <register>
            <name>GPIOC_OSPEEDR</name>
            <displayName>GPIOC_OSPEEDR</displayName>
            <description>GPIOC port output speed register</description>
            <addressOffset>0x008</addressOffset>
            <size>0x20</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>OSPEED13</name>
                <description>Port C configuration I/O pin 13</description>
                <bitOffset>26</bitOffset>
                <bitWidth>2</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>OSPEED14</name>
                <description>Port C configuration I/O pin 14</description>
                <bitOffset>28</bitOffset>
                <bitWidth>2</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>OSPEED15</name>
                <description>Port C configuration I/O pin 15
These bits are written by software to configure the I/O output speed.
Access can be protected by GPIOC SEC15.
Note: Refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed.</description>
                <bitOffset>30</bitOffset>
                <bitWidth>2</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Low speed</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Medium speed</description>
                    <value>0x1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x2</name>
                    <description>High speed</description>
                    <value>0x2</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x3</name>
                    <description>Reserved</description>
                    <value>0x3</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
            </fields>
          </register>
          <register>
            <name>GPIOC_PUPDR</name>
            <displayName>GPIOC_PUPDR</displayName>
            <description>GPIO port C pull-up/pull-down register</description>
            <addressOffset>0x00C</addressOffset>
            <size>0x20</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>PUPD13</name>
                <description>Port C configuration I/O pin 13</description>
                <bitOffset>26</bitOffset>
                <bitWidth>2</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>PUPD14</name>
                <description>Port C configuration I/O pin 14</description>
                <bitOffset>28</bitOffset>
                <bitWidth>2</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>PUPD15</name>
                <description>Port C configuration I/O pin 15
These bits are written by software to configure the I/O pull-up or pull-down
Access can be protected by GPIOC SEC15.</description>
                <bitOffset>30</bitOffset>
                <bitWidth>2</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>No pull-up, pull-down</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Pull-up</description>
                    <value>0x1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x2</name>
                    <description>Pull-down</description>
                    <value>0x2</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x3</name>
                    <description>Reserved</description>
                    <value>0x3</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
            </fields>
          </register>
          <register>
            <name>GPIOC_IDR</name>
            <displayName>GPIOC_IDR</displayName>
            <description>GPIO port C input data register</description>
            <addressOffset>0x010</addressOffset>
            <size>0x20</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFF0FFF</resetMask>
            <fields>
              <field>
                <name>ID13</name>
                <description>Port C input data I/O pin y
These bits are read-only. They contain the input value of the corresponding I/O port.
Access can be protected by GPIOC SECy.</description>
                <bitOffset>13</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-only</access>
              </field>
              <field>
                <name>ID14</name>
                <description>Port C input data I/O pin y
These bits are read-only. They contain the input value of the corresponding I/O port.
Access can be protected by GPIOC SECy.</description>
                <bitOffset>14</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-only</access>
              </field>
              <field>
                <name>ID15</name>
                <description>Port C input data I/O pin y
These bits are read-only. They contain the input value of the corresponding I/O port.
Access can be protected by GPIOC SECy.</description>
                <bitOffset>15</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-only</access>
              </field>
            </fields>
          </register>
          <register>
            <name>GPIOC_ODR</name>
            <displayName>GPIOC_ODR</displayName>
            <description>GPIO port C output data register</description>
            <addressOffset>0x014</addressOffset>
            <size>0x20</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>OD13</name>
                <description>Port C output data I/O pin y
These bits can be read and written by software.
Access can be protected by GPIOC SECy.
Note: For atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the GPIOC_BSRR or GPIOC_BRR registers.</description>
                <bitOffset>13</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>OD14</name>
                <description>Port C output data I/O pin y
These bits can be read and written by software.
Access can be protected by GPIOC SECy.
Note: For atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the GPIOC_BSRR or GPIOC_BRR registers.</description>
                <bitOffset>14</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>OD15</name>
                <description>Port C output data I/O pin y
These bits can be read and written by software.
Access can be protected by GPIOC SECy.
Note: For atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the GPIOC_BSRR or GPIOC_BRR registers.</description>
                <bitOffset>15</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>GPIOC_BSRR</name>
            <displayName>GPIOC_BSRR</displayName>
            <description>GPIO port C bit set/reset register</description>
            <addressOffset>0x018</addressOffset>
            <size>0x20</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>BS13</name>
                <description>Port C set I/O pin y
These bits are write-only. A read to these bits returns the value 0.
Access can be protected by GPIOC SECy.</description>
                <bitOffset>13</bitOffset>
                <bitWidth>1</bitWidth>
                <access>write-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>No action on the corresponding ODy bit</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Sets the corresponding ODy bit</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>BS14</name>
                <description>Port C set I/O pin y
These bits are write-only. A read to these bits returns the value 0.
Access can be protected by GPIOC SECy.</description>
                <bitOffset>14</bitOffset>
                <bitWidth>1</bitWidth>
                <access>write-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>No action on the corresponding ODy bit</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Sets the corresponding ODy bit</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>BS15</name>
                <description>Port C set I/O pin y
These bits are write-only. A read to these bits returns the value 0.
Access can be protected by GPIOC SECy.</description>
                <bitOffset>15</bitOffset>
                <bitWidth>1</bitWidth>
                <access>write-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>No action on the corresponding ODy bit</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Sets the corresponding ODy bit</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>BR13</name>
                <description>Port C reset I/O pin y
These bits are write-only. A read to these bits returns the value 0.
Access can be protected by GPIOC SECy.
Note: If both BSy and BRy are set, BSy has priority.</description>
                <bitOffset>29</bitOffset>
                <bitWidth>1</bitWidth>
                <access>write-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>No action on the corresponding ODy bit</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Resets the corresponding ODy bit</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>BR14</name>
                <description>Port C reset I/O pin y
These bits are write-only. A read to these bits returns the value 0.
Access can be protected by GPIOC SECy.
Note: If both BSy and BRy are set, BSy has priority.</description>
                <bitOffset>30</bitOffset>
                <bitWidth>1</bitWidth>
                <access>write-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>No action on the corresponding ODy bit</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Resets the corresponding ODy bit</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>BR15</name>
                <description>Port C reset I/O pin y
These bits are write-only. A read to these bits returns the value 0.
Access can be protected by GPIOC SECy.
Note: If both BSy and BRy are set, BSy has priority.</description>
                <bitOffset>31</bitOffset>
                <bitWidth>1</bitWidth>
                <access>write-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>No action on the corresponding ODy bit</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Resets the corresponding ODy bit</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
            </fields>
          </register>
          <register>
            <name>GPIOC_LCKR</name>
            <displayName>GPIOC_LCKR</displayName>
            <description>GPIO port C configuration lock register</description>
            <addressOffset>0x01C</addressOffset>
            <size>0x20</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>LCK13</name>
                <description>Port C lock I/O pin y
These bits are read/write but can only be written when the LCKK bit is 0
Access can be protected by GPIOC SECy.</description>
                <bitOffset>13</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Port configuration not locked</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Port configuration locked</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>LCK14</name>
                <description>Port C lock I/O pin y
These bits are read/write but can only be written when the LCKK bit is 0
Access can be protected by GPIOC SECy.</description>
                <bitOffset>14</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Port configuration not locked</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Port configuration locked</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>LCK15</name>
                <description>Port C lock I/O pin y
These bits are read/write but can only be written when the LCKK bit is 0
Access can be protected by GPIOC SECy.</description>
                <bitOffset>15</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Port configuration not locked</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Port configuration locked</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>LCKK</name>
                <description>Lock key
This bit can be read any time. It can only be modified using the lock key write sequence.
Access is protected by any GPIOC SECy.
- LOCK key write sequence:
WR LCKR[16] = 1 + LCKR[15:13]
WR LCKR[16] = 0 + LCKR[15:13]
WR LCKR[16] = 1 + LCKR[15:13]
- LOCK key read
RD LCKR[16] = 1 (this read operation is optional but it confirms that the lock is active)
Note: During the LOCK key write sequence, the value of LCK[15:13] must not change.
Note: Any error in the lock sequence aborts the LOCK.
Note: After the first LOCK sequence on any bit of the port, any read access on the LCKK bit returns 1 until the next MCU reset or peripheral reset.</description>
                <bitOffset>16</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Port configuration lock key not active</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Port configuration lock key active. The GPIOC_LCKR register is locked until the next MCU reset or peripheral reset.</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
            </fields>
          </register>
          <register>
            <name>GPIOC_AFRH</name>
            <displayName>GPIOC_AFRH</displayName>
            <description>GPIO port C alternate function high register</description>
            <addressOffset>0x024</addressOffset>
            <size>0x20</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>AFSEL13</name>
                <description>Alternate function selection for port C I/O pin 13</description>
                <bitOffset>20</bitOffset>
                <bitWidth>4</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>AFSEL14</name>
                <description>Alternate function selection for port C I/O pin 14</description>
                <bitOffset>24</bitOffset>
                <bitWidth>4</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>AFSEL15</name>
                <description>Alternate function selection for port C I/O pin 15
These bits are written by software to configure alternate function I/Os.
Access can be protected by GPIOC SEC15.</description>
                <bitOffset>28</bitOffset>
                <bitWidth>4</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>AF0</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>AF1</description>
                    <value>0x1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x2</name>
                    <description>AF2</description>
                    <value>0x2</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x3</name>
                    <description>AF3</description>
                    <value>0x3</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x4</name>
                    <description>AF4</description>
                    <value>0x4</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x5</name>
                    <description>AF5</description>
                    <value>0x5</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x6</name>
                    <description>AF6</description>
                    <value>0x6</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x7</name>
                    <description>AF7</description>
                    <value>0x7</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x8</name>
                    <description>AF8</description>
                    <value>0x8</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x9</name>
                    <description>AF9</description>
                    <value>0x9</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0xA</name>
                    <description>AF10</description>
                    <value>0xA</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0xB</name>
                    <description>AF11</description>
                    <value>0xB</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0xC</name>
                    <description>AF12</description>
                    <value>0xC</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0xD</name>
                    <description>AF13</description>
                    <value>0xD</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0xE</name>
                    <description>AF14</description>
                    <value>0xE</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0xF</name>
                    <description>AF15</description>
                    <value>0xF</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
            </fields>
          </register>
          <register>
            <name>GPIOC_BRR</name>
            <displayName>GPIOC_BRR</displayName>
            <description>GPIO port C bit reset register</description>
            <addressOffset>0x028</addressOffset>
            <size>0x20</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>BR13</name>
                <description>Port reset I/O pin y
These bits are write-only. A read to these bits returns the value 0.
Access can be protected by GPIOC SECy.</description>
                <bitOffset>13</bitOffset>
                <bitWidth>1</bitWidth>
                <access>write-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>No action on the corresponding ODy bit</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Reset the corresponding ODy bit</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>BR14</name>
                <description>Port reset I/O pin y
These bits are write-only. A read to these bits returns the value 0.
Access can be protected by GPIOC SECy.</description>
                <bitOffset>14</bitOffset>
                <bitWidth>1</bitWidth>
                <access>write-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>No action on the corresponding ODy bit</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Reset the corresponding ODy bit</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>BR15</name>
                <description>Port reset I/O pin y
These bits are write-only. A read to these bits returns the value 0.
Access can be protected by GPIOC SECy.</description>
                <bitOffset>15</bitOffset>
                <bitWidth>1</bitWidth>
                <access>write-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>No action on the corresponding ODy bit</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Reset the corresponding ODy bit</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
            </fields>
          </register>
          <register>
            <name>GPIOC_SECCFGR</name>
            <displayName>GPIOC_SECCFGR</displayName>
            <description>GPIO port C secure configuration register</description>
            <addressOffset>0x030</addressOffset>
            <size>0x20</size>
            <resetValue>0x0000FFFF</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>SEC13</name>
                <description>I/O pin of port C secure bit enable y
These bits are written by software to enabled the security I/O port pin.</description>
                <bitOffset>13</bitOffset>
                <bitWidth>1</bitWidth>
                <access>write-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>The I/O pin is non-secure</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>The I/O pin is secure. Refer to Table 112 for all corresponding secured bits.</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>SEC14</name>
                <description>I/O pin of port C secure bit enable y
These bits are written by software to enabled the security I/O port pin.</description>
                <bitOffset>14</bitOffset>
                <bitWidth>1</bitWidth>
                <access>write-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>The I/O pin is non-secure</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>The I/O pin is secure. Refer to Table 112 for all corresponding secured bits.</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>SEC15</name>
                <description>I/O pin of port C secure bit enable y
These bits are written by software to enabled the security I/O port pin.</description>
                <bitOffset>15</bitOffset>
                <bitWidth>1</bitWidth>
                <access>write-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>The I/O pin is non-secure</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>The I/O pin is secure. Refer to Table 112 for all corresponding secured bits.</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
            </fields>
          </register>
        </registers>
    </peripheral>
	<peripheral derivedFrom="GPIOC">
        <name>SEC_GPIOC</name>
        <baseAddress>0x52020800</baseAddress>
    </peripheral>
    <peripheral>
        <name>GPIOH</name>
        <description>General-purpose I/Os</description>
        <groupName>GPIO</groupName>
        <baseAddress>0x42021C00</baseAddress>
        <addressBlock>
          <offset>0x0</offset>
          <size>0x400</size>
          <usage>registers</usage>
        </addressBlock>
        <registers>
          <register>
            <name>GPIOH_MODER</name>
            <displayName>GPIOH_MODER</displayName>
            <description>GPIO port H mode register</description>
            <addressOffset>0x000</addressOffset>
            <size>0x20</size>
            <resetValue>0x0000C000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>MODE3</name>
                <description>Port H configuration I/O pin 3
These bits are written by software to configure the I/O mode.
Access can be protected by GPIOH SEC3.</description>
                <bitOffset>6</bitOffset>
                <bitWidth>2</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Input mode</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>General purpose output mode</description>
                    <value>0x1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x2</name>
                    <description>Alternate function mode</description>
                    <value>0x2</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x3</name>
                    <description>Analog mode (reset state)</description>
                    <value>0x3</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
            </fields>
          </register>
          <register>
            <name>GPIOH_OTYPER</name>
            <displayName>GPIOH_OTYPER</displayName>
            <description>GPIO port H output type register</description>
            <addressOffset>0x004</addressOffset>
            <size>0x20</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>OT3</name>
                <description>Port H configuration I/O pin 3
This bit is written by software to configure the I/O output type.
Access can be protected by GPIOH SEC3.</description>
                <bitOffset>3</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Output push-pull (reset state)</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Output open-drain</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
            </fields>
          </register>
          <register>
            <name>GPIOH_OSPEEDR</name>
            <displayName>GPIOH_OSPEEDR</displayName>
            <description>GPIO port H output speed register</description>
            <addressOffset>0x008</addressOffset>
            <size>0x20</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>OSPEED3</name>
                <description>Port H configuration I/O pin 3
These bits are written by software to configure the I/O output speed.
Access can be protected by GPIOH SEC3.
Note: Refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed.</description>
                <bitOffset>6</bitOffset>
                <bitWidth>2</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Low speed</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Medium speed</description>
                    <value>0x1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x2</name>
                    <description>High speed</description>
                    <value>0x2</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x3</name>
                    <description>Reserved</description>
                    <value>0x3</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
            </fields>
          </register>
          <register>
            <name>GPIOH_PUPDR</name>
            <displayName>GPIOH_PUPDR</displayName>
            <description>GPIO port H pull-up/pull-down register</description>
            <addressOffset>0x00C</addressOffset>
            <size>0x20</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>PUPD3</name>
                <description>Port H configuration I/O pin 3
These bits are written by software to configure the I/O pull-up or pull-down
Access can be protected by GPIOH SEC3.</description>
                <bitOffset>6</bitOffset>
                <bitWidth>2</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>No pull-up, pull-down</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Pull-up</description>
                    <value>0x1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x2</name>
                    <description>Pull-down</description>
                    <value>0x2</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x3</name>
                    <description>Reserved</description>
                    <value>0x3</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
            </fields>
          </register>
          <register>
            <name>GPIOH_IDR</name>
            <displayName>GPIOH_IDR</displayName>
            <description>GPIO port H input data register</description>
            <addressOffset>0x010</addressOffset>
            <size>0x20</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFF0000</resetMask>
            <fields>
              <field>
                <name>ID3</name>
                <description>Port H input data I/O pin 3
This bit is read-only. It contain the input value of the corresponding I/O port.
Access can be protected by GPIOH SEC3.</description>
                <bitOffset>3</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-only</access>
              </field>
            </fields>
          </register>
          <register>
            <name>GPIOH_ODR</name>
            <displayName>GPIOH_ODR</displayName>
            <description>GPIO port H output data register</description>
            <addressOffset>0x014</addressOffset>
            <size>0x20</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>OD3</name>
                <description>Port H output data I/O pin 3
This bits can be read and written by software.
Access can be protected by GPIOH SEC3.
Note: For atomic bit set/reset, the OD bit can be individually set and/or reset by writing to the GPIOH_BSRR or GPIOH_BRR registers.</description>
                <bitOffset>3</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>GPIOH_BSRR</name>
            <displayName>GPIOH_BSRR</displayName>
            <description>GPIO port H bit set/reset register</description>
            <addressOffset>0x018</addressOffset>
            <size>0x20</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>BS3</name>
                <description>Port H set I/O pin 3
This bit is write-only. A read to this bit returns the value 0.
Access can be protected by GPIOH SEC3.</description>
                <bitOffset>3</bitOffset>
                <bitWidth>1</bitWidth>
                <access>write-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>No action on the corresponding OD3 bit</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Sets the corresponding OD3 bit</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>BR3</name>
                <description>Port H reset I/O pin 3
This bit is write-only. A read to this bit returns the value 0.
Access can be protected by GPIOH SEC3.
Note: If both BS3 and BR3 are set, BS3 has priority.</description>
                <bitOffset>19</bitOffset>
                <bitWidth>1</bitWidth>
                <access>write-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>No action on the corresponding OD3 bit</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Resets the corresponding OD3 bit</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
            </fields>
          </register>
          <register>
            <name>GPIOH_LCKR</name>
            <displayName>GPIOH_LCKR</displayName>
            <description>GPIO port H configuration lock register</description>
            <addressOffset>0x01C</addressOffset>
            <size>0x20</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>LCK3</name>
                <description>Port H lock I/O pin 3
This bit is read/write but can only be written when the LCKK bit is 0
Access can be protected by GPIOH SEC3.</description>
                <bitOffset>3</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Port configuration not locked</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Port configuration locked</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>LCKK</name>
                <description>Lock key
This bit can be read any time. It can only be modified using the lock key write sequence.
Access is protected by GPIOH SEC3.
- LOCK key write sequence:
WR LCKR[16] = 1 + LCKR[3]
WR LCKR[16] = 0 + LCKR[3]
WR LCKR[16] = 1 + LCKR[3]
- LOCK key read
RD LCKR[16] = 1 (this read operation is optional but it confirms that the lock is active)
Note: During the LOCK key write sequence, the value of LCK3 must not change.
Note: Any error in the lock sequence aborts the LOCK.
Note: After the first LOCK sequence on any bit of the port, any read access on the LCKK bit returns 1 until the next MCU reset or peripheral reset.</description>
                <bitOffset>16</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Port configuration lock key not active</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Port configuration lock key active. The GPIOH_LCKR register is locked until the next MCU reset or peripheral reset.</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
            </fields>
          </register>
          <register>
            <name>GPIOH_AFRL</name>
            <displayName>GPIOH_AFRL</displayName>
            <description>GPIO port H alternate function low register</description>
            <addressOffset>0x020</addressOffset>
            <size>0x20</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>AFSEL3</name>
                <description>Alternate function selection for port H I/O pin 3
These bits are written by software to configure alternate function I/Os.
Access can be protected by GPIOH SEC3.</description>
                <bitOffset>12</bitOffset>
                <bitWidth>4</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>AF0</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>AF1</description>
                    <value>0x1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x2</name>
                    <description>AF2</description>
                    <value>0x2</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x3</name>
                    <description>AF3</description>
                    <value>0x3</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x4</name>
                    <description>AF4</description>
                    <value>0x4</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x5</name>
                    <description>AF5</description>
                    <value>0x5</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x6</name>
                    <description>AF6</description>
                    <value>0x6</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x7</name>
                    <description>AF7</description>
                    <value>0x7</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x8</name>
                    <description>AF8</description>
                    <value>0x8</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x9</name>
                    <description>AF9</description>
                    <value>0x9</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0xA</name>
                    <description>AF10</description>
                    <value>0xA</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0xB</name>
                    <description>AF11</description>
                    <value>0xB</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0xC</name>
                    <description>AF12</description>
                    <value>0xC</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0xD</name>
                    <description>AF13</description>
                    <value>0xD</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0xE</name>
                    <description>AF14</description>
                    <value>0xE</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0xF</name>
                    <description>AF15</description>
                    <value>0xF</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
            </fields>
          </register>
          <register>
            <name>GPIOH_BRR</name>
            <displayName>GPIOH_BRR</displayName>
            <description>GPIO port H bit reset register</description>
            <addressOffset>0x028</addressOffset>
            <size>0x20</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>BR3</name>
                <description>Port H reset I/O pin 3
This bit is write-only. A read to this bit returns the value 0.
Access can be protected by GPIOH SEC3.</description>
                <bitOffset>3</bitOffset>
                <bitWidth>1</bitWidth>
                <access>write-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>No action on the corresponding OD3 bit</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Reset the corresponding OD3 bit</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
            </fields>
          </register>
          <register>
            <name>GPIOH_SECCFGR</name>
            <displayName>GPIOH_SECCFGR</displayName>
            <description>GPIO port H secure configuration register</description>
            <addressOffset>0x030</addressOffset>
            <size>0x20</size>
            <resetValue>0x0000FFFF</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>SEC3</name>
                <description>I/O pin of port H secure bit enable 3
This bit is written by software to enabled the security I/O port pin.</description>
                <bitOffset>3</bitOffset>
                <bitWidth>1</bitWidth>
                <access>write-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>The I/O pin is non-secure</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>The I/O pin is secure. Refer to Table 112 for all corresponding secured bits.</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
            </fields>
          </register>
        </registers>
    </peripheral>
	<peripheral derivedFrom="GPIOH">
        <name>SEC_GPIOH</name>
        <baseAddress>0x52021C00</baseAddress>
    </peripheral>
	<peripheral>
      <name>GTZC1_TZSC</name>
      <description>GTZC1_TZSC</description>
      <groupName>GTZC</groupName>
      <baseAddress>0x40032400</baseAddress>
      <addressBlock>
        <offset>0x0</offset>
        <size>0x400</size>
        <usage>registers</usage>
      </addressBlock>
      <registers>
	     <register>
            <name>GTZC1_TZSC_CR</name>
            <displayName>GTZC1_TZSC_CR</displayName>
            <description>GTZC1 TZSC control register</description>
            <addressOffset>0x000</addressOffset>
            <size>0x20</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>LCK</name>
                <description>lock the configuration of GTZC1_TZSC_SECCFGRn and GTZC1_TZSC_PRIVCFGRn registers until next reset
This bit is cleared by default and once set, it can not be reset until system reset.</description>
                <bitOffset>0</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>configuration of all GTZC1_TZSC_SECCFGRn and GTZC1_TZSC_PRIVCFGRn registers not locked</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>configuration of all GTZC1_TZSC_SECCFGRn and GTZC1_TZSC_PRIVCFGRn registers locked</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
            </fields>
          </register>
		  <register>
            <name>GTZC1_TZSC_SECCFGR1</name>
            <displayName>GTZC1_TZSC_SECCFGR1</displayName>
            <description>GTZC1 TZSC secure configuration register 1</description>
            <addressOffset>0x010</addressOffset>
            <size>0x20</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>TIM2SEC</name>
                <description>secure access mode for TIM2</description>
                <bitOffset>0</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>non-secure</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>secure</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>TIM3SEC</name>
                <description>secure access mode for TIM3</description>
                <bitOffset>1</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>non-secure</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>secure</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>WWDGSEC</name>
                <description>secure access mode for WWDG</description>
                <bitOffset>6</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>non-secure</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>secure</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>IWDGSEC</name>
                <description>secure access mode for IWDG</description>
                <bitOffset>7</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>non-secure</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>secure</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>USART2SEC</name>
                <description>secure access mode for USART2</description>
                <bitOffset>9</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>non-secure</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>secure</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>I2C1SEC</name>
                <description>secure access mode for I2C1</description>
                <bitOffset>13</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>non-secure</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>secure</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>LPTIM2SEC</name>
                <description>secure access mode for LPTIM2</description>
                <bitOffset>17</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>non-secure</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>secure</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
            </fields>
          </register>
		  <register>
            <name>GTZC1_TZSC_SECCFGR2</name>
            <displayName>GTZC1_TZSC_SECCFGR2</displayName>
            <description>GTZC1 TZSC secure configuration register 2</description>
            <addressOffset>0x014</addressOffset>
            <size>0x20</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>TIM1SEC</name>
                <description>secure access mode for TIM1</description>
                <bitOffset>0</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>non-secure</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>secure</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>SPI1SEC</name>
                <description>secure access mode for SPI1</description>
                <bitOffset>1</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>non-secure</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>secure</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>USART1SEC</name>
                <description>secure access mode for USART1</description>
                <bitOffset>3</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>non-secure</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>secure</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>TIM16SEC</name>
                <description>secure access mode for TIM16</description>
                <bitOffset>5</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>non-secure</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>secure</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>TIM17SEC</name>
                <description>secure access mode for TIM17</description>
                <bitOffset>6</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>non-secure</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>secure</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>SPI3SEC</name>
                <description>secure access mode for SPI3</description>
                <bitOffset>16</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>non-secure</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>secure</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>LPUART1SEC</name>
                <description>secure access mode for LPUART1</description>
                <bitOffset>17</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>non-secure</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>secure</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>I2C3SEC</name>
                <description>secure access mode for I2C3</description>
                <bitOffset>18</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>non-secure</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>secure</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>LPTIM1SEC</name>
                <description>secure access mode for LPTIM1</description>
                <bitOffset>19</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>non-secure</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>secure</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>COMPSEC</name>
                <description>secure access mode for COMP
Note that bit 23 is reserved on sales type STM32WBA52.</description>
                <bitOffset>23</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>non-secure</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>secure</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>ADC4SEC</name>
                <description>secure access mode for ADC4</description>
                <bitOffset>24</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>non-secure</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>secure</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
            </fields>
          </register>
		  <register>
            <name>GTZC1_TZSC_SECCFGR3</name>
            <displayName>GTZC1_TZSC_SECCFGR3</displayName>
            <description>GTZC1 TZSC secure configuration register 3</description>
            <addressOffset>0x018</addressOffset>
            <size>0x20</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>CRCSEC</name>
                <description>secure access mode for CRC</description>
                <bitOffset>3</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>non-secure</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>secure</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>TSCSEC</name>
                <description>secure access mode for TSC</description>
                <bitOffset>4</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>non-secure</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>secure</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>ICACHE_REGSEC</name>
                <description>secure access mode for ICACHE registers</description>
                <bitOffset>6</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>non-secure</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>secure</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>AESSEC</name>
                <description>secure access mode for AES</description>
                <bitOffset>11</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>non-secure</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>secure</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>HASHSEC</name>
                <description>secure access mode for HASH</description>
                <bitOffset>12</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>non-secure</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>secure</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>RNGSEC</name>
                <description>secure access mode for RNG</description>
                <bitOffset>13</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>non-secure</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>secure</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>SAESSEC</name>
                <description>secure access mode for SAES</description>
                <bitOffset>14</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>non-secure</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>secure</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>PKASEC</name>
                <description>secure access mode for PKA</description>
                <bitOffset>16</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>non-secure</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>secure</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>RAMCFGSEC</name>
                <description>secure access mode for RAMCFG</description>
                <bitOffset>22</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>non-secure</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>secure</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>RADIOSEC</name>
                <description>secure access mode for 2.4 GHz RADIO</description>
                <bitOffset>23</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>non-secure</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>secure</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
            </fields>
          </register>
		  <register>
            <name>GTZC1_TZSC_PRIVCFGR1</name>
            <displayName>GTZC1_TZSC_PRIVCFGR1</displayName>
            <description>GTZC1 TZSC privilege configuration register 1</description>
            <addressOffset>0x020</addressOffset>
            <size>0x20</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>TIM2PRIV</name>
                <description>privileged access mode for TIM2</description>
                <bitOffset>0</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>unprivileged</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>privileged</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>TIM3PRIV</name>
                <description>privileged access mode for TIM3</description>
                <bitOffset>1</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>unprivileged</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>privileged</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>WWDGPRIV</name>
                <description>privileged access mode for WWDG</description>
                <bitOffset>6</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>unprivileged</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>privileged</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>IWDGPRIV</name>
                <description>privileged access mode for IWDG</description>
                <bitOffset>7</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>unprivileged</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>privileged</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>USART2PRIV</name>
                <description>privileged access mode for USART2</description>
                <bitOffset>9</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>unprivileged</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>privileged</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>I2C1PRIV</name>
                <description>privileged access mode for I2C1</description>
                <bitOffset>13</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>unprivileged</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>privileged</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>LPTIM2PRIV</name>
                <description>privileged access mode for LPTIM2</description>
                <bitOffset>17</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>unprivileged</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>privileged</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
            </fields>
          </register>
		  <register>
            <name>GTZC1_TZSC_PRIVCFGR2</name>
            <displayName>GTZC1_TZSC_PRIVCFGR2</displayName>
            <description>GTZC1 TZSC privilege configuration register 2</description>
            <addressOffset>0x024</addressOffset>
            <size>0x20</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>TIM1PRIV</name>
                <description>privileged access mode for TIM1</description>
                <bitOffset>0</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>unprivileged</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>privileged</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>SPI1PRIV</name>
                <description>privileged access mode for SPI1PRIV</description>
                <bitOffset>1</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>unprivileged</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>privileged</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>USART1PRIV</name>
                <description>privileged access mode for USART1</description>
                <bitOffset>3</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>unprivileged</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>privileged</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>TIM16PRIV</name>
                <description>privileged access mode for TIM16</description>
                <bitOffset>5</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>unprivileged</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>privileged</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>TIM17PRIV</name>
                <description>privileged access mode for TIM17</description>
                <bitOffset>6</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>unprivileged</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>privileged</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>SPI3PRIV</name>
                <description>privileged access mode for SPI3</description>
                <bitOffset>16</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>unprivileged</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>privileged</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>LPUART1PRIV</name>
                <description>privileged access mode for LPUART1</description>
                <bitOffset>17</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>unprivileged</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>privileged</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>I2C3PRIV</name>
                <description>privileged access mode for I2C3</description>
                <bitOffset>18</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>unprivileged</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>privileged</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>LPTIM1PRIV</name>
                <description>privileged access mode for LPTIM1</description>
                <bitOffset>19</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>unprivileged</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>privileged</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>COMPPRIV</name>
                <description>privileged access mode for COMP
Note that bit 23 is reserved on sales type STM32WBA52.</description>
                <bitOffset>23</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>unprivileged</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>privileged</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>ADC4PRIV</name>
                <description>privileged access mode for ADC4</description>
                <bitOffset>24</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>unprivileged</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>privileged</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
            </fields>
          </register>
          <register>
            <name>GTZC1_TZSC_PRIVCFGR3</name>
            <displayName>GTZC1_TZSC_PRIVCFGR3</displayName>
            <description>GTZC1 TZSC privilege configuration register 3</description>
            <addressOffset>0x028</addressOffset>
            <size>0x20</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>CRCPRIV</name>
                <description>privileged access mode for CRC</description>
                <bitOffset>3</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>unprivileged</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>privileged</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>TSCPRIV</name>
                <description>privileged access mode for TSC</description>
                <bitOffset>4</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>unprivileged</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>privileged</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>ICACHE_REGPRIV</name>
                <description>privileged access mode for ICACHE registers</description>
                <bitOffset>6</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>unprivileged</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>privileged</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>AESPRIV</name>
                <description>privileged access mode for AES</description>
                <bitOffset>11</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>unprivileged</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>privileged</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>HASHPRIV</name>
                <description>privileged access mode for HASH</description>
                <bitOffset>12</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>unprivileged</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>privileged</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>RNGPRIV</name>
                <description>privileged access mode for RNG</description>
                <bitOffset>13</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>unprivileged</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>privileged</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>SAESPRIV</name>
                <description>privileged access mode for SAES</description>
                <bitOffset>14</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>unprivileged</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>privileged</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>PKAPRIV</name>
                <description>privileged access mode for PKA</description>
                <bitOffset>16</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>unprivileged</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>privileged</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>RAMCFGPRIV</name>
                <description>privileged access mode for RAMCFG</description>
                <bitOffset>22</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>unprivileged</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>privileged</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>RADIOPRIV</name>
                <description>privileged access mode for 2.4 GHz RADIO</description>
                <bitOffset>23</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>unprivileged</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>privileged</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
            </fields>
          </register>
	  </registers>
    </peripheral>
    <peripheral derivedFrom="GTZC1_TZSC">
      <name>SEC_GTZC1_TZSC</name>
      <baseAddress>0x50032400</baseAddress>
    </peripheral>
	<peripheral>
      <name>GTZC1_TZIC</name>
      <description>GTZC1_TZIC</description>
      <groupName>GTZC</groupName>
      <baseAddress>0x40032800</baseAddress>
      <addressBlock>
        <offset>0x0</offset>
        <size>0x400</size>
        <usage>registers</usage>
      </addressBlock>
      <registers>   
	   <register>
          <name>GTZC1_TZIC_IER1</name>
          <displayName>GTZC1_TZIC_IER1</displayName>
          <description>TZIC interrupt enable register 1</description>
          <addressOffset>0x0</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
		  <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
                <name>TIM2IE</name>
                <description>illegal access interrupt enable for TIM2</description>
                <bitOffset>0</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>interrupt disabled</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>interrupt enabled</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>TIM3IE</name>
                <description>illegal access interrupt enable for TIM3</description>
                <bitOffset>1</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>interrupt disabled</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>interrupt enabled</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>WWDGIE</name>
                <description>illegal access interrupt enable for WWDG</description>
                <bitOffset>6</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>interrupt disabled</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>interrupt enabled</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>IWDGIE</name>
                <description>illegal access interrupt enable for IWDG</description>
                <bitOffset>7</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>interrupt disabled</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>interrupt enabled</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>USART2IE</name>
                <description>illegal access interrupt enable for USART2</description>
                <bitOffset>9</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>interrupt disabled</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>interrupt enabled</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>I2C1IE</name>
                <description>illegal access interrupt enable for I2C1</description>
                <bitOffset>13</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>interrupt disabled</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>interrupt enabled</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>LPTIM2IE</name>
                <description>illegal access interrupt enable for LPTIM2</description>
                <bitOffset>17</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>interrupt disabled</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>interrupt enabled</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>           
          </fields>
        </register>
        <register>
            <name>GTZC1_TZIC_IER2</name>
            <displayName>GTZC1_TZIC_IER2</displayName>
            <description>GTZC1 TZIC interrupt enable register 2</description>
            <addressOffset>0x004</addressOffset>
            <size>0x20</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>TIM1IE</name>
                <description>illegal access interrupt enable for TIM1</description>
                <bitOffset>0</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>interrupt disabled</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>interrupt enabled</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>SPI1IE</name>
                <description>illegal access interrupt enable for SPI1</description>
                <bitOffset>1</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>interrupt disabled</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>interrupt enabled</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>USART1IE</name>
                <description>illegal access interrupt enable for USART1</description>
                <bitOffset>3</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>interrupt disabled</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>interrupt enabled</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>TIM16IE</name>
                <description>illegal access interrupt enable for TIM16</description>
                <bitOffset>5</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>interrupt disabled</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>interrupt enabled</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>TIM17IE</name>
                <description>illegal access interrupt enable for TIM17</description>
                <bitOffset>6</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>interrupt disabled</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>interrupt enabled</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>SPI3IE</name>
                <description>illegal access interrupt enable for SPI3</description>
                <bitOffset>16</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>interrupt disabled</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>interrupt enabled</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>LPUART1IE</name>
                <description>illegal access interrupt enable for LPUART1</description>
                <bitOffset>17</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>interrupt disabled</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>interrupt enabled</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>I2C3IE</name>
                <description>illegal access interrupt enable for I2C3</description>
                <bitOffset>18</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>interrupt disabled</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>interrupt enabled</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>LPTIM1IE</name>
                <description>illegal access interrupt enable for LPTIM1</description>
                <bitOffset>19</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>interrupt disabled</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>interrupt enabled</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>COMPIE</name>
                <description>illegal access interrupt enable for COMP
Note that bit 23 is reserved on sales type STM32WBA52.</description>
                <bitOffset>23</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>interrupt disabled</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>interrupt enabled</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>ADC4IE</name>
                <description>illegal access interrupt enable for ADC4</description>
                <bitOffset>24</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>interrupt disabled</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>interrupt enabled</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
            </fields>
          </register>
          <register>
            <name>GTZC1_TZIC_IER3</name>
            <displayName>GTZC1_TZIC_IER3</displayName>
            <description>GTZC1 TZIC interrupt enable register 3</description>
            <addressOffset>0x008</addressOffset>
            <size>0x20</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>CRCIE</name>
                <description>illegal access interrupt enable for CRC</description>
                <bitOffset>3</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>interrupt disabled</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>interrupt enabled</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>TSCIE</name>
                <description>illegal access interrupt enable for TSC</description>
                <bitOffset>4</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>interrupt disabled</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>interrupt enabled</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>ICACHEIE</name>
                <description>illegal access interrupt enable for ICACHE registers</description>
                <bitOffset>6</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>interrupt disabled</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>interrupt enabled</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>AESIE</name>
                <description>illegal access interrupt enable for AES</description>
                <bitOffset>11</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>interrupt disabled</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>interrupt enabled</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>HASHIE</name>
                <description>illegal access interrupt enable for HASH</description>
                <bitOffset>12</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>interrupt disabled</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>interrupt enabled</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>RNGIE</name>
                <description>illegal access interrupt enable for RNG</description>
                <bitOffset>13</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>interrupt disabled</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>interrupt enabled</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>SAESIE</name>
                <description>illegal access interrupt enable for SAES</description>
                <bitOffset>14</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>interrupt disabled</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>interrupt enabled</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>HSEMIE</name>
                <description>illegal access interrupt enable for HSEM</description>
                <bitOffset>15</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>interrupt disabled</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>interrupt enabled</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>PKAIE</name>
                <description>illegal access interrupt enable for PKA</description>
                <bitOffset>16</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>interrupt disabled</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>interrupt enabled</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>RAMCFGIE</name>
                <description>illegal access interrupt enable for RAMCFG</description>
                <bitOffset>22</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>interrupt disabled</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>interrupt enabled</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>RADIOIE</name>
                <description>illegal access interrupt enable for 2.4 GHz RADIO</description>
                <bitOffset>23</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>interrupt disabled</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>interrupt enabled</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
            </fields>
          </register>
          <register>
            <name>GTZC1_TZIC_IER4</name>
            <displayName>GTZC1_TZIC_IER4</displayName>
            <description>GTZC1 TZIC interrupt enable register 4</description>
            <addressOffset>0x00C</addressOffset>
            <size>0x20</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>GPDMA1IE</name>
                <description>illegal access interrupt enable for GPDMA1</description>
                <bitOffset>0</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>interrupt disabled</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>interrupt enabled</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>FLASHIE</name>
                <description>illegal access interrupt enable for FLASH memory</description>
                <bitOffset>1</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>interrupt disabled</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>interrupt enabled</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>FLASH_REGIE</name>
                <description>illegal access interrupt enable for FLASH interface</description>
                <bitOffset>2</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>interrupt disabled</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>interrupt enabled</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>SYSCFGIE</name>
                <description>illegal access interrupt enable for SYSCFG</description>
                <bitOffset>7</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>interrupt disabled</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>interrupt enabled</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>RTCIE</name>
                <description>illegal access interrupt enable for RTC</description>
                <bitOffset>8</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>interrupt disabled</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>interrupt enabled</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>TAMPIE</name>
                <description>illegal access interrupt enable for TAMP</description>
                <bitOffset>9</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>interrupt disabled</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>interrupt enabled</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>PWRIE</name>
                <description>illegal access interrupt enable for PWR</description>
                <bitOffset>10</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>interrupt disabled</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>interrupt enabled</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>RCCIE</name>
                <description>illegal access interrupt enable for RCC</description>
                <bitOffset>11</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>interrupt disabled</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>interrupt enabled</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>EXTIIE</name>
                <description>illegal access interrupt enable for EXTI</description>
                <bitOffset>13</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>interrupt disabled</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>interrupt enabled</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>TZSCIE</name>
                <description>illegal access interrupt enable for GTZC1 TZSC</description>
                <bitOffset>14</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>interrupt disabled</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>interrupt enabled</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>TZICIE</name>
                <description>illegal access interrupt enable for GTZC1 TZIC</description>
                <bitOffset>15</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>interrupt disabled</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>interrupt enabled</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>SRAM1IE</name>
                <description>illegal access interrupt enable for SRAM1 memory</description>
                <bitOffset>22</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>interrupt disabled</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>interrupt enabled</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>MPCBB1IE</name>
                <description>illegal access interrupt enable for MPCBB1</description>
                <bitOffset>23</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>interrupt disabled</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>interrupt enabled</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>SRAM2IE</name>
                <description>illegal access interrupt enable for SRAM2 memory</description>
                <bitOffset>24</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>interrupt disabled</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>interrupt enabled</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>MPCBB2IE</name>
                <description>illegal access interrupt enable for MPCBB2</description>
                <bitOffset>25</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>interrupt disabled</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>interrupt enabled</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>SRAM6IE</name>
                <description>illegal access interrupt enable for 2.4GHz RXTXRAM memory</description>
                <bitOffset>30</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>interrupt disabled</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>interrupt enabled</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>MPCBB6IE</name>
                <description>illegal access interrupt enable for MPCBB6</description>
                <bitOffset>31</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>interrupt disabled</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>interrupt enabled</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
            </fields>
          </register>         
		  <register>
            <name>GTZC1_TZIC_SR1</name>
            <displayName>GTZC1_TZIC_SR1</displayName>
            <description>TZIC status register 1</description>
            <addressOffset>0x10</addressOffset>
            <size>0x20</size>
            <access>read-only</access>
            <resetValue>0x00000000</resetValue>
	   	   <resetMask>0xFFFFFFFF</resetMask>
           <fields>
		    <field>
                <name>TIM2F</name>
                <description>illegal access flag for TIM2</description>
                <bitOffset>0</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>no illegal access event</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>illegal access event</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>TIM3F</name>
                <description>illegal access flag for TIM3</description>
                <bitOffset>1</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>no illegal access event</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>illegal access event</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>WWDGF</name>
                <description>illegal access flag for WWDG</description>
                <bitOffset>6</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>no illegal access event</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>illegal access event</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>IWDGF</name>
                <description>illegal access flag for IWDG</description>
                <bitOffset>7</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>no illegal access event</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>illegal access event</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>USART2F</name>
                <description>illegal access flag for USART2</description>
                <bitOffset>9</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>no illegal access event</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>illegal access event</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>I2C1F</name>
                <description>illegal access flag for I2C1</description>
                <bitOffset>13</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>no illegal access event</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>illegal access event</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>LPTIM2F</name>
                <description>illegal access flag for LPTIM2</description>
                <bitOffset>17</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>no illegal access event</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>illegal access event</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
		   </fields>
        </register>
        <register>
          <name>GTZC1_TZIC_SR2</name>
          <displayName>GTZC1_TZIC_SR2</displayName>
          <description>TZIC status register 2</description>
          <addressOffset>0x14</addressOffset>
          <size>0x20</size>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>TIM1F</name>
              <description>illegal access flag for TIM1</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>SPI1F</name>
              <description>illegal access flag for SPI1</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>USART1F</name>
              <description>illegal access flag for USART1</description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>TIM16F</name>
              <description>illegal access flag for TIM6</description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>TIM17F</name>
              <description>illegal access flag for TIM7</description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
            </field>			
            <field>
              <name>SPI3F</name>
              <description>SPI3F</description>
              <bitOffset>16</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>LPUART1F</name>
              <description>LPUART1F</description>
              <bitOffset>17</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
			<field>
              <name>I2C3F</name>
              <description>I2C3F</description>
              <bitOffset>18</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
			<field>
              <name>LPTIM1F</name>
              <description>LPTIM1F</description>
              <bitOffset>19</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
			<field>
              <name>COMPF</name>
              <description>COMPF</description>
              <bitOffset>23</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
			<field>
              <name>ADC4F</name>
              <description>ADC4F</description>
              <bitOffset>24</bitOffset>
              <bitWidth>1</bitWidth>
            </field>			
          </fields>
        </register>
        <register>
          <name>GTZC1_TZIC_SR3</name>
          <displayName>GTZC1_TZIC_SR3</displayName>
          <description>TZIC status register 3</description>
          <addressOffset>0x18</addressOffset>
          <size>0x20</size>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <fields>            
            <field>
              <name>CRCF</name>
              <description>illegal access flag for CRC</description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>TSCF</name>
              <description>illegal access flag for TSC</description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>ICACHEF</name>
              <description>illegal access flag for ICACHE registers</description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
            </field>            
            <field>
              <name>AESF</name>
              <description>illegal access flag for AES</description>
              <bitOffset>11</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>HASHF</name>
              <description>illegal access flag for HASH</description>
              <bitOffset>12</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RNGF</name>
              <description>illegal access flag for RNG</description>
              <bitOffset>13</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>SAESF</name>
              <description>illegal access flag for SAES</description>
              <bitOffset>14</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>HSEMF</name>
              <description>illegal access flag for HSEM</description>
              <bitOffset>15</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>PKAF</name>
              <description>illegal access flag for PKA</description>
              <bitOffset>16</bitOffset>
              <bitWidth>1</bitWidth>
            </field>           
            <field>
              <name>RAMCFGF</name>
              <description>illegal access flag for RAMCFG</description>
              <bitOffset>22</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
			<field>
              <name>RADIOF</name>
              <description>illegal access flag for 2.4 GHz RADIO</description>
              <bitOffset>23</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
          </fields>
        </register>                   
        <register>
            <name>GTZC1_TZIC_SR4</name>
            <displayName>GTZC1_TZIC_SR4</displayName>
            <description>GTZC1 TZIC status register 4</description>
            <addressOffset>0x01C</addressOffset>
            <size>0x20</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>GPDMA1F</name>
                <description>illegal access flag for GPDMA1</description>
                <bitOffset>0</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>no illegal access event</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>illegal access event</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>FLASHF</name>
                <description>illegal access flag for FLASH memory</description>
                <bitOffset>1</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>no illegal access event</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>illegal access event</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>FLASH_REGF</name>
                <description>illegal access flag for FLASH interface</description>
                <bitOffset>2</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>no illegal access event</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>illegal access event</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>SYSCFGF</name>
                <description>illegal access flag for SYSCFG</description>
                <bitOffset>7</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>no illegal access event</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>illegal access event</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>RTCF</name>
                <description>illegal access flag for RTC</description>
                <bitOffset>8</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>no illegal access event</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>illegal access event</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>TAMPF</name>
                <description>illegal access flag for TAMP</description>
                <bitOffset>9</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>no illegal access event</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>illegal access event</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>PWRF</name>
                <description>illegal access flag for PWR</description>
                <bitOffset>10</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>no illegal access event</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>illegal access event</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>RCCF</name>
                <description>illegal access flag for RCC</description>
                <bitOffset>11</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>no illegal access event</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>illegal access event</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>EXTIF</name>
                <description>illegal access flag for EXTI</description>
                <bitOffset>13</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>no illegal access event</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>illegal access event</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>TZSCF</name>
                <description>illegal access flag for GTZC1 TZSC</description>
                <bitOffset>14</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>no illegal access event</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>illegal access event</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>TZICF</name>
                <description>illegal access flag for GTZC1 TZIC</description>
                <bitOffset>15</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>no illegal access event</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>illegal access event</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>SRAM1F</name>
                <description>illegal access flag for SRAM1 memory</description>
                <bitOffset>22</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>no illegal access event</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>illegal access event</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>MPCBB1F</name>
                <description>illegal access flag for MPCBB1</description>
                <bitOffset>23</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>no illegal access event</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>illegal access event</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>SRAM2F</name>
                <description>illegal access flag for SRAM2 memory</description>
                <bitOffset>24</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>no illegal access event</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>illegal access event</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>MPCBB2F</name>
                <description>illegal access flag for MPCBB2</description>
                <bitOffset>25</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>no illegal access event</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>illegal access event</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>SRAM6F</name>
                <description>illegal access flag for 2.4 GHZ RADIO RXTXRAM memory</description>
                <bitOffset>30</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>no illegal access event</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>illegal access event</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>MPCBB6F</name>
                <description>illegal access flag for MPCBB6</description>
                <bitOffset>31</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>no illegal access event</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>illegal access event</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
            </fields>
          </register>
		  <register>
			  <name>GTZC1_TZIC_FCR1</name>
			  <displayName>GTZC1_TZIC_FCR1</displayName>
			  <description>TZIC flag clear register 1</description>
			  <addressOffset>0x20</addressOffset>
			  <size>0x20</size>
			  <access>write-only</access>
			  <resetValue>0x00000000</resetValue>
			  <fields>
            <field>
              <name>CTIM2F</name>
              <description>clear the illegal access flag for TIM2</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>CTIM3F</name>
              <description>clear the illegal access flag for TIM3</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
            </field>           
            <field>
              <name>CWWDGF</name>
              <description>clear the illegal access flag for WWDG</description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>CIWDGF</name>
              <description>clear the illegal access flag for IWDG</description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>CUSART2F</name>
              <description>clear the illegal access flag for USART2</description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>CI2C1F</name>
              <description>clear the illegal access flag for I2C1</description>
              <bitOffset>13</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>CLPTIM2F</name>
              <description>clear the illegal access flag for LPTIM2</description>
              <bitOffset>17</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>GTZC1_TZIC_FCR2</name>
          <displayName>GTZC1_TZIC_FCR2</displayName>
          <description>TZIC flag clear register 2</description>
          <addressOffset>0x24</addressOffset>
          <size>0x20</size>
          <access>write-only</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>CTIM1F</name>
              <description>clear the illegal access flag for TIM1</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>CSPI1F</name>
              <description>clear the illegal access flag for SPI1</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>CUSART1F</name>
              <description>clear the illegal access flag for USART1</description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>CTIM16F</name>
              <description>clear the illegal access flag for TIM6</description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>CTIM17F</name>
              <description>clear the illegal access flag for TIM7</description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
            </field>			
            <field>
              <name>CSPI3F</name>
              <description>clear the illegal access flag for SPI3</description>
              <bitOffset>16</bitOffset>
              <bitWidth>1</bitWidth>
            </field>  
            <field>
              <name>CLPUART1F</name>
              <description>clear the illegal access flag for LPUART1</description>
              <bitOffset>17</bitOffset>
              <bitWidth>1</bitWidth>
            </field>	
            <field>
              <name>CI2C3F</name>
              <description>clear the illegal access flag for I2C3</description>
              <bitOffset>18</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
			<field>
              <name>CLPTIM1F</name>
              <description>clear the illegal access flag for LPTIM1</description>
              <bitOffset>19</bitOffset>
              <bitWidth>1</bitWidth>
            </field>			
            <field>
              <name>CCOMPF</name>
              <description>iclear the illegal access flag for COMP</description>
              <bitOffset>23</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
			<field>
              <name>CADC4F</name>
              <description>clear the illegal access flag for ADC4</description>
              <bitOffset>24</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>GTZC1_TZIC_FCR3</name>
          <displayName>GTZC1_TZIC_FCR3</displayName>
          <description>TZIC flag clear register 3</description>
          <addressOffset>0x28</addressOffset>
          <size>0x20</size>
          <access>write-only</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>CCRCF</name>
              <description>clear the illegal access flag for CRC</description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>CTSCF</name>
              <description>clear the illegal access flag for TSC</description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>CICACHEF</name>
              <description>clear the illegal access flag for ICACHE registers</description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>CAESF</name>
              <description>clear the illegal access flag for AES</description>
              <bitOffset>11</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>CHASHF</name>
              <description>clear the illegal access flag for HASH</description>
              <bitOffset>12</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>CRNGF</name>
              <description>clear the illegal access flag for RNG</description>
              <bitOffset>13</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>CSAESF</name>
              <description>clear the illegal access flag for SAES</description>
              <bitOffset>14</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>CHSEMF</name>
              <description>clear the illegal access flag for HSEM</description>
              <bitOffset>15</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>CPKAF</name>
              <description>clear the illegal access flag for PKA</description>
              <bitOffset>16</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>CRAMCFGF</name>
              <description>clear the illegal access flag for RAMCFG</description>
              <bitOffset>22</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
			<field>
              <name>CRADIOF</name>
              <description>clear the illegal access flag for 2.4 GHz RADIO</description>
              <bitOffset>23</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
          </fields>
        </register>		   
        <register>
            <name>GTZC1_TZIC_FCR4</name>
            <displayName>GTZC1_TZIC_FCR4</displayName>
            <description>GTZC1 TZIC flag clear register 4</description>
            <addressOffset>0x02C</addressOffset>
            <size>0x20</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>CGPDMA1F</name>
                <description>clear the illegal access flag for GPDMA1</description>
                <bitOffset>0</bitOffset>
                <bitWidth>1</bitWidth>
                <access>write-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>no action</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>status flag cleared</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>CFLASHF</name>
                <description>clear the illegal access flag for FLASH memory</description>
                <bitOffset>1</bitOffset>
                <bitWidth>1</bitWidth>
                <access>write-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>no action</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>status flag cleared</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>CFLASH_REGF</name>
                <description>clear the illegal access flag for FLASH interface</description>
                <bitOffset>2</bitOffset>
                <bitWidth>1</bitWidth>
                <access>write-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>no action</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>status flag cleared</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>CSYSCFGF</name>
                <description>clear the illegal access flag for SYSCFG</description>
                <bitOffset>7</bitOffset>
                <bitWidth>1</bitWidth>
                <access>write-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>no action</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>status flag cleared</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>CRTCF</name>
                <description>clear the illegal access flag for RTC</description>
                <bitOffset>8</bitOffset>
                <bitWidth>1</bitWidth>
                <access>write-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>no action</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>status flag cleared</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>CTAMPF</name>
                <description>clear the illegal access flag for TAMP</description>
                <bitOffset>9</bitOffset>
                <bitWidth>1</bitWidth>
                <access>write-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>no action</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>status flag cleared</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>CPWRF</name>
                <description>clear the illegal access flag for PWR</description>
                <bitOffset>10</bitOffset>
                <bitWidth>1</bitWidth>
                <access>write-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>no action</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>status flag cleared</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>CRCCF</name>
                <description>clear the illegal access flag for RCC</description>
                <bitOffset>11</bitOffset>
                <bitWidth>1</bitWidth>
                <access>write-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>no action</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>status flag cleared</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>CEXTIF</name>
                <description>clear the illegal access flag for EXTI</description>
                <bitOffset>13</bitOffset>
                <bitWidth>1</bitWidth>
                <access>write-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>no action</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>status flag cleared</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>CTZSCF</name>
                <description>clear the illegal access flag for GTZC1 TZSC</description>
                <bitOffset>14</bitOffset>
                <bitWidth>1</bitWidth>
                <access>write-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>no action</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>status flag cleared</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>CTZICF</name>
                <description>clear the illegal access flag for GTZC1 TZIC</description>
                <bitOffset>15</bitOffset>
                <bitWidth>1</bitWidth>
                <access>write-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>no action</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>status flag cleared</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>CSRAM1F</name>
                <description>clear the illegal access flag for SRAM1 memory</description>
                <bitOffset>22</bitOffset>
                <bitWidth>1</bitWidth>
                <access>write-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>no action</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>status flag cleared</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>CMPCBB1F</name>
                <description>clear the illegal access flag for MPCBB1</description>
                <bitOffset>23</bitOffset>
                <bitWidth>1</bitWidth>
                <access>write-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>no action</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>status flag cleared</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>CSRAM2F</name>
                <description>clear the illegal access flag for SRAM2 memory</description>
                <bitOffset>24</bitOffset>
                <bitWidth>1</bitWidth>
                <access>write-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>no action</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>status flag cleared</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>CMPCBB2F</name>
                <description>clear the illegal access flag for MPCBB2</description>
                <bitOffset>25</bitOffset>
                <bitWidth>1</bitWidth>
                <access>write-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>no action</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>status flag cleared</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>CSRAM6F</name>
                <description>clear the illegal access flag for 2.4 GHz RADIO RXTXRAM memory</description>
                <bitOffset>30</bitOffset>
                <bitWidth>1</bitWidth>
                <access>write-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>no action</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>status flag cleared</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>CMPCBB6F</name>
                <description>clear the illegal access flag for MPCBB6</description>
                <bitOffset>31</bitOffset>
                <bitWidth>1</bitWidth>
                <access>write-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>no action</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>status flag cleared</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
            </fields>
        </register>
	   </registers>
    </peripheral>
    <peripheral derivedFrom="GTZC1_TZIC">
      <name>SEC_GTZC1_TZIC</name>
      <baseAddress>0x50032800</baseAddress>
    </peripheral>
	<peripheral>
        <name>GTZC1_MPCBB1</name>
        <description>GTZC1_MPCBB1 address block description</description>
		<groupName>GTZC</groupName>
        <baseAddress>0x40032C00</baseAddress>
        <addressBlock>
          <offset>0x0</offset>
          <size>0x400</size>
          <usage>registers</usage>
        </addressBlock>
        <registers>
        <register>
          <name>GTZC1_MPCBB_CR</name>
          <displayName>GTZC1_MPCBB_CR</displayName>
          <description>MPCBB control register</description>
          <addressOffset>0x0</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
		  <resetMask>0xFFFFFFFF</resetMask>
          <fields>
		   <field>
                <name>GLOCK</name>
                <description>lock the control register of the MPCBB until next reset;
This bit is cleared by default and once set, it can not be reset until system reset.</description>
                <bitOffset>0</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>control register not locked</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>control register locked</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>INVSECSTATE</name>
                <description>SRAM clocks security state;
This bit is used to define the internal SRAM clocks control in RCC as secure or not.</description>
                <bitOffset>30</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>SRAM clock is secured if a secure area exists in the MPCBB. It is non secure if there is no secure area.</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>SRAM clock is non-secure even if a secure area exists in the MPCBB, and secure even if no secure block is set in the MPCBB.</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>SRWILADIS</name>
                <description>secure read/write illegal access disable;
This bit disables the detection of an illegal access when a secure read/write transaction access a non-secure blocks of the block-based SRAM (secure fetch on non-secure block is always considered illegal).</description>
                <bitOffset>31</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>enabled, secure read/write acces not allowed on non-secure SRAM block</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>disabled, secure read/write access allowed on non-secure SRAM block</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
          </fields>
        </register>
        <register>
          <name>GTZC1_MPCBB_CFGLOCK</name>
          <displayName>GTZC1_MPCBB_CFGLOCK</displayName>
          <description>GTZC1 SRAMz MPCBB configuration lock register</description>
          <addressOffset>0x10</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
		  <resetMask>0xFFFFFFFF</resetMask>
          <fields>
		    <field>
                <name>SPLCK0</name>
                <description>Security/privilege configuration lock super-block;
This bit is set by software and can be cleared only by system reset.;
note that bit [3:2] are reserved on sales type STM32WBA5xEx for MPCBB1.</description>
                <bitOffset>0</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>GTZC1_MPCBB_SECCFGRn and GTZC1_MPCBB_PRIVCFGRn can be written.</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Writes to GTZC1_MPCBB_SECCFGRn and GTZC1_MPCBB_PRIVCFGRn are ignored</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>SPLCK1</name>
                <description>Security/privilege configuration lock super-block;
This bit is set by software and can be cleared only by system reset.;
note that bit [3:2] are reserved on sales type STM32WBA5xEx for MPCBB1.</description>
                <bitOffset>1</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>GTZC1_MPCBB_SECCFGRn and GTZC1_MPCBB_PRIVCFGRn can be written.</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Writes to GTZC1_MPCBB_SECCFGRn and GTZC1_MPCBB_PRIVCFGRn are ignored</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>SPLCK2</name>
                <description>Security/privilege configuration lock super-block;
This bit is set by software and can be cleared only by system reset.;
note that bit [3:2] are reserved on sales type STM32WBA5xEx for MPCBB1.</description>
                <bitOffset>2</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>GTZC1_MPCBB_SECCFGRn and GTZC1_MPCBB_PRIVCFGRn can be written.</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Writes to GTZC1_MPCBB_SECCFGRn and GTZC1_MPCBB_PRIVCFGRn are ignored</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>SPLCK3</name>
                <description>Security/privilege configuration lock super-block;
This bit is set by software and can be cleared only by system reset.;
note that bit [3:2] are reserved on sales type STM32WBA5xEx for MPCBB1.</description>
                <bitOffset>3</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>GTZC1_MPCBB_SECCFGRn and GTZC1_MPCBB_PRIVCFGRn can be written.</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Writes to GTZC1_MPCBB_SECCFGRn and GTZC1_MPCBB_PRIVCFGRn are ignored</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
		  </fields>         
        </register>          
        <register>
            <name>GTZC1_MPCBB_SECCFGR0</name>
            <displayName>GTZC1_MPCBB_SECCFGR0</displayName>
            <description>GTZC1 MPCBB security configuration for super-block 0 register</description>
            <addressOffset>0x100</addressOffset>
            <size>0x20</size>
            <resetValue>0xFFFFFFFF</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>SEC0</name>
                <description>Security configuration for block y (y = 0 to 31) in super block n
Unprivileged write to this bit is ignored if PRIVy bit is set in GTZC1_MPCBB_PRIVCFGRn.
Writes are ignored if SPLCKn bit is set in GTZC1_MPCBB_CFGLOCK.</description>
                <bitOffset>0</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Non-secure access only to block y, belonging to super-block n. Secure access is also allowed if the SRWILADIS bit is set in GTZC1_MPCBB_CR.</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Secure access only to block y, belonging to super-block n.</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>SEC1</name>
                <description>Security configuration for block y (y = 0 to 31) in super block n
Unprivileged write to this bit is ignored if PRIVy bit is set in GTZC1_MPCBB_PRIVCFGRn.
Writes are ignored if SPLCKn bit is set in GTZC1_MPCBB_CFGLOCK.</description>
                <bitOffset>1</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Non-secure access only to block y, belonging to super-block n. Secure access is also allowed if the SRWILADIS bit is set in GTZC1_MPCBB_CR.</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Secure access only to block y, belonging to super-block n.</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>SEC2</name>
                <description>Security configuration for block y (y = 0 to 31) in super block n
Unprivileged write to this bit is ignored if PRIVy bit is set in GTZC1_MPCBB_PRIVCFGRn.
Writes are ignored if SPLCKn bit is set in GTZC1_MPCBB_CFGLOCK.</description>
                <bitOffset>2</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Non-secure access only to block y, belonging to super-block n. Secure access is also allowed if the SRWILADIS bit is set in GTZC1_MPCBB_CR.</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Secure access only to block y, belonging to super-block n.</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>SEC3</name>
                <description>Security configuration for block y (y = 0 to 31) in super block n
Unprivileged write to this bit is ignored if PRIVy bit is set in GTZC1_MPCBB_PRIVCFGRn.
Writes are ignored if SPLCKn bit is set in GTZC1_MPCBB_CFGLOCK.</description>
                <bitOffset>3</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Non-secure access only to block y, belonging to super-block n. Secure access is also allowed if the SRWILADIS bit is set in GTZC1_MPCBB_CR.</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Secure access only to block y, belonging to super-block n.</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>SEC4</name>
                <description>Security configuration for block y (y = 0 to 31) in super block n
Unprivileged write to this bit is ignored if PRIVy bit is set in GTZC1_MPCBB_PRIVCFGRn.
Writes are ignored if SPLCKn bit is set in GTZC1_MPCBB_CFGLOCK.</description>
                <bitOffset>4</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Non-secure access only to block y, belonging to super-block n. Secure access is also allowed if the SRWILADIS bit is set in GTZC1_MPCBB_CR.</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Secure access only to block y, belonging to super-block n.</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>SEC5</name>
                <description>Security configuration for block y (y = 0 to 31) in super block n
Unprivileged write to this bit is ignored if PRIVy bit is set in GTZC1_MPCBB_PRIVCFGRn.
Writes are ignored if SPLCKn bit is set in GTZC1_MPCBB_CFGLOCK.</description>
                <bitOffset>5</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Non-secure access only to block y, belonging to super-block n. Secure access is also allowed if the SRWILADIS bit is set in GTZC1_MPCBB_CR.</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Secure access only to block y, belonging to super-block n.</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>SEC6</name>
                <description>Security configuration for block y (y = 0 to 31) in super block n
Unprivileged write to this bit is ignored if PRIVy bit is set in GTZC1_MPCBB_PRIVCFGRn.
Writes are ignored if SPLCKn bit is set in GTZC1_MPCBB_CFGLOCK.</description>
                <bitOffset>6</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Non-secure access only to block y, belonging to super-block n. Secure access is also allowed if the SRWILADIS bit is set in GTZC1_MPCBB_CR.</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Secure access only to block y, belonging to super-block n.</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>SEC7</name>
                <description>Security configuration for block y (y = 0 to 31) in super block n
Unprivileged write to this bit is ignored if PRIVy bit is set in GTZC1_MPCBB_PRIVCFGRn.
Writes are ignored if SPLCKn bit is set in GTZC1_MPCBB_CFGLOCK.</description>
                <bitOffset>7</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Non-secure access only to block y, belonging to super-block n. Secure access is also allowed if the SRWILADIS bit is set in GTZC1_MPCBB_CR.</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Secure access only to block y, belonging to super-block n.</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>SEC8</name>
                <description>Security configuration for block y (y = 0 to 31) in super block n
Unprivileged write to this bit is ignored if PRIVy bit is set in GTZC1_MPCBB_PRIVCFGRn.
Writes are ignored if SPLCKn bit is set in GTZC1_MPCBB_CFGLOCK.</description>
                <bitOffset>8</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Non-secure access only to block y, belonging to super-block n. Secure access is also allowed if the SRWILADIS bit is set in GTZC1_MPCBB_CR.</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Secure access only to block y, belonging to super-block n.</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>SEC9</name>
                <description>Security configuration for block y (y = 0 to 31) in super block n
Unprivileged write to this bit is ignored if PRIVy bit is set in GTZC1_MPCBB_PRIVCFGRn.
Writes are ignored if SPLCKn bit is set in GTZC1_MPCBB_CFGLOCK.</description>
                <bitOffset>9</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Non-secure access only to block y, belonging to super-block n. Secure access is also allowed if the SRWILADIS bit is set in GTZC1_MPCBB_CR.</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Secure access only to block y, belonging to super-block n.</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>SEC10</name>
                <description>Security configuration for block y (y = 0 to 31) in super block n
Unprivileged write to this bit is ignored if PRIVy bit is set in GTZC1_MPCBB_PRIVCFGRn.
Writes are ignored if SPLCKn bit is set in GTZC1_MPCBB_CFGLOCK.</description>
                <bitOffset>10</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Non-secure access only to block y, belonging to super-block n. Secure access is also allowed if the SRWILADIS bit is set in GTZC1_MPCBB_CR.</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Secure access only to block y, belonging to super-block n.</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>SEC11</name>
                <description>Security configuration for block y (y = 0 to 31) in super block n
Unprivileged write to this bit is ignored if PRIVy bit is set in GTZC1_MPCBB_PRIVCFGRn.
Writes are ignored if SPLCKn bit is set in GTZC1_MPCBB_CFGLOCK.</description>
                <bitOffset>11</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Non-secure access only to block y, belonging to super-block n. Secure access is also allowed if the SRWILADIS bit is set in GTZC1_MPCBB_CR.</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Secure access only to block y, belonging to super-block n.</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>SEC12</name>
                <description>Security configuration for block y (y = 0 to 31) in super block n
Unprivileged write to this bit is ignored if PRIVy bit is set in GTZC1_MPCBB_PRIVCFGRn.
Writes are ignored if SPLCKn bit is set in GTZC1_MPCBB_CFGLOCK.</description>
                <bitOffset>12</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Non-secure access only to block y, belonging to super-block n. Secure access is also allowed if the SRWILADIS bit is set in GTZC1_MPCBB_CR.</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Secure access only to block y, belonging to super-block n.</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>SEC13</name>
                <description>Security configuration for block y (y = 0 to 31) in super block n
Unprivileged write to this bit is ignored if PRIVy bit is set in GTZC1_MPCBB_PRIVCFGRn.
Writes are ignored if SPLCKn bit is set in GTZC1_MPCBB_CFGLOCK.</description>
                <bitOffset>13</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Non-secure access only to block y, belonging to super-block n. Secure access is also allowed if the SRWILADIS bit is set in GTZC1_MPCBB_CR.</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Secure access only to block y, belonging to super-block n.</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>SEC14</name>
                <description>Security configuration for block y (y = 0 to 31) in super block n
Unprivileged write to this bit is ignored if PRIVy bit is set in GTZC1_MPCBB_PRIVCFGRn.
Writes are ignored if SPLCKn bit is set in GTZC1_MPCBB_CFGLOCK.</description>
                <bitOffset>14</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Non-secure access only to block y, belonging to super-block n. Secure access is also allowed if the SRWILADIS bit is set in GTZC1_MPCBB_CR.</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Secure access only to block y, belonging to super-block n.</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>SEC15</name>
                <description>Security configuration for block y (y = 0 to 31) in super block n
Unprivileged write to this bit is ignored if PRIVy bit is set in GTZC1_MPCBB_PRIVCFGRn.
Writes are ignored if SPLCKn bit is set in GTZC1_MPCBB_CFGLOCK.</description>
                <bitOffset>15</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Non-secure access only to block y, belonging to super-block n. Secure access is also allowed if the SRWILADIS bit is set in GTZC1_MPCBB_CR.</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Secure access only to block y, belonging to super-block n.</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>SEC16</name>
                <description>Security configuration for block y (y = 0 to 31) in super block n
Unprivileged write to this bit is ignored if PRIVy bit is set in GTZC1_MPCBB_PRIVCFGRn.
Writes are ignored if SPLCKn bit is set in GTZC1_MPCBB_CFGLOCK.</description>
                <bitOffset>16</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Non-secure access only to block y, belonging to super-block n. Secure access is also allowed if the SRWILADIS bit is set in GTZC1_MPCBB_CR.</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Secure access only to block y, belonging to super-block n.</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>SEC17</name>
                <description>Security configuration for block y (y = 0 to 31) in super block n
Unprivileged write to this bit is ignored if PRIVy bit is set in GTZC1_MPCBB_PRIVCFGRn.
Writes are ignored if SPLCKn bit is set in GTZC1_MPCBB_CFGLOCK.</description>
                <bitOffset>17</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Non-secure access only to block y, belonging to super-block n. Secure access is also allowed if the SRWILADIS bit is set in GTZC1_MPCBB_CR.</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Secure access only to block y, belonging to super-block n.</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>SEC18</name>
                <description>Security configuration for block y (y = 0 to 31) in super block n
Unprivileged write to this bit is ignored if PRIVy bit is set in GTZC1_MPCBB_PRIVCFGRn.
Writes are ignored if SPLCKn bit is set in GTZC1_MPCBB_CFGLOCK.</description>
                <bitOffset>18</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Non-secure access only to block y, belonging to super-block n. Secure access is also allowed if the SRWILADIS bit is set in GTZC1_MPCBB_CR.</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Secure access only to block y, belonging to super-block n.</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>SEC19</name>
                <description>Security configuration for block y (y = 0 to 31) in super block n
Unprivileged write to this bit is ignored if PRIVy bit is set in GTZC1_MPCBB_PRIVCFGRn.
Writes are ignored if SPLCKn bit is set in GTZC1_MPCBB_CFGLOCK.</description>
                <bitOffset>19</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Non-secure access only to block y, belonging to super-block n. Secure access is also allowed if the SRWILADIS bit is set in GTZC1_MPCBB_CR.</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Secure access only to block y, belonging to super-block n.</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>SEC20</name>
                <description>Security configuration for block y (y = 0 to 31) in super block n
Unprivileged write to this bit is ignored if PRIVy bit is set in GTZC1_MPCBB_PRIVCFGRn.
Writes are ignored if SPLCKn bit is set in GTZC1_MPCBB_CFGLOCK.</description>
                <bitOffset>20</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Non-secure access only to block y, belonging to super-block n. Secure access is also allowed if the SRWILADIS bit is set in GTZC1_MPCBB_CR.</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Secure access only to block y, belonging to super-block n.</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>SEC21</name>
                <description>Security configuration for block y (y = 0 to 31) in super block n
Unprivileged write to this bit is ignored if PRIVy bit is set in GTZC1_MPCBB_PRIVCFGRn.
Writes are ignored if SPLCKn bit is set in GTZC1_MPCBB_CFGLOCK.</description>
                <bitOffset>21</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Non-secure access only to block y, belonging to super-block n. Secure access is also allowed if the SRWILADIS bit is set in GTZC1_MPCBB_CR.</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Secure access only to block y, belonging to super-block n.</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>SEC22</name>
                <description>Security configuration for block y (y = 0 to 31) in super block n
Unprivileged write to this bit is ignored if PRIVy bit is set in GTZC1_MPCBB_PRIVCFGRn.
Writes are ignored if SPLCKn bit is set in GTZC1_MPCBB_CFGLOCK.</description>
                <bitOffset>22</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Non-secure access only to block y, belonging to super-block n. Secure access is also allowed if the SRWILADIS bit is set in GTZC1_MPCBB_CR.</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Secure access only to block y, belonging to super-block n.</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>SEC23</name>
                <description>Security configuration for block y (y = 0 to 31) in super block n
Unprivileged write to this bit is ignored if PRIVy bit is set in GTZC1_MPCBB_PRIVCFGRn.
Writes are ignored if SPLCKn bit is set in GTZC1_MPCBB_CFGLOCK.</description>
                <bitOffset>23</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Non-secure access only to block y, belonging to super-block n. Secure access is also allowed if the SRWILADIS bit is set in GTZC1_MPCBB_CR.</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Secure access only to block y, belonging to super-block n.</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>SEC24</name>
                <description>Security configuration for block y (y = 0 to 31) in super block n
Unprivileged write to this bit is ignored if PRIVy bit is set in GTZC1_MPCBB_PRIVCFGRn.
Writes are ignored if SPLCKn bit is set in GTZC1_MPCBB_CFGLOCK.</description>
                <bitOffset>24</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Non-secure access only to block y, belonging to super-block n. Secure access is also allowed if the SRWILADIS bit is set in GTZC1_MPCBB_CR.</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Secure access only to block y, belonging to super-block n.</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>SEC25</name>
                <description>Security configuration for block y (y = 0 to 31) in super block n
Unprivileged write to this bit is ignored if PRIVy bit is set in GTZC1_MPCBB_PRIVCFGRn.
Writes are ignored if SPLCKn bit is set in GTZC1_MPCBB_CFGLOCK.</description>
                <bitOffset>25</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Non-secure access only to block y, belonging to super-block n. Secure access is also allowed if the SRWILADIS bit is set in GTZC1_MPCBB_CR.</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Secure access only to block y, belonging to super-block n.</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>SEC26</name>
                <description>Security configuration for block y (y = 0 to 31) in super block n
Unprivileged write to this bit is ignored if PRIVy bit is set in GTZC1_MPCBB_PRIVCFGRn.
Writes are ignored if SPLCKn bit is set in GTZC1_MPCBB_CFGLOCK.</description>
                <bitOffset>26</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Non-secure access only to block y, belonging to super-block n. Secure access is also allowed if the SRWILADIS bit is set in GTZC1_MPCBB_CR.</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Secure access only to block y, belonging to super-block n.</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>SEC27</name>
                <description>Security configuration for block y (y = 0 to 31) in super block n
Unprivileged write to this bit is ignored if PRIVy bit is set in GTZC1_MPCBB_PRIVCFGRn.
Writes are ignored if SPLCKn bit is set in GTZC1_MPCBB_CFGLOCK.</description>
                <bitOffset>27</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Non-secure access only to block y, belonging to super-block n. Secure access is also allowed if the SRWILADIS bit is set in GTZC1_MPCBB_CR.</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Secure access only to block y, belonging to super-block n.</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>SEC28</name>
                <description>Security configuration for block y (y = 0 to 31) in super block n
Unprivileged write to this bit is ignored if PRIVy bit is set in GTZC1_MPCBB_PRIVCFGRn.
Writes are ignored if SPLCKn bit is set in GTZC1_MPCBB_CFGLOCK.</description>
                <bitOffset>28</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Non-secure access only to block y, belonging to super-block n. Secure access is also allowed if the SRWILADIS bit is set in GTZC1_MPCBB_CR.</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Secure access only to block y, belonging to super-block n.</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>SEC29</name>
                <description>Security configuration for block y (y = 0 to 31) in super block n
Unprivileged write to this bit is ignored if PRIVy bit is set in GTZC1_MPCBB_PRIVCFGRn.
Writes are ignored if SPLCKn bit is set in GTZC1_MPCBB_CFGLOCK.</description>
                <bitOffset>29</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Non-secure access only to block y, belonging to super-block n. Secure access is also allowed if the SRWILADIS bit is set in GTZC1_MPCBB_CR.</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Secure access only to block y, belonging to super-block n.</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>SEC30</name>
                <description>Security configuration for block y (y = 0 to 31) in super block n
Unprivileged write to this bit is ignored if PRIVy bit is set in GTZC1_MPCBB_PRIVCFGRn.
Writes are ignored if SPLCKn bit is set in GTZC1_MPCBB_CFGLOCK.</description>
                <bitOffset>30</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Non-secure access only to block y, belonging to super-block n. Secure access is also allowed if the SRWILADIS bit is set in GTZC1_MPCBB_CR.</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Secure access only to block y, belonging to super-block n.</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>SEC31</name>
                <description>Security configuration for block y (y = 0 to 31) in super block n
Unprivileged write to this bit is ignored if PRIVy bit is set in GTZC1_MPCBB_PRIVCFGRn.
Writes are ignored if SPLCKn bit is set in GTZC1_MPCBB_CFGLOCK.</description>
                <bitOffset>31</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Non-secure access only to block y, belonging to super-block n. Secure access is also allowed if the SRWILADIS bit is set in GTZC1_MPCBB_CR.</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Secure access only to block y, belonging to super-block n.</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
            </fields>
          </register>
          <register>
            <name>GTZC1_MPCBB_SECCFGR1</name>
            <displayName>GTZC1_MPCBB_SECCFGR1</displayName>
            <description>GTZC1 MPCBB security configuration for super-block 1 register</description>
            <addressOffset>0x104</addressOffset>
            <size>0x20</size>
            <resetValue>0xFFFFFFFF</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>SEC0</name>
                <description>Security configuration for block y (y = 0 to 31) in super block n
Unprivileged write to this bit is ignored if PRIVy bit is set in GTZC1_MPCBB_PRIVCFGRn.
Writes are ignored if SPLCKn bit is set in GTZC1_MPCBB_CFGLOCK.</description>
                <bitOffset>0</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Non-secure access only to block y, belonging to super-block n. Secure access is also allowed if the SRWILADIS bit is set in GTZC1_MPCBB_CR.</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Secure access only to block y, belonging to super-block n.</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>SEC1</name>
                <description>Security configuration for block y (y = 0 to 31) in super block n
Unprivileged write to this bit is ignored if PRIVy bit is set in GTZC1_MPCBB_PRIVCFGRn.
Writes are ignored if SPLCKn bit is set in GTZC1_MPCBB_CFGLOCK.</description>
                <bitOffset>1</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Non-secure access only to block y, belonging to super-block n. Secure access is also allowed if the SRWILADIS bit is set in GTZC1_MPCBB_CR.</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Secure access only to block y, belonging to super-block n.</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>SEC2</name>
                <description>Security configuration for block y (y = 0 to 31) in super block n
Unprivileged write to this bit is ignored if PRIVy bit is set in GTZC1_MPCBB_PRIVCFGRn.
Writes are ignored if SPLCKn bit is set in GTZC1_MPCBB_CFGLOCK.</description>
                <bitOffset>2</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Non-secure access only to block y, belonging to super-block n. Secure access is also allowed if the SRWILADIS bit is set in GTZC1_MPCBB_CR.</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Secure access only to block y, belonging to super-block n.</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>SEC3</name>
                <description>Security configuration for block y (y = 0 to 31) in super block n
Unprivileged write to this bit is ignored if PRIVy bit is set in GTZC1_MPCBB_PRIVCFGRn.
Writes are ignored if SPLCKn bit is set in GTZC1_MPCBB_CFGLOCK.</description>
                <bitOffset>3</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Non-secure access only to block y, belonging to super-block n. Secure access is also allowed if the SRWILADIS bit is set in GTZC1_MPCBB_CR.</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Secure access only to block y, belonging to super-block n.</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>SEC4</name>
                <description>Security configuration for block y (y = 0 to 31) in super block n
Unprivileged write to this bit is ignored if PRIVy bit is set in GTZC1_MPCBB_PRIVCFGRn.
Writes are ignored if SPLCKn bit is set in GTZC1_MPCBB_CFGLOCK.</description>
                <bitOffset>4</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Non-secure access only to block y, belonging to super-block n. Secure access is also allowed if the SRWILADIS bit is set in GTZC1_MPCBB_CR.</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Secure access only to block y, belonging to super-block n.</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>SEC5</name>
                <description>Security configuration for block y (y = 0 to 31) in super block n
Unprivileged write to this bit is ignored if PRIVy bit is set in GTZC1_MPCBB_PRIVCFGRn.
Writes are ignored if SPLCKn bit is set in GTZC1_MPCBB_CFGLOCK.</description>
                <bitOffset>5</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Non-secure access only to block y, belonging to super-block n. Secure access is also allowed if the SRWILADIS bit is set in GTZC1_MPCBB_CR.</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Secure access only to block y, belonging to super-block n.</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>SEC6</name>
                <description>Security configuration for block y (y = 0 to 31) in super block n
Unprivileged write to this bit is ignored if PRIVy bit is set in GTZC1_MPCBB_PRIVCFGRn.
Writes are ignored if SPLCKn bit is set in GTZC1_MPCBB_CFGLOCK.</description>
                <bitOffset>6</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Non-secure access only to block y, belonging to super-block n. Secure access is also allowed if the SRWILADIS bit is set in GTZC1_MPCBB_CR.</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Secure access only to block y, belonging to super-block n.</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>SEC7</name>
                <description>Security configuration for block y (y = 0 to 31) in super block n
Unprivileged write to this bit is ignored if PRIVy bit is set in GTZC1_MPCBB_PRIVCFGRn.
Writes are ignored if SPLCKn bit is set in GTZC1_MPCBB_CFGLOCK.</description>
                <bitOffset>7</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Non-secure access only to block y, belonging to super-block n. Secure access is also allowed if the SRWILADIS bit is set in GTZC1_MPCBB_CR.</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Secure access only to block y, belonging to super-block n.</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>SEC8</name>
                <description>Security configuration for block y (y = 0 to 31) in super block n
Unprivileged write to this bit is ignored if PRIVy bit is set in GTZC1_MPCBB_PRIVCFGRn.
Writes are ignored if SPLCKn bit is set in GTZC1_MPCBB_CFGLOCK.</description>
                <bitOffset>8</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Non-secure access only to block y, belonging to super-block n. Secure access is also allowed if the SRWILADIS bit is set in GTZC1_MPCBB_CR.</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Secure access only to block y, belonging to super-block n.</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>SEC9</name>
                <description>Security configuration for block y (y = 0 to 31) in super block n
Unprivileged write to this bit is ignored if PRIVy bit is set in GTZC1_MPCBB_PRIVCFGRn.
Writes are ignored if SPLCKn bit is set in GTZC1_MPCBB_CFGLOCK.</description>
                <bitOffset>9</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Non-secure access only to block y, belonging to super-block n. Secure access is also allowed if the SRWILADIS bit is set in GTZC1_MPCBB_CR.</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Secure access only to block y, belonging to super-block n.</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>SEC10</name>
                <description>Security configuration for block y (y = 0 to 31) in super block n
Unprivileged write to this bit is ignored if PRIVy bit is set in GTZC1_MPCBB_PRIVCFGRn.
Writes are ignored if SPLCKn bit is set in GTZC1_MPCBB_CFGLOCK.</description>
                <bitOffset>10</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Non-secure access only to block y, belonging to super-block n. Secure access is also allowed if the SRWILADIS bit is set in GTZC1_MPCBB_CR.</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Secure access only to block y, belonging to super-block n.</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>SEC11</name>
                <description>Security configuration for block y (y = 0 to 31) in super block n
Unprivileged write to this bit is ignored if PRIVy bit is set in GTZC1_MPCBB_PRIVCFGRn.
Writes are ignored if SPLCKn bit is set in GTZC1_MPCBB_CFGLOCK.</description>
                <bitOffset>11</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Non-secure access only to block y, belonging to super-block n. Secure access is also allowed if the SRWILADIS bit is set in GTZC1_MPCBB_CR.</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Secure access only to block y, belonging to super-block n.</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>SEC12</name>
                <description>Security configuration for block y (y = 0 to 31) in super block n
Unprivileged write to this bit is ignored if PRIVy bit is set in GTZC1_MPCBB_PRIVCFGRn.
Writes are ignored if SPLCKn bit is set in GTZC1_MPCBB_CFGLOCK.</description>
                <bitOffset>12</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Non-secure access only to block y, belonging to super-block n. Secure access is also allowed if the SRWILADIS bit is set in GTZC1_MPCBB_CR.</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Secure access only to block y, belonging to super-block n.</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>SEC13</name>
                <description>Security configuration for block y (y = 0 to 31) in super block n
Unprivileged write to this bit is ignored if PRIVy bit is set in GTZC1_MPCBB_PRIVCFGRn.
Writes are ignored if SPLCKn bit is set in GTZC1_MPCBB_CFGLOCK.</description>
                <bitOffset>13</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Non-secure access only to block y, belonging to super-block n. Secure access is also allowed if the SRWILADIS bit is set in GTZC1_MPCBB_CR.</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Secure access only to block y, belonging to super-block n.</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>SEC14</name>
                <description>Security configuration for block y (y = 0 to 31) in super block n
Unprivileged write to this bit is ignored if PRIVy bit is set in GTZC1_MPCBB_PRIVCFGRn.
Writes are ignored if SPLCKn bit is set in GTZC1_MPCBB_CFGLOCK.</description>
                <bitOffset>14</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Non-secure access only to block y, belonging to super-block n. Secure access is also allowed if the SRWILADIS bit is set in GTZC1_MPCBB_CR.</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Secure access only to block y, belonging to super-block n.</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>SEC15</name>
                <description>Security configuration for block y (y = 0 to 31) in super block n
Unprivileged write to this bit is ignored if PRIVy bit is set in GTZC1_MPCBB_PRIVCFGRn.
Writes are ignored if SPLCKn bit is set in GTZC1_MPCBB_CFGLOCK.</description>
                <bitOffset>15</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Non-secure access only to block y, belonging to super-block n. Secure access is also allowed if the SRWILADIS bit is set in GTZC1_MPCBB_CR.</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Secure access only to block y, belonging to super-block n.</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>SEC16</name>
                <description>Security configuration for block y (y = 0 to 31) in super block n
Unprivileged write to this bit is ignored if PRIVy bit is set in GTZC1_MPCBB_PRIVCFGRn.
Writes are ignored if SPLCKn bit is set in GTZC1_MPCBB_CFGLOCK.</description>
                <bitOffset>16</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Non-secure access only to block y, belonging to super-block n. Secure access is also allowed if the SRWILADIS bit is set in GTZC1_MPCBB_CR.</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Secure access only to block y, belonging to super-block n.</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>SEC17</name>
                <description>Security configuration for block y (y = 0 to 31) in super block n
Unprivileged write to this bit is ignored if PRIVy bit is set in GTZC1_MPCBB_PRIVCFGRn.
Writes are ignored if SPLCKn bit is set in GTZC1_MPCBB_CFGLOCK.</description>
                <bitOffset>17</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Non-secure access only to block y, belonging to super-block n. Secure access is also allowed if the SRWILADIS bit is set in GTZC1_MPCBB_CR.</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Secure access only to block y, belonging to super-block n.</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>SEC18</name>
                <description>Security configuration for block y (y = 0 to 31) in super block n
Unprivileged write to this bit is ignored if PRIVy bit is set in GTZC1_MPCBB_PRIVCFGRn.
Writes are ignored if SPLCKn bit is set in GTZC1_MPCBB_CFGLOCK.</description>
                <bitOffset>18</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Non-secure access only to block y, belonging to super-block n. Secure access is also allowed if the SRWILADIS bit is set in GTZC1_MPCBB_CR.</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Secure access only to block y, belonging to super-block n.</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>SEC19</name>
                <description>Security configuration for block y (y = 0 to 31) in super block n
Unprivileged write to this bit is ignored if PRIVy bit is set in GTZC1_MPCBB_PRIVCFGRn.
Writes are ignored if SPLCKn bit is set in GTZC1_MPCBB_CFGLOCK.</description>
                <bitOffset>19</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Non-secure access only to block y, belonging to super-block n. Secure access is also allowed if the SRWILADIS bit is set in GTZC1_MPCBB_CR.</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Secure access only to block y, belonging to super-block n.</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>SEC20</name>
                <description>Security configuration for block y (y = 0 to 31) in super block n
Unprivileged write to this bit is ignored if PRIVy bit is set in GTZC1_MPCBB_PRIVCFGRn.
Writes are ignored if SPLCKn bit is set in GTZC1_MPCBB_CFGLOCK.</description>
                <bitOffset>20</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Non-secure access only to block y, belonging to super-block n. Secure access is also allowed if the SRWILADIS bit is set in GTZC1_MPCBB_CR.</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Secure access only to block y, belonging to super-block n.</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>SEC21</name>
                <description>Security configuration for block y (y = 0 to 31) in super block n
Unprivileged write to this bit is ignored if PRIVy bit is set in GTZC1_MPCBB_PRIVCFGRn.
Writes are ignored if SPLCKn bit is set in GTZC1_MPCBB_CFGLOCK.</description>
                <bitOffset>21</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Non-secure access only to block y, belonging to super-block n. Secure access is also allowed if the SRWILADIS bit is set in GTZC1_MPCBB_CR.</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Secure access only to block y, belonging to super-block n.</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>SEC22</name>
                <description>Security configuration for block y (y = 0 to 31) in super block n
Unprivileged write to this bit is ignored if PRIVy bit is set in GTZC1_MPCBB_PRIVCFGRn.
Writes are ignored if SPLCKn bit is set in GTZC1_MPCBB_CFGLOCK.</description>
                <bitOffset>22</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Non-secure access only to block y, belonging to super-block n. Secure access is also allowed if the SRWILADIS bit is set in GTZC1_MPCBB_CR.</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Secure access only to block y, belonging to super-block n.</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>SEC23</name>
                <description>Security configuration for block y (y = 0 to 31) in super block n
Unprivileged write to this bit is ignored if PRIVy bit is set in GTZC1_MPCBB_PRIVCFGRn.
Writes are ignored if SPLCKn bit is set in GTZC1_MPCBB_CFGLOCK.</description>
                <bitOffset>23</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Non-secure access only to block y, belonging to super-block n. Secure access is also allowed if the SRWILADIS bit is set in GTZC1_MPCBB_CR.</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Secure access only to block y, belonging to super-block n.</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>SEC24</name>
                <description>Security configuration for block y (y = 0 to 31) in super block n
Unprivileged write to this bit is ignored if PRIVy bit is set in GTZC1_MPCBB_PRIVCFGRn.
Writes are ignored if SPLCKn bit is set in GTZC1_MPCBB_CFGLOCK.</description>
                <bitOffset>24</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Non-secure access only to block y, belonging to super-block n. Secure access is also allowed if the SRWILADIS bit is set in GTZC1_MPCBB_CR.</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Secure access only to block y, belonging to super-block n.</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>SEC25</name>
                <description>Security configuration for block y (y = 0 to 31) in super block n
Unprivileged write to this bit is ignored if PRIVy bit is set in GTZC1_MPCBB_PRIVCFGRn.
Writes are ignored if SPLCKn bit is set in GTZC1_MPCBB_CFGLOCK.</description>
                <bitOffset>25</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Non-secure access only to block y, belonging to super-block n. Secure access is also allowed if the SRWILADIS bit is set in GTZC1_MPCBB_CR.</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Secure access only to block y, belonging to super-block n.</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>SEC26</name>
                <description>Security configuration for block y (y = 0 to 31) in super block n
Unprivileged write to this bit is ignored if PRIVy bit is set in GTZC1_MPCBB_PRIVCFGRn.
Writes are ignored if SPLCKn bit is set in GTZC1_MPCBB_CFGLOCK.</description>
                <bitOffset>26</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Non-secure access only to block y, belonging to super-block n. Secure access is also allowed if the SRWILADIS bit is set in GTZC1_MPCBB_CR.</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Secure access only to block y, belonging to super-block n.</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>SEC27</name>
                <description>Security configuration for block y (y = 0 to 31) in super block n
Unprivileged write to this bit is ignored if PRIVy bit is set in GTZC1_MPCBB_PRIVCFGRn.
Writes are ignored if SPLCKn bit is set in GTZC1_MPCBB_CFGLOCK.</description>
                <bitOffset>27</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Non-secure access only to block y, belonging to super-block n. Secure access is also allowed if the SRWILADIS bit is set in GTZC1_MPCBB_CR.</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Secure access only to block y, belonging to super-block n.</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>SEC28</name>
                <description>Security configuration for block y (y = 0 to 31) in super block n
Unprivileged write to this bit is ignored if PRIVy bit is set in GTZC1_MPCBB_PRIVCFGRn.
Writes are ignored if SPLCKn bit is set in GTZC1_MPCBB_CFGLOCK.</description>
                <bitOffset>28</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Non-secure access only to block y, belonging to super-block n. Secure access is also allowed if the SRWILADIS bit is set in GTZC1_MPCBB_CR.</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Secure access only to block y, belonging to super-block n.</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>SEC29</name>
                <description>Security configuration for block y (y = 0 to 31) in super block n
Unprivileged write to this bit is ignored if PRIVy bit is set in GTZC1_MPCBB_PRIVCFGRn.
Writes are ignored if SPLCKn bit is set in GTZC1_MPCBB_CFGLOCK.</description>
                <bitOffset>29</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Non-secure access only to block y, belonging to super-block n. Secure access is also allowed if the SRWILADIS bit is set in GTZC1_MPCBB_CR.</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Secure access only to block y, belonging to super-block n.</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>SEC30</name>
                <description>Security configuration for block y (y = 0 to 31) in super block n
Unprivileged write to this bit is ignored if PRIVy bit is set in GTZC1_MPCBB_PRIVCFGRn.
Writes are ignored if SPLCKn bit is set in GTZC1_MPCBB_CFGLOCK.</description>
                <bitOffset>30</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Non-secure access only to block y, belonging to super-block n. Secure access is also allowed if the SRWILADIS bit is set in GTZC1_MPCBB_CR.</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Secure access only to block y, belonging to super-block n.</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>SEC31</name>
                <description>Security configuration for block y (y = 0 to 31) in super block n
Unprivileged write to this bit is ignored if PRIVy bit is set in GTZC1_MPCBB_PRIVCFGRn.
Writes are ignored if SPLCKn bit is set in GTZC1_MPCBB_CFGLOCK.</description>
                <bitOffset>31</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Non-secure access only to block y, belonging to super-block n. Secure access is also allowed if the SRWILADIS bit is set in GTZC1_MPCBB_CR.</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Secure access only to block y, belonging to super-block n.</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
            </fields>
          </register>
          <register>
            <name>GTZC1_MPCBB_SECCFGR2</name>
            <displayName>GTZC1_MPCBB_SECCFGR2</displayName>
            <description>GTZC1 MPCBB security configuration for super-block 2 register</description>
            <addressOffset>0x108</addressOffset>
            <size>0x20</size>
            <resetValue>0xFFFFFFFF</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>SEC0</name>
                <description>Security configuration for block y (y = 0 to 31) in super block n
Unprivileged write to this bit is ignored if PRIVy bit is set in GTZC1_MPCBB_PRIVCFGRn.
Writes are ignored if SPLCKn bit is set in GTZC1_MPCBB_CFGLOCK.</description>
                <bitOffset>0</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Non-secure access only to block y, belonging to super-block n. Secure access is also allowed if the SRWILADIS bit is set in GTZC1_MPCBB_CR.</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Secure access only to block y, belonging to super-block n.</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>SEC1</name>
                <description>Security configuration for block y (y = 0 to 31) in super block n
Unprivileged write to this bit is ignored if PRIVy bit is set in GTZC1_MPCBB_PRIVCFGRn.
Writes are ignored if SPLCKn bit is set in GTZC1_MPCBB_CFGLOCK.</description>
                <bitOffset>1</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Non-secure access only to block y, belonging to super-block n. Secure access is also allowed if the SRWILADIS bit is set in GTZC1_MPCBB_CR.</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Secure access only to block y, belonging to super-block n.</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>SEC2</name>
                <description>Security configuration for block y (y = 0 to 31) in super block n
Unprivileged write to this bit is ignored if PRIVy bit is set in GTZC1_MPCBB_PRIVCFGRn.
Writes are ignored if SPLCKn bit is set in GTZC1_MPCBB_CFGLOCK.</description>
                <bitOffset>2</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Non-secure access only to block y, belonging to super-block n. Secure access is also allowed if the SRWILADIS bit is set in GTZC1_MPCBB_CR.</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Secure access only to block y, belonging to super-block n.</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>SEC3</name>
                <description>Security configuration for block y (y = 0 to 31) in super block n
Unprivileged write to this bit is ignored if PRIVy bit is set in GTZC1_MPCBB_PRIVCFGRn.
Writes are ignored if SPLCKn bit is set in GTZC1_MPCBB_CFGLOCK.</description>
                <bitOffset>3</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Non-secure access only to block y, belonging to super-block n. Secure access is also allowed if the SRWILADIS bit is set in GTZC1_MPCBB_CR.</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Secure access only to block y, belonging to super-block n.</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>SEC4</name>
                <description>Security configuration for block y (y = 0 to 31) in super block n
Unprivileged write to this bit is ignored if PRIVy bit is set in GTZC1_MPCBB_PRIVCFGRn.
Writes are ignored if SPLCKn bit is set in GTZC1_MPCBB_CFGLOCK.</description>
                <bitOffset>4</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Non-secure access only to block y, belonging to super-block n. Secure access is also allowed if the SRWILADIS bit is set in GTZC1_MPCBB_CR.</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Secure access only to block y, belonging to super-block n.</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>SEC5</name>
                <description>Security configuration for block y (y = 0 to 31) in super block n
Unprivileged write to this bit is ignored if PRIVy bit is set in GTZC1_MPCBB_PRIVCFGRn.
Writes are ignored if SPLCKn bit is set in GTZC1_MPCBB_CFGLOCK.</description>
                <bitOffset>5</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Non-secure access only to block y, belonging to super-block n. Secure access is also allowed if the SRWILADIS bit is set in GTZC1_MPCBB_CR.</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Secure access only to block y, belonging to super-block n.</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>SEC6</name>
                <description>Security configuration for block y (y = 0 to 31) in super block n
Unprivileged write to this bit is ignored if PRIVy bit is set in GTZC1_MPCBB_PRIVCFGRn.
Writes are ignored if SPLCKn bit is set in GTZC1_MPCBB_CFGLOCK.</description>
                <bitOffset>6</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Non-secure access only to block y, belonging to super-block n. Secure access is also allowed if the SRWILADIS bit is set in GTZC1_MPCBB_CR.</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Secure access only to block y, belonging to super-block n.</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>SEC7</name>
                <description>Security configuration for block y (y = 0 to 31) in super block n
Unprivileged write to this bit is ignored if PRIVy bit is set in GTZC1_MPCBB_PRIVCFGRn.
Writes are ignored if SPLCKn bit is set in GTZC1_MPCBB_CFGLOCK.</description>
                <bitOffset>7</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Non-secure access only to block y, belonging to super-block n. Secure access is also allowed if the SRWILADIS bit is set in GTZC1_MPCBB_CR.</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Secure access only to block y, belonging to super-block n.</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>SEC8</name>
                <description>Security configuration for block y (y = 0 to 31) in super block n
Unprivileged write to this bit is ignored if PRIVy bit is set in GTZC1_MPCBB_PRIVCFGRn.
Writes are ignored if SPLCKn bit is set in GTZC1_MPCBB_CFGLOCK.</description>
                <bitOffset>8</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Non-secure access only to block y, belonging to super-block n. Secure access is also allowed if the SRWILADIS bit is set in GTZC1_MPCBB_CR.</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Secure access only to block y, belonging to super-block n.</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>SEC9</name>
                <description>Security configuration for block y (y = 0 to 31) in super block n
Unprivileged write to this bit is ignored if PRIVy bit is set in GTZC1_MPCBB_PRIVCFGRn.
Writes are ignored if SPLCKn bit is set in GTZC1_MPCBB_CFGLOCK.</description>
                <bitOffset>9</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Non-secure access only to block y, belonging to super-block n. Secure access is also allowed if the SRWILADIS bit is set in GTZC1_MPCBB_CR.</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Secure access only to block y, belonging to super-block n.</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>SEC10</name>
                <description>Security configuration for block y (y = 0 to 31) in super block n
Unprivileged write to this bit is ignored if PRIVy bit is set in GTZC1_MPCBB_PRIVCFGRn.
Writes are ignored if SPLCKn bit is set in GTZC1_MPCBB_CFGLOCK.</description>
                <bitOffset>10</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Non-secure access only to block y, belonging to super-block n. Secure access is also allowed if the SRWILADIS bit is set in GTZC1_MPCBB_CR.</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Secure access only to block y, belonging to super-block n.</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>SEC11</name>
                <description>Security configuration for block y (y = 0 to 31) in super block n
Unprivileged write to this bit is ignored if PRIVy bit is set in GTZC1_MPCBB_PRIVCFGRn.
Writes are ignored if SPLCKn bit is set in GTZC1_MPCBB_CFGLOCK.</description>
                <bitOffset>11</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Non-secure access only to block y, belonging to super-block n. Secure access is also allowed if the SRWILADIS bit is set in GTZC1_MPCBB_CR.</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Secure access only to block y, belonging to super-block n.</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>SEC12</name>
                <description>Security configuration for block y (y = 0 to 31) in super block n
Unprivileged write to this bit is ignored if PRIVy bit is set in GTZC1_MPCBB_PRIVCFGRn.
Writes are ignored if SPLCKn bit is set in GTZC1_MPCBB_CFGLOCK.</description>
                <bitOffset>12</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Non-secure access only to block y, belonging to super-block n. Secure access is also allowed if the SRWILADIS bit is set in GTZC1_MPCBB_CR.</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Secure access only to block y, belonging to super-block n.</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>SEC13</name>
                <description>Security configuration for block y (y = 0 to 31) in super block n
Unprivileged write to this bit is ignored if PRIVy bit is set in GTZC1_MPCBB_PRIVCFGRn.
Writes are ignored if SPLCKn bit is set in GTZC1_MPCBB_CFGLOCK.</description>
                <bitOffset>13</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Non-secure access only to block y, belonging to super-block n. Secure access is also allowed if the SRWILADIS bit is set in GTZC1_MPCBB_CR.</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Secure access only to block y, belonging to super-block n.</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>SEC14</name>
                <description>Security configuration for block y (y = 0 to 31) in super block n
Unprivileged write to this bit is ignored if PRIVy bit is set in GTZC1_MPCBB_PRIVCFGRn.
Writes are ignored if SPLCKn bit is set in GTZC1_MPCBB_CFGLOCK.</description>
                <bitOffset>14</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Non-secure access only to block y, belonging to super-block n. Secure access is also allowed if the SRWILADIS bit is set in GTZC1_MPCBB_CR.</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Secure access only to block y, belonging to super-block n.</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>SEC15</name>
                <description>Security configuration for block y (y = 0 to 31) in super block n
Unprivileged write to this bit is ignored if PRIVy bit is set in GTZC1_MPCBB_PRIVCFGRn.
Writes are ignored if SPLCKn bit is set in GTZC1_MPCBB_CFGLOCK.</description>
                <bitOffset>15</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Non-secure access only to block y, belonging to super-block n. Secure access is also allowed if the SRWILADIS bit is set in GTZC1_MPCBB_CR.</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Secure access only to block y, belonging to super-block n.</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>SEC16</name>
                <description>Security configuration for block y (y = 0 to 31) in super block n
Unprivileged write to this bit is ignored if PRIVy bit is set in GTZC1_MPCBB_PRIVCFGRn.
Writes are ignored if SPLCKn bit is set in GTZC1_MPCBB_CFGLOCK.</description>
                <bitOffset>16</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Non-secure access only to block y, belonging to super-block n. Secure access is also allowed if the SRWILADIS bit is set in GTZC1_MPCBB_CR.</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Secure access only to block y, belonging to super-block n.</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>SEC17</name>
                <description>Security configuration for block y (y = 0 to 31) in super block n
Unprivileged write to this bit is ignored if PRIVy bit is set in GTZC1_MPCBB_PRIVCFGRn.
Writes are ignored if SPLCKn bit is set in GTZC1_MPCBB_CFGLOCK.</description>
                <bitOffset>17</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Non-secure access only to block y, belonging to super-block n. Secure access is also allowed if the SRWILADIS bit is set in GTZC1_MPCBB_CR.</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Secure access only to block y, belonging to super-block n.</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>SEC18</name>
                <description>Security configuration for block y (y = 0 to 31) in super block n
Unprivileged write to this bit is ignored if PRIVy bit is set in GTZC1_MPCBB_PRIVCFGRn.
Writes are ignored if SPLCKn bit is set in GTZC1_MPCBB_CFGLOCK.</description>
                <bitOffset>18</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Non-secure access only to block y, belonging to super-block n. Secure access is also allowed if the SRWILADIS bit is set in GTZC1_MPCBB_CR.</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Secure access only to block y, belonging to super-block n.</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>SEC19</name>
                <description>Security configuration for block y (y = 0 to 31) in super block n
Unprivileged write to this bit is ignored if PRIVy bit is set in GTZC1_MPCBB_PRIVCFGRn.
Writes are ignored if SPLCKn bit is set in GTZC1_MPCBB_CFGLOCK.</description>
                <bitOffset>19</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Non-secure access only to block y, belonging to super-block n. Secure access is also allowed if the SRWILADIS bit is set in GTZC1_MPCBB_CR.</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Secure access only to block y, belonging to super-block n.</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>SEC20</name>
                <description>Security configuration for block y (y = 0 to 31) in super block n
Unprivileged write to this bit is ignored if PRIVy bit is set in GTZC1_MPCBB_PRIVCFGRn.
Writes are ignored if SPLCKn bit is set in GTZC1_MPCBB_CFGLOCK.</description>
                <bitOffset>20</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Non-secure access only to block y, belonging to super-block n. Secure access is also allowed if the SRWILADIS bit is set in GTZC1_MPCBB_CR.</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Secure access only to block y, belonging to super-block n.</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>SEC21</name>
                <description>Security configuration for block y (y = 0 to 31) in super block n
Unprivileged write to this bit is ignored if PRIVy bit is set in GTZC1_MPCBB_PRIVCFGRn.
Writes are ignored if SPLCKn bit is set in GTZC1_MPCBB_CFGLOCK.</description>
                <bitOffset>21</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Non-secure access only to block y, belonging to super-block n. Secure access is also allowed if the SRWILADIS bit is set in GTZC1_MPCBB_CR.</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Secure access only to block y, belonging to super-block n.</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>SEC22</name>
                <description>Security configuration for block y (y = 0 to 31) in super block n
Unprivileged write to this bit is ignored if PRIVy bit is set in GTZC1_MPCBB_PRIVCFGRn.
Writes are ignored if SPLCKn bit is set in GTZC1_MPCBB_CFGLOCK.</description>
                <bitOffset>22</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Non-secure access only to block y, belonging to super-block n. Secure access is also allowed if the SRWILADIS bit is set in GTZC1_MPCBB_CR.</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Secure access only to block y, belonging to super-block n.</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>SEC23</name>
                <description>Security configuration for block y (y = 0 to 31) in super block n
Unprivileged write to this bit is ignored if PRIVy bit is set in GTZC1_MPCBB_PRIVCFGRn.
Writes are ignored if SPLCKn bit is set in GTZC1_MPCBB_CFGLOCK.</description>
                <bitOffset>23</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Non-secure access only to block y, belonging to super-block n. Secure access is also allowed if the SRWILADIS bit is set in GTZC1_MPCBB_CR.</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Secure access only to block y, belonging to super-block n.</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>SEC24</name>
                <description>Security configuration for block y (y = 0 to 31) in super block n
Unprivileged write to this bit is ignored if PRIVy bit is set in GTZC1_MPCBB_PRIVCFGRn.
Writes are ignored if SPLCKn bit is set in GTZC1_MPCBB_CFGLOCK.</description>
                <bitOffset>24</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Non-secure access only to block y, belonging to super-block n. Secure access is also allowed if the SRWILADIS bit is set in GTZC1_MPCBB_CR.</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Secure access only to block y, belonging to super-block n.</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>SEC25</name>
                <description>Security configuration for block y (y = 0 to 31) in super block n
Unprivileged write to this bit is ignored if PRIVy bit is set in GTZC1_MPCBB_PRIVCFGRn.
Writes are ignored if SPLCKn bit is set in GTZC1_MPCBB_CFGLOCK.</description>
                <bitOffset>25</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Non-secure access only to block y, belonging to super-block n. Secure access is also allowed if the SRWILADIS bit is set in GTZC1_MPCBB_CR.</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Secure access only to block y, belonging to super-block n.</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>SEC26</name>
                <description>Security configuration for block y (y = 0 to 31) in super block n
Unprivileged write to this bit is ignored if PRIVy bit is set in GTZC1_MPCBB_PRIVCFGRn.
Writes are ignored if SPLCKn bit is set in GTZC1_MPCBB_CFGLOCK.</description>
                <bitOffset>26</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Non-secure access only to block y, belonging to super-block n. Secure access is also allowed if the SRWILADIS bit is set in GTZC1_MPCBB_CR.</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Secure access only to block y, belonging to super-block n.</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>SEC27</name>
                <description>Security configuration for block y (y = 0 to 31) in super block n
Unprivileged write to this bit is ignored if PRIVy bit is set in GTZC1_MPCBB_PRIVCFGRn.
Writes are ignored if SPLCKn bit is set in GTZC1_MPCBB_CFGLOCK.</description>
                <bitOffset>27</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Non-secure access only to block y, belonging to super-block n. Secure access is also allowed if the SRWILADIS bit is set in GTZC1_MPCBB_CR.</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Secure access only to block y, belonging to super-block n.</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>SEC28</name>
                <description>Security configuration for block y (y = 0 to 31) in super block n
Unprivileged write to this bit is ignored if PRIVy bit is set in GTZC1_MPCBB_PRIVCFGRn.
Writes are ignored if SPLCKn bit is set in GTZC1_MPCBB_CFGLOCK.</description>
                <bitOffset>28</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Non-secure access only to block y, belonging to super-block n. Secure access is also allowed if the SRWILADIS bit is set in GTZC1_MPCBB_CR.</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Secure access only to block y, belonging to super-block n.</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>SEC29</name>
                <description>Security configuration for block y (y = 0 to 31) in super block n
Unprivileged write to this bit is ignored if PRIVy bit is set in GTZC1_MPCBB_PRIVCFGRn.
Writes are ignored if SPLCKn bit is set in GTZC1_MPCBB_CFGLOCK.</description>
                <bitOffset>29</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Non-secure access only to block y, belonging to super-block n. Secure access is also allowed if the SRWILADIS bit is set in GTZC1_MPCBB_CR.</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Secure access only to block y, belonging to super-block n.</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>SEC30</name>
                <description>Security configuration for block y (y = 0 to 31) in super block n
Unprivileged write to this bit is ignored if PRIVy bit is set in GTZC1_MPCBB_PRIVCFGRn.
Writes are ignored if SPLCKn bit is set in GTZC1_MPCBB_CFGLOCK.</description>
                <bitOffset>30</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Non-secure access only to block y, belonging to super-block n. Secure access is also allowed if the SRWILADIS bit is set in GTZC1_MPCBB_CR.</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Secure access only to block y, belonging to super-block n.</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>SEC31</name>
                <description>Security configuration for block y (y = 0 to 31) in super block n
Unprivileged write to this bit is ignored if PRIVy bit is set in GTZC1_MPCBB_PRIVCFGRn.
Writes are ignored if SPLCKn bit is set in GTZC1_MPCBB_CFGLOCK.</description>
                <bitOffset>31</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Non-secure access only to block y, belonging to super-block n. Secure access is also allowed if the SRWILADIS bit is set in GTZC1_MPCBB_CR.</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Secure access only to block y, belonging to super-block n.</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
            </fields>
          </register>
          <register>
            <name>GTZC1_MPCBB_SECCFGR3</name>
            <displayName>GTZC1_MPCBB_SECCFGR3</displayName>
            <description>GTZC1 MPCBB security configuration for super-block 3 register</description>
            <addressOffset>0x10C</addressOffset>
            <size>0x20</size>
            <resetValue>0xFFFFFFFF</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>SEC0</name>
                <description>Security configuration for block y (y = 0 to 31) in super block n
Unprivileged write to this bit is ignored if PRIVy bit is set in GTZC1_MPCBB_PRIVCFGRn.
Writes are ignored if SPLCKn bit is set in GTZC1_MPCBB_CFGLOCK.</description>
                <bitOffset>0</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Non-secure access only to block y, belonging to super-block n. Secure access is also allowed if the SRWILADIS bit is set in GTZC1_MPCBB_CR.</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Secure access only to block y, belonging to super-block n.</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>SEC1</name>
                <description>Security configuration for block y (y = 0 to 31) in super block n
Unprivileged write to this bit is ignored if PRIVy bit is set in GTZC1_MPCBB_PRIVCFGRn.
Writes are ignored if SPLCKn bit is set in GTZC1_MPCBB_CFGLOCK.</description>
                <bitOffset>1</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Non-secure access only to block y, belonging to super-block n. Secure access is also allowed if the SRWILADIS bit is set in GTZC1_MPCBB_CR.</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Secure access only to block y, belonging to super-block n.</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>SEC2</name>
                <description>Security configuration for block y (y = 0 to 31) in super block n
Unprivileged write to this bit is ignored if PRIVy bit is set in GTZC1_MPCBB_PRIVCFGRn.
Writes are ignored if SPLCKn bit is set in GTZC1_MPCBB_CFGLOCK.</description>
                <bitOffset>2</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Non-secure access only to block y, belonging to super-block n. Secure access is also allowed if the SRWILADIS bit is set in GTZC1_MPCBB_CR.</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Secure access only to block y, belonging to super-block n.</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>SEC3</name>
                <description>Security configuration for block y (y = 0 to 31) in super block n
Unprivileged write to this bit is ignored if PRIVy bit is set in GTZC1_MPCBB_PRIVCFGRn.
Writes are ignored if SPLCKn bit is set in GTZC1_MPCBB_CFGLOCK.</description>
                <bitOffset>3</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Non-secure access only to block y, belonging to super-block n. Secure access is also allowed if the SRWILADIS bit is set in GTZC1_MPCBB_CR.</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Secure access only to block y, belonging to super-block n.</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>SEC4</name>
                <description>Security configuration for block y (y = 0 to 31) in super block n
Unprivileged write to this bit is ignored if PRIVy bit is set in GTZC1_MPCBB_PRIVCFGRn.
Writes are ignored if SPLCKn bit is set in GTZC1_MPCBB_CFGLOCK.</description>
                <bitOffset>4</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Non-secure access only to block y, belonging to super-block n. Secure access is also allowed if the SRWILADIS bit is set in GTZC1_MPCBB_CR.</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Secure access only to block y, belonging to super-block n.</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>SEC5</name>
                <description>Security configuration for block y (y = 0 to 31) in super block n
Unprivileged write to this bit is ignored if PRIVy bit is set in GTZC1_MPCBB_PRIVCFGRn.
Writes are ignored if SPLCKn bit is set in GTZC1_MPCBB_CFGLOCK.</description>
                <bitOffset>5</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Non-secure access only to block y, belonging to super-block n. Secure access is also allowed if the SRWILADIS bit is set in GTZC1_MPCBB_CR.</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Secure access only to block y, belonging to super-block n.</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>SEC6</name>
                <description>Security configuration for block y (y = 0 to 31) in super block n
Unprivileged write to this bit is ignored if PRIVy bit is set in GTZC1_MPCBB_PRIVCFGRn.
Writes are ignored if SPLCKn bit is set in GTZC1_MPCBB_CFGLOCK.</description>
                <bitOffset>6</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Non-secure access only to block y, belonging to super-block n. Secure access is also allowed if the SRWILADIS bit is set in GTZC1_MPCBB_CR.</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Secure access only to block y, belonging to super-block n.</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>SEC7</name>
                <description>Security configuration for block y (y = 0 to 31) in super block n
Unprivileged write to this bit is ignored if PRIVy bit is set in GTZC1_MPCBB_PRIVCFGRn.
Writes are ignored if SPLCKn bit is set in GTZC1_MPCBB_CFGLOCK.</description>
                <bitOffset>7</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Non-secure access only to block y, belonging to super-block n. Secure access is also allowed if the SRWILADIS bit is set in GTZC1_MPCBB_CR.</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Secure access only to block y, belonging to super-block n.</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>SEC8</name>
                <description>Security configuration for block y (y = 0 to 31) in super block n
Unprivileged write to this bit is ignored if PRIVy bit is set in GTZC1_MPCBB_PRIVCFGRn.
Writes are ignored if SPLCKn bit is set in GTZC1_MPCBB_CFGLOCK.</description>
                <bitOffset>8</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Non-secure access only to block y, belonging to super-block n. Secure access is also allowed if the SRWILADIS bit is set in GTZC1_MPCBB_CR.</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Secure access only to block y, belonging to super-block n.</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>SEC9</name>
                <description>Security configuration for block y (y = 0 to 31) in super block n
Unprivileged write to this bit is ignored if PRIVy bit is set in GTZC1_MPCBB_PRIVCFGRn.
Writes are ignored if SPLCKn bit is set in GTZC1_MPCBB_CFGLOCK.</description>
                <bitOffset>9</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Non-secure access only to block y, belonging to super-block n. Secure access is also allowed if the SRWILADIS bit is set in GTZC1_MPCBB_CR.</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Secure access only to block y, belonging to super-block n.</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>SEC10</name>
                <description>Security configuration for block y (y = 0 to 31) in super block n
Unprivileged write to this bit is ignored if PRIVy bit is set in GTZC1_MPCBB_PRIVCFGRn.
Writes are ignored if SPLCKn bit is set in GTZC1_MPCBB_CFGLOCK.</description>
                <bitOffset>10</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Non-secure access only to block y, belonging to super-block n. Secure access is also allowed if the SRWILADIS bit is set in GTZC1_MPCBB_CR.</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Secure access only to block y, belonging to super-block n.</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>SEC11</name>
                <description>Security configuration for block y (y = 0 to 31) in super block n
Unprivileged write to this bit is ignored if PRIVy bit is set in GTZC1_MPCBB_PRIVCFGRn.
Writes are ignored if SPLCKn bit is set in GTZC1_MPCBB_CFGLOCK.</description>
                <bitOffset>11</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Non-secure access only to block y, belonging to super-block n. Secure access is also allowed if the SRWILADIS bit is set in GTZC1_MPCBB_CR.</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Secure access only to block y, belonging to super-block n.</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>SEC12</name>
                <description>Security configuration for block y (y = 0 to 31) in super block n
Unprivileged write to this bit is ignored if PRIVy bit is set in GTZC1_MPCBB_PRIVCFGRn.
Writes are ignored if SPLCKn bit is set in GTZC1_MPCBB_CFGLOCK.</description>
                <bitOffset>12</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Non-secure access only to block y, belonging to super-block n. Secure access is also allowed if the SRWILADIS bit is set in GTZC1_MPCBB_CR.</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Secure access only to block y, belonging to super-block n.</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>SEC13</name>
                <description>Security configuration for block y (y = 0 to 31) in super block n
Unprivileged write to this bit is ignored if PRIVy bit is set in GTZC1_MPCBB_PRIVCFGRn.
Writes are ignored if SPLCKn bit is set in GTZC1_MPCBB_CFGLOCK.</description>
                <bitOffset>13</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Non-secure access only to block y, belonging to super-block n. Secure access is also allowed if the SRWILADIS bit is set in GTZC1_MPCBB_CR.</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Secure access only to block y, belonging to super-block n.</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>SEC14</name>
                <description>Security configuration for block y (y = 0 to 31) in super block n
Unprivileged write to this bit is ignored if PRIVy bit is set in GTZC1_MPCBB_PRIVCFGRn.
Writes are ignored if SPLCKn bit is set in GTZC1_MPCBB_CFGLOCK.</description>
                <bitOffset>14</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Non-secure access only to block y, belonging to super-block n. Secure access is also allowed if the SRWILADIS bit is set in GTZC1_MPCBB_CR.</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Secure access only to block y, belonging to super-block n.</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>SEC15</name>
                <description>Security configuration for block y (y = 0 to 31) in super block n
Unprivileged write to this bit is ignored if PRIVy bit is set in GTZC1_MPCBB_PRIVCFGRn.
Writes are ignored if SPLCKn bit is set in GTZC1_MPCBB_CFGLOCK.</description>
                <bitOffset>15</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Non-secure access only to block y, belonging to super-block n. Secure access is also allowed if the SRWILADIS bit is set in GTZC1_MPCBB_CR.</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Secure access only to block y, belonging to super-block n.</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>SEC16</name>
                <description>Security configuration for block y (y = 0 to 31) in super block n
Unprivileged write to this bit is ignored if PRIVy bit is set in GTZC1_MPCBB_PRIVCFGRn.
Writes are ignored if SPLCKn bit is set in GTZC1_MPCBB_CFGLOCK.</description>
                <bitOffset>16</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Non-secure access only to block y, belonging to super-block n. Secure access is also allowed if the SRWILADIS bit is set in GTZC1_MPCBB_CR.</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Secure access only to block y, belonging to super-block n.</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>SEC17</name>
                <description>Security configuration for block y (y = 0 to 31) in super block n
Unprivileged write to this bit is ignored if PRIVy bit is set in GTZC1_MPCBB_PRIVCFGRn.
Writes are ignored if SPLCKn bit is set in GTZC1_MPCBB_CFGLOCK.</description>
                <bitOffset>17</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Non-secure access only to block y, belonging to super-block n. Secure access is also allowed if the SRWILADIS bit is set in GTZC1_MPCBB_CR.</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Secure access only to block y, belonging to super-block n.</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>SEC18</name>
                <description>Security configuration for block y (y = 0 to 31) in super block n
Unprivileged write to this bit is ignored if PRIVy bit is set in GTZC1_MPCBB_PRIVCFGRn.
Writes are ignored if SPLCKn bit is set in GTZC1_MPCBB_CFGLOCK.</description>
                <bitOffset>18</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Non-secure access only to block y, belonging to super-block n. Secure access is also allowed if the SRWILADIS bit is set in GTZC1_MPCBB_CR.</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Secure access only to block y, belonging to super-block n.</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>SEC19</name>
                <description>Security configuration for block y (y = 0 to 31) in super block n
Unprivileged write to this bit is ignored if PRIVy bit is set in GTZC1_MPCBB_PRIVCFGRn.
Writes are ignored if SPLCKn bit is set in GTZC1_MPCBB_CFGLOCK.</description>
                <bitOffset>19</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Non-secure access only to block y, belonging to super-block n. Secure access is also allowed if the SRWILADIS bit is set in GTZC1_MPCBB_CR.</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Secure access only to block y, belonging to super-block n.</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>SEC20</name>
                <description>Security configuration for block y (y = 0 to 31) in super block n
Unprivileged write to this bit is ignored if PRIVy bit is set in GTZC1_MPCBB_PRIVCFGRn.
Writes are ignored if SPLCKn bit is set in GTZC1_MPCBB_CFGLOCK.</description>
                <bitOffset>20</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Non-secure access only to block y, belonging to super-block n. Secure access is also allowed if the SRWILADIS bit is set in GTZC1_MPCBB_CR.</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Secure access only to block y, belonging to super-block n.</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>SEC21</name>
                <description>Security configuration for block y (y = 0 to 31) in super block n
Unprivileged write to this bit is ignored if PRIVy bit is set in GTZC1_MPCBB_PRIVCFGRn.
Writes are ignored if SPLCKn bit is set in GTZC1_MPCBB_CFGLOCK.</description>
                <bitOffset>21</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Non-secure access only to block y, belonging to super-block n. Secure access is also allowed if the SRWILADIS bit is set in GTZC1_MPCBB_CR.</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Secure access only to block y, belonging to super-block n.</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>SEC22</name>
                <description>Security configuration for block y (y = 0 to 31) in super block n
Unprivileged write to this bit is ignored if PRIVy bit is set in GTZC1_MPCBB_PRIVCFGRn.
Writes are ignored if SPLCKn bit is set in GTZC1_MPCBB_CFGLOCK.</description>
                <bitOffset>22</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Non-secure access only to block y, belonging to super-block n. Secure access is also allowed if the SRWILADIS bit is set in GTZC1_MPCBB_CR.</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Secure access only to block y, belonging to super-block n.</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>SEC23</name>
                <description>Security configuration for block y (y = 0 to 31) in super block n
Unprivileged write to this bit is ignored if PRIVy bit is set in GTZC1_MPCBB_PRIVCFGRn.
Writes are ignored if SPLCKn bit is set in GTZC1_MPCBB_CFGLOCK.</description>
                <bitOffset>23</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Non-secure access only to block y, belonging to super-block n. Secure access is also allowed if the SRWILADIS bit is set in GTZC1_MPCBB_CR.</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Secure access only to block y, belonging to super-block n.</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>SEC24</name>
                <description>Security configuration for block y (y = 0 to 31) in super block n
Unprivileged write to this bit is ignored if PRIVy bit is set in GTZC1_MPCBB_PRIVCFGRn.
Writes are ignored if SPLCKn bit is set in GTZC1_MPCBB_CFGLOCK.</description>
                <bitOffset>24</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Non-secure access only to block y, belonging to super-block n. Secure access is also allowed if the SRWILADIS bit is set in GTZC1_MPCBB_CR.</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Secure access only to block y, belonging to super-block n.</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>SEC25</name>
                <description>Security configuration for block y (y = 0 to 31) in super block n
Unprivileged write to this bit is ignored if PRIVy bit is set in GTZC1_MPCBB_PRIVCFGRn.
Writes are ignored if SPLCKn bit is set in GTZC1_MPCBB_CFGLOCK.</description>
                <bitOffset>25</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Non-secure access only to block y, belonging to super-block n. Secure access is also allowed if the SRWILADIS bit is set in GTZC1_MPCBB_CR.</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Secure access only to block y, belonging to super-block n.</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>SEC26</name>
                <description>Security configuration for block y (y = 0 to 31) in super block n
Unprivileged write to this bit is ignored if PRIVy bit is set in GTZC1_MPCBB_PRIVCFGRn.
Writes are ignored if SPLCKn bit is set in GTZC1_MPCBB_CFGLOCK.</description>
                <bitOffset>26</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Non-secure access only to block y, belonging to super-block n. Secure access is also allowed if the SRWILADIS bit is set in GTZC1_MPCBB_CR.</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Secure access only to block y, belonging to super-block n.</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>SEC27</name>
                <description>Security configuration for block y (y = 0 to 31) in super block n
Unprivileged write to this bit is ignored if PRIVy bit is set in GTZC1_MPCBB_PRIVCFGRn.
Writes are ignored if SPLCKn bit is set in GTZC1_MPCBB_CFGLOCK.</description>
                <bitOffset>27</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Non-secure access only to block y, belonging to super-block n. Secure access is also allowed if the SRWILADIS bit is set in GTZC1_MPCBB_CR.</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Secure access only to block y, belonging to super-block n.</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>SEC28</name>
                <description>Security configuration for block y (y = 0 to 31) in super block n
Unprivileged write to this bit is ignored if PRIVy bit is set in GTZC1_MPCBB_PRIVCFGRn.
Writes are ignored if SPLCKn bit is set in GTZC1_MPCBB_CFGLOCK.</description>
                <bitOffset>28</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Non-secure access only to block y, belonging to super-block n. Secure access is also allowed if the SRWILADIS bit is set in GTZC1_MPCBB_CR.</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Secure access only to block y, belonging to super-block n.</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>SEC29</name>
                <description>Security configuration for block y (y = 0 to 31) in super block n
Unprivileged write to this bit is ignored if PRIVy bit is set in GTZC1_MPCBB_PRIVCFGRn.
Writes are ignored if SPLCKn bit is set in GTZC1_MPCBB_CFGLOCK.</description>
                <bitOffset>29</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Non-secure access only to block y, belonging to super-block n. Secure access is also allowed if the SRWILADIS bit is set in GTZC1_MPCBB_CR.</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Secure access only to block y, belonging to super-block n.</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>SEC30</name>
                <description>Security configuration for block y (y = 0 to 31) in super block n
Unprivileged write to this bit is ignored if PRIVy bit is set in GTZC1_MPCBB_PRIVCFGRn.
Writes are ignored if SPLCKn bit is set in GTZC1_MPCBB_CFGLOCK.</description>
                <bitOffset>30</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Non-secure access only to block y, belonging to super-block n. Secure access is also allowed if the SRWILADIS bit is set in GTZC1_MPCBB_CR.</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Secure access only to block y, belonging to super-block n.</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>SEC31</name>
                <description>Security configuration for block y (y = 0 to 31) in super block n
Unprivileged write to this bit is ignored if PRIVy bit is set in GTZC1_MPCBB_PRIVCFGRn.
Writes are ignored if SPLCKn bit is set in GTZC1_MPCBB_CFGLOCK.</description>
                <bitOffset>31</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Non-secure access only to block y, belonging to super-block n. Secure access is also allowed if the SRWILADIS bit is set in GTZC1_MPCBB_CR.</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Secure access only to block y, belonging to super-block n.</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
            </fields>
          </register>
          <register>
            <name>GTZC1_MPCBB_PRIVCFGR0</name>
            <displayName>GTZC1_MPCBB_PRIVCFGR0</displayName>
            <description>GTZC1 MPCBB privileged configuration for super-block 0	register</description>
            <addressOffset>0x200</addressOffset>
            <size>0x20</size>
            <resetValue>0xFFFFFFFF</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>PRIV0</name>
                <description>Privileged configuration for block y (y = 0 to 31), belonging to super-block n.
Non-secure write to this bit is ignored if SECy bit is set in GTZC1_MPCBB_SECCFGRn.
Writes are ignored if SPLCKn bit is set in GTZC1_MPCBB_CFGLOCK.</description>
                <bitOffset>0</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Privileged and unprivileged access to block y, belonging to super-block n</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Only privileged access to block y, belonging to super-block n</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>PRIV1</name>
                <description>Privileged configuration for block y (y = 0 to 31), belonging to super-block n.
Non-secure write to this bit is ignored if SECy bit is set in GTZC1_MPCBB_SECCFGRn.
Writes are ignored if SPLCKn bit is set in GTZC1_MPCBB_CFGLOCK.</description>
                <bitOffset>1</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Privileged and unprivileged access to block y, belonging to super-block n</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Only privileged access to block y, belonging to super-block n</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>PRIV2</name>
                <description>Privileged configuration for block y (y = 0 to 31), belonging to super-block n.
Non-secure write to this bit is ignored if SECy bit is set in GTZC1_MPCBB_SECCFGRn.
Writes are ignored if SPLCKn bit is set in GTZC1_MPCBB_CFGLOCK.</description>
                <bitOffset>2</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Privileged and unprivileged access to block y, belonging to super-block n</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Only privileged access to block y, belonging to super-block n</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>PRIV3</name>
                <description>Privileged configuration for block y (y = 0 to 31), belonging to super-block n.
Non-secure write to this bit is ignored if SECy bit is set in GTZC1_MPCBB_SECCFGRn.
Writes are ignored if SPLCKn bit is set in GTZC1_MPCBB_CFGLOCK.</description>
                <bitOffset>3</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Privileged and unprivileged access to block y, belonging to super-block n</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Only privileged access to block y, belonging to super-block n</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>PRIV4</name>
                <description>Privileged configuration for block y (y = 0 to 31), belonging to super-block n.
Non-secure write to this bit is ignored if SECy bit is set in GTZC1_MPCBB_SECCFGRn.
Writes are ignored if SPLCKn bit is set in GTZC1_MPCBB_CFGLOCK.</description>
                <bitOffset>4</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Privileged and unprivileged access to block y, belonging to super-block n</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Only privileged access to block y, belonging to super-block n</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>PRIV5</name>
                <description>Privileged configuration for block y (y = 0 to 31), belonging to super-block n.
Non-secure write to this bit is ignored if SECy bit is set in GTZC1_MPCBB_SECCFGRn.
Writes are ignored if SPLCKn bit is set in GTZC1_MPCBB_CFGLOCK.</description>
                <bitOffset>5</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Privileged and unprivileged access to block y, belonging to super-block n</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Only privileged access to block y, belonging to super-block n</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>PRIV6</name>
                <description>Privileged configuration for block y (y = 0 to 31), belonging to super-block n.
Non-secure write to this bit is ignored if SECy bit is set in GTZC1_MPCBB_SECCFGRn.
Writes are ignored if SPLCKn bit is set in GTZC1_MPCBB_CFGLOCK.</description>
                <bitOffset>6</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Privileged and unprivileged access to block y, belonging to super-block n</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Only privileged access to block y, belonging to super-block n</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>PRIV7</name>
                <description>Privileged configuration for block y (y = 0 to 31), belonging to super-block n.
Non-secure write to this bit is ignored if SECy bit is set in GTZC1_MPCBB_SECCFGRn.
Writes are ignored if SPLCKn bit is set in GTZC1_MPCBB_CFGLOCK.</description>
                <bitOffset>7</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Privileged and unprivileged access to block y, belonging to super-block n</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Only privileged access to block y, belonging to super-block n</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>PRIV8</name>
                <description>Privileged configuration for block y (y = 0 to 31), belonging to super-block n.
Non-secure write to this bit is ignored if SECy bit is set in GTZC1_MPCBB_SECCFGRn.
Writes are ignored if SPLCKn bit is set in GTZC1_MPCBB_CFGLOCK.</description>
                <bitOffset>8</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Privileged and unprivileged access to block y, belonging to super-block n</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Only privileged access to block y, belonging to super-block n</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>PRIV9</name>
                <description>Privileged configuration for block y (y = 0 to 31), belonging to super-block n.
Non-secure write to this bit is ignored if SECy bit is set in GTZC1_MPCBB_SECCFGRn.
Writes are ignored if SPLCKn bit is set in GTZC1_MPCBB_CFGLOCK.</description>
                <bitOffset>9</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Privileged and unprivileged access to block y, belonging to super-block n</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Only privileged access to block y, belonging to super-block n</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>PRIV10</name>
                <description>Privileged configuration for block y (y = 0 to 31), belonging to super-block n.
Non-secure write to this bit is ignored if SECy bit is set in GTZC1_MPCBB_SECCFGRn.
Writes are ignored if SPLCKn bit is set in GTZC1_MPCBB_CFGLOCK.</description>
                <bitOffset>10</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Privileged and unprivileged access to block y, belonging to super-block n</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Only privileged access to block y, belonging to super-block n</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>PRIV11</name>
                <description>Privileged configuration for block y (y = 0 to 31), belonging to super-block n.
Non-secure write to this bit is ignored if SECy bit is set in GTZC1_MPCBB_SECCFGRn.
Writes are ignored if SPLCKn bit is set in GTZC1_MPCBB_CFGLOCK.</description>
                <bitOffset>11</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Privileged and unprivileged access to block y, belonging to super-block n</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Only privileged access to block y, belonging to super-block n</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>PRIV12</name>
                <description>Privileged configuration for block y (y = 0 to 31), belonging to super-block n.
Non-secure write to this bit is ignored if SECy bit is set in GTZC1_MPCBB_SECCFGRn.
Writes are ignored if SPLCKn bit is set in GTZC1_MPCBB_CFGLOCK.</description>
                <bitOffset>12</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Privileged and unprivileged access to block y, belonging to super-block n</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Only privileged access to block y, belonging to super-block n</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>PRIV13</name>
                <description>Privileged configuration for block y (y = 0 to 31), belonging to super-block n.
Non-secure write to this bit is ignored if SECy bit is set in GTZC1_MPCBB_SECCFGRn.
Writes are ignored if SPLCKn bit is set in GTZC1_MPCBB_CFGLOCK.</description>
                <bitOffset>13</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Privileged and unprivileged access to block y, belonging to super-block n</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Only privileged access to block y, belonging to super-block n</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>PRIV14</name>
                <description>Privileged configuration for block y (y = 0 to 31), belonging to super-block n.
Non-secure write to this bit is ignored if SECy bit is set in GTZC1_MPCBB_SECCFGRn.
Writes are ignored if SPLCKn bit is set in GTZC1_MPCBB_CFGLOCK.</description>
                <bitOffset>14</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Privileged and unprivileged access to block y, belonging to super-block n</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Only privileged access to block y, belonging to super-block n</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>PRIV15</name>
                <description>Privileged configuration for block y (y = 0 to 31), belonging to super-block n.
Non-secure write to this bit is ignored if SECy bit is set in GTZC1_MPCBB_SECCFGRn.
Writes are ignored if SPLCKn bit is set in GTZC1_MPCBB_CFGLOCK.</description>
                <bitOffset>15</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Privileged and unprivileged access to block y, belonging to super-block n</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Only privileged access to block y, belonging to super-block n</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>PRIV16</name>
                <description>Privileged configuration for block y (y = 0 to 31), belonging to super-block n.
Non-secure write to this bit is ignored if SECy bit is set in GTZC1_MPCBB_SECCFGRn.
Writes are ignored if SPLCKn bit is set in GTZC1_MPCBB_CFGLOCK.</description>
                <bitOffset>16</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Privileged and unprivileged access to block y, belonging to super-block n</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Only privileged access to block y, belonging to super-block n</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>PRIV17</name>
                <description>Privileged configuration for block y (y = 0 to 31), belonging to super-block n.
Non-secure write to this bit is ignored if SECy bit is set in GTZC1_MPCBB_SECCFGRn.
Writes are ignored if SPLCKn bit is set in GTZC1_MPCBB_CFGLOCK.</description>
                <bitOffset>17</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Privileged and unprivileged access to block y, belonging to super-block n</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Only privileged access to block y, belonging to super-block n</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>PRIV18</name>
                <description>Privileged configuration for block y (y = 0 to 31), belonging to super-block n.
Non-secure write to this bit is ignored if SECy bit is set in GTZC1_MPCBB_SECCFGRn.
Writes are ignored if SPLCKn bit is set in GTZC1_MPCBB_CFGLOCK.</description>
                <bitOffset>18</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Privileged and unprivileged access to block y, belonging to super-block n</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Only privileged access to block y, belonging to super-block n</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>PRIV19</name>
                <description>Privileged configuration for block y (y = 0 to 31), belonging to super-block n.
Non-secure write to this bit is ignored if SECy bit is set in GTZC1_MPCBB_SECCFGRn.
Writes are ignored if SPLCKn bit is set in GTZC1_MPCBB_CFGLOCK.</description>
                <bitOffset>19</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Privileged and unprivileged access to block y, belonging to super-block n</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Only privileged access to block y, belonging to super-block n</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>PRIV20</name>
                <description>Privileged configuration for block y (y = 0 to 31), belonging to super-block n.
Non-secure write to this bit is ignored if SECy bit is set in GTZC1_MPCBB_SECCFGRn.
Writes are ignored if SPLCKn bit is set in GTZC1_MPCBB_CFGLOCK.</description>
                <bitOffset>20</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Privileged and unprivileged access to block y, belonging to super-block n</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Only privileged access to block y, belonging to super-block n</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>PRIV21</name>
                <description>Privileged configuration for block y (y = 0 to 31), belonging to super-block n.
Non-secure write to this bit is ignored if SECy bit is set in GTZC1_MPCBB_SECCFGRn.
Writes are ignored if SPLCKn bit is set in GTZC1_MPCBB_CFGLOCK.</description>
                <bitOffset>21</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Privileged and unprivileged access to block y, belonging to super-block n</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Only privileged access to block y, belonging to super-block n</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>PRIV22</name>
                <description>Privileged configuration for block y (y = 0 to 31), belonging to super-block n.
Non-secure write to this bit is ignored if SECy bit is set in GTZC1_MPCBB_SECCFGRn.
Writes are ignored if SPLCKn bit is set in GTZC1_MPCBB_CFGLOCK.</description>
                <bitOffset>22</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Privileged and unprivileged access to block y, belonging to super-block n</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Only privileged access to block y, belonging to super-block n</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>PRIV23</name>
                <description>Privileged configuration for block y (y = 0 to 31), belonging to super-block n.
Non-secure write to this bit is ignored if SECy bit is set in GTZC1_MPCBB_SECCFGRn.
Writes are ignored if SPLCKn bit is set in GTZC1_MPCBB_CFGLOCK.</description>
                <bitOffset>23</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Privileged and unprivileged access to block y, belonging to super-block n</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Only privileged access to block y, belonging to super-block n</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>PRIV24</name>
                <description>Privileged configuration for block y (y = 0 to 31), belonging to super-block n.
Non-secure write to this bit is ignored if SECy bit is set in GTZC1_MPCBB_SECCFGRn.
Writes are ignored if SPLCKn bit is set in GTZC1_MPCBB_CFGLOCK.</description>
                <bitOffset>24</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Privileged and unprivileged access to block y, belonging to super-block n</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Only privileged access to block y, belonging to super-block n</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>PRIV25</name>
                <description>Privileged configuration for block y (y = 0 to 31), belonging to super-block n.
Non-secure write to this bit is ignored if SECy bit is set in GTZC1_MPCBB_SECCFGRn.
Writes are ignored if SPLCKn bit is set in GTZC1_MPCBB_CFGLOCK.</description>
                <bitOffset>25</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Privileged and unprivileged access to block y, belonging to super-block n</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Only privileged access to block y, belonging to super-block n</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>PRIV26</name>
                <description>Privileged configuration for block y (y = 0 to 31), belonging to super-block n.
Non-secure write to this bit is ignored if SECy bit is set in GTZC1_MPCBB_SECCFGRn.
Writes are ignored if SPLCKn bit is set in GTZC1_MPCBB_CFGLOCK.</description>
                <bitOffset>26</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Privileged and unprivileged access to block y, belonging to super-block n</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Only privileged access to block y, belonging to super-block n</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>PRIV27</name>
                <description>Privileged configuration for block y (y = 0 to 31), belonging to super-block n.
Non-secure write to this bit is ignored if SECy bit is set in GTZC1_MPCBB_SECCFGRn.
Writes are ignored if SPLCKn bit is set in GTZC1_MPCBB_CFGLOCK.</description>
                <bitOffset>27</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Privileged and unprivileged access to block y, belonging to super-block n</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Only privileged access to block y, belonging to super-block n</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>PRIV28</name>
                <description>Privileged configuration for block y (y = 0 to 31), belonging to super-block n.
Non-secure write to this bit is ignored if SECy bit is set in GTZC1_MPCBB_SECCFGRn.
Writes are ignored if SPLCKn bit is set in GTZC1_MPCBB_CFGLOCK.</description>
                <bitOffset>28</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Privileged and unprivileged access to block y, belonging to super-block n</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Only privileged access to block y, belonging to super-block n</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>PRIV29</name>
                <description>Privileged configuration for block y (y = 0 to 31), belonging to super-block n.
Non-secure write to this bit is ignored if SECy bit is set in GTZC1_MPCBB_SECCFGRn.
Writes are ignored if SPLCKn bit is set in GTZC1_MPCBB_CFGLOCK.</description>
                <bitOffset>29</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Privileged and unprivileged access to block y, belonging to super-block n</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Only privileged access to block y, belonging to super-block n</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>PRIV30</name>
                <description>Privileged configuration for block y (y = 0 to 31), belonging to super-block n.
Non-secure write to this bit is ignored if SECy bit is set in GTZC1_MPCBB_SECCFGRn.
Writes are ignored if SPLCKn bit is set in GTZC1_MPCBB_CFGLOCK.</description>
                <bitOffset>30</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Privileged and unprivileged access to block y, belonging to super-block n</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Only privileged access to block y, belonging to super-block n</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>PRIV31</name>
                <description>Privileged configuration for block y (y = 0 to 31), belonging to super-block n.
Non-secure write to this bit is ignored if SECy bit is set in GTZC1_MPCBB_SECCFGRn.
Writes are ignored if SPLCKn bit is set in GTZC1_MPCBB_CFGLOCK.</description>
                <bitOffset>31</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Privileged and unprivileged access to block y, belonging to super-block n</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Only privileged access to block y, belonging to super-block n</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
            </fields>
          </register>
          <register>
            <name>GTZC1_MPCBB_PRIVCFGR1</name>
            <displayName>GTZC1_MPCBB_PRIVCFGR1</displayName>
            <description>GTZC1 MPCBB privileged configuration for super-block 1	register</description>
            <addressOffset>0x204</addressOffset>
            <size>0x20</size>
            <resetValue>0xFFFFFFFF</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>PRIV0</name>
                <description>Privileged configuration for block y (y = 0 to 31), belonging to super-block n.
Non-secure write to this bit is ignored if SECy bit is set in GTZC1_MPCBB_SECCFGRn.
Writes are ignored if SPLCKn bit is set in GTZC1_MPCBB_CFGLOCK.</description>
                <bitOffset>0</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Privileged and unprivileged access to block y, belonging to super-block n</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Only privileged access to block y, belonging to super-block n</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>PRIV1</name>
                <description>Privileged configuration for block y (y = 0 to 31), belonging to super-block n.
Non-secure write to this bit is ignored if SECy bit is set in GTZC1_MPCBB_SECCFGRn.
Writes are ignored if SPLCKn bit is set in GTZC1_MPCBB_CFGLOCK.</description>
                <bitOffset>1</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Privileged and unprivileged access to block y, belonging to super-block n</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Only privileged access to block y, belonging to super-block n</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>PRIV2</name>
                <description>Privileged configuration for block y (y = 0 to 31), belonging to super-block n.
Non-secure write to this bit is ignored if SECy bit is set in GTZC1_MPCBB_SECCFGRn.
Writes are ignored if SPLCKn bit is set in GTZC1_MPCBB_CFGLOCK.</description>
                <bitOffset>2</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Privileged and unprivileged access to block y, belonging to super-block n</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Only privileged access to block y, belonging to super-block n</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>PRIV3</name>
                <description>Privileged configuration for block y (y = 0 to 31), belonging to super-block n.
Non-secure write to this bit is ignored if SECy bit is set in GTZC1_MPCBB_SECCFGRn.
Writes are ignored if SPLCKn bit is set in GTZC1_MPCBB_CFGLOCK.</description>
                <bitOffset>3</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Privileged and unprivileged access to block y, belonging to super-block n</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Only privileged access to block y, belonging to super-block n</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>PRIV4</name>
                <description>Privileged configuration for block y (y = 0 to 31), belonging to super-block n.
Non-secure write to this bit is ignored if SECy bit is set in GTZC1_MPCBB_SECCFGRn.
Writes are ignored if SPLCKn bit is set in GTZC1_MPCBB_CFGLOCK.</description>
                <bitOffset>4</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Privileged and unprivileged access to block y, belonging to super-block n</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Only privileged access to block y, belonging to super-block n</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>PRIV5</name>
                <description>Privileged configuration for block y (y = 0 to 31), belonging to super-block n.
Non-secure write to this bit is ignored if SECy bit is set in GTZC1_MPCBB_SECCFGRn.
Writes are ignored if SPLCKn bit is set in GTZC1_MPCBB_CFGLOCK.</description>
                <bitOffset>5</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Privileged and unprivileged access to block y, belonging to super-block n</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Only privileged access to block y, belonging to super-block n</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>PRIV6</name>
                <description>Privileged configuration for block y (y = 0 to 31), belonging to super-block n.
Non-secure write to this bit is ignored if SECy bit is set in GTZC1_MPCBB_SECCFGRn.
Writes are ignored if SPLCKn bit is set in GTZC1_MPCBB_CFGLOCK.</description>
                <bitOffset>6</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Privileged and unprivileged access to block y, belonging to super-block n</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Only privileged access to block y, belonging to super-block n</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>PRIV7</name>
                <description>Privileged configuration for block y (y = 0 to 31), belonging to super-block n.
Non-secure write to this bit is ignored if SECy bit is set in GTZC1_MPCBB_SECCFGRn.
Writes are ignored if SPLCKn bit is set in GTZC1_MPCBB_CFGLOCK.</description>
                <bitOffset>7</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Privileged and unprivileged access to block y, belonging to super-block n</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Only privileged access to block y, belonging to super-block n</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>PRIV8</name>
                <description>Privileged configuration for block y (y = 0 to 31), belonging to super-block n.
Non-secure write to this bit is ignored if SECy bit is set in GTZC1_MPCBB_SECCFGRn.
Writes are ignored if SPLCKn bit is set in GTZC1_MPCBB_CFGLOCK.</description>
                <bitOffset>8</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Privileged and unprivileged access to block y, belonging to super-block n</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Only privileged access to block y, belonging to super-block n</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>PRIV9</name>
                <description>Privileged configuration for block y (y = 0 to 31), belonging to super-block n.
Non-secure write to this bit is ignored if SECy bit is set in GTZC1_MPCBB_SECCFGRn.
Writes are ignored if SPLCKn bit is set in GTZC1_MPCBB_CFGLOCK.</description>
                <bitOffset>9</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Privileged and unprivileged access to block y, belonging to super-block n</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Only privileged access to block y, belonging to super-block n</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>PRIV10</name>
                <description>Privileged configuration for block y (y = 0 to 31), belonging to super-block n.
Non-secure write to this bit is ignored if SECy bit is set in GTZC1_MPCBB_SECCFGRn.
Writes are ignored if SPLCKn bit is set in GTZC1_MPCBB_CFGLOCK.</description>
                <bitOffset>10</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Privileged and unprivileged access to block y, belonging to super-block n</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Only privileged access to block y, belonging to super-block n</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>PRIV11</name>
                <description>Privileged configuration for block y (y = 0 to 31), belonging to super-block n.
Non-secure write to this bit is ignored if SECy bit is set in GTZC1_MPCBB_SECCFGRn.
Writes are ignored if SPLCKn bit is set in GTZC1_MPCBB_CFGLOCK.</description>
                <bitOffset>11</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Privileged and unprivileged access to block y, belonging to super-block n</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Only privileged access to block y, belonging to super-block n</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>PRIV12</name>
                <description>Privileged configuration for block y (y = 0 to 31), belonging to super-block n.
Non-secure write to this bit is ignored if SECy bit is set in GTZC1_MPCBB_SECCFGRn.
Writes are ignored if SPLCKn bit is set in GTZC1_MPCBB_CFGLOCK.</description>
                <bitOffset>12</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Privileged and unprivileged access to block y, belonging to super-block n</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Only privileged access to block y, belonging to super-block n</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>PRIV13</name>
                <description>Privileged configuration for block y (y = 0 to 31), belonging to super-block n.
Non-secure write to this bit is ignored if SECy bit is set in GTZC1_MPCBB_SECCFGRn.
Writes are ignored if SPLCKn bit is set in GTZC1_MPCBB_CFGLOCK.</description>
                <bitOffset>13</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Privileged and unprivileged access to block y, belonging to super-block n</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Only privileged access to block y, belonging to super-block n</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>PRIV14</name>
                <description>Privileged configuration for block y (y = 0 to 31), belonging to super-block n.
Non-secure write to this bit is ignored if SECy bit is set in GTZC1_MPCBB_SECCFGRn.
Writes are ignored if SPLCKn bit is set in GTZC1_MPCBB_CFGLOCK.</description>
                <bitOffset>14</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Privileged and unprivileged access to block y, belonging to super-block n</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Only privileged access to block y, belonging to super-block n</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>PRIV15</name>
                <description>Privileged configuration for block y (y = 0 to 31), belonging to super-block n.
Non-secure write to this bit is ignored if SECy bit is set in GTZC1_MPCBB_SECCFGRn.
Writes are ignored if SPLCKn bit is set in GTZC1_MPCBB_CFGLOCK.</description>
                <bitOffset>15</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Privileged and unprivileged access to block y, belonging to super-block n</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Only privileged access to block y, belonging to super-block n</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>PRIV16</name>
                <description>Privileged configuration for block y (y = 0 to 31), belonging to super-block n.
Non-secure write to this bit is ignored if SECy bit is set in GTZC1_MPCBB_SECCFGRn.
Writes are ignored if SPLCKn bit is set in GTZC1_MPCBB_CFGLOCK.</description>
                <bitOffset>16</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Privileged and unprivileged access to block y, belonging to super-block n</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Only privileged access to block y, belonging to super-block n</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>PRIV17</name>
                <description>Privileged configuration for block y (y = 0 to 31), belonging to super-block n.
Non-secure write to this bit is ignored if SECy bit is set in GTZC1_MPCBB_SECCFGRn.
Writes are ignored if SPLCKn bit is set in GTZC1_MPCBB_CFGLOCK.</description>
                <bitOffset>17</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Privileged and unprivileged access to block y, belonging to super-block n</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Only privileged access to block y, belonging to super-block n</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>PRIV18</name>
                <description>Privileged configuration for block y (y = 0 to 31), belonging to super-block n.
Non-secure write to this bit is ignored if SECy bit is set in GTZC1_MPCBB_SECCFGRn.
Writes are ignored if SPLCKn bit is set in GTZC1_MPCBB_CFGLOCK.</description>
                <bitOffset>18</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Privileged and unprivileged access to block y, belonging to super-block n</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Only privileged access to block y, belonging to super-block n</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>PRIV19</name>
                <description>Privileged configuration for block y (y = 0 to 31), belonging to super-block n.
Non-secure write to this bit is ignored if SECy bit is set in GTZC1_MPCBB_SECCFGRn.
Writes are ignored if SPLCKn bit is set in GTZC1_MPCBB_CFGLOCK.</description>
                <bitOffset>19</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Privileged and unprivileged access to block y, belonging to super-block n</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Only privileged access to block y, belonging to super-block n</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>PRIV20</name>
                <description>Privileged configuration for block y (y = 0 to 31), belonging to super-block n.
Non-secure write to this bit is ignored if SECy bit is set in GTZC1_MPCBB_SECCFGRn.
Writes are ignored if SPLCKn bit is set in GTZC1_MPCBB_CFGLOCK.</description>
                <bitOffset>20</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Privileged and unprivileged access to block y, belonging to super-block n</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Only privileged access to block y, belonging to super-block n</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>PRIV21</name>
                <description>Privileged configuration for block y (y = 0 to 31), belonging to super-block n.
Non-secure write to this bit is ignored if SECy bit is set in GTZC1_MPCBB_SECCFGRn.
Writes are ignored if SPLCKn bit is set in GTZC1_MPCBB_CFGLOCK.</description>
                <bitOffset>21</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Privileged and unprivileged access to block y, belonging to super-block n</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Only privileged access to block y, belonging to super-block n</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>PRIV22</name>
                <description>Privileged configuration for block y (y = 0 to 31), belonging to super-block n.
Non-secure write to this bit is ignored if SECy bit is set in GTZC1_MPCBB_SECCFGRn.
Writes are ignored if SPLCKn bit is set in GTZC1_MPCBB_CFGLOCK.</description>
                <bitOffset>22</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Privileged and unprivileged access to block y, belonging to super-block n</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Only privileged access to block y, belonging to super-block n</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>PRIV23</name>
                <description>Privileged configuration for block y (y = 0 to 31), belonging to super-block n.
Non-secure write to this bit is ignored if SECy bit is set in GTZC1_MPCBB_SECCFGRn.
Writes are ignored if SPLCKn bit is set in GTZC1_MPCBB_CFGLOCK.</description>
                <bitOffset>23</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Privileged and unprivileged access to block y, belonging to super-block n</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Only privileged access to block y, belonging to super-block n</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>PRIV24</name>
                <description>Privileged configuration for block y (y = 0 to 31), belonging to super-block n.
Non-secure write to this bit is ignored if SECy bit is set in GTZC1_MPCBB_SECCFGRn.
Writes are ignored if SPLCKn bit is set in GTZC1_MPCBB_CFGLOCK.</description>
                <bitOffset>24</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Privileged and unprivileged access to block y, belonging to super-block n</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Only privileged access to block y, belonging to super-block n</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>PRIV25</name>
                <description>Privileged configuration for block y (y = 0 to 31), belonging to super-block n.
Non-secure write to this bit is ignored if SECy bit is set in GTZC1_MPCBB_SECCFGRn.
Writes are ignored if SPLCKn bit is set in GTZC1_MPCBB_CFGLOCK.</description>
                <bitOffset>25</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Privileged and unprivileged access to block y, belonging to super-block n</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Only privileged access to block y, belonging to super-block n</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>PRIV26</name>
                <description>Privileged configuration for block y (y = 0 to 31), belonging to super-block n.
Non-secure write to this bit is ignored if SECy bit is set in GTZC1_MPCBB_SECCFGRn.
Writes are ignored if SPLCKn bit is set in GTZC1_MPCBB_CFGLOCK.</description>
                <bitOffset>26</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Privileged and unprivileged access to block y, belonging to super-block n</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Only privileged access to block y, belonging to super-block n</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>PRIV27</name>
                <description>Privileged configuration for block y (y = 0 to 31), belonging to super-block n.
Non-secure write to this bit is ignored if SECy bit is set in GTZC1_MPCBB_SECCFGRn.
Writes are ignored if SPLCKn bit is set in GTZC1_MPCBB_CFGLOCK.</description>
                <bitOffset>27</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Privileged and unprivileged access to block y, belonging to super-block n</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Only privileged access to block y, belonging to super-block n</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>PRIV28</name>
                <description>Privileged configuration for block y (y = 0 to 31), belonging to super-block n.
Non-secure write to this bit is ignored if SECy bit is set in GTZC1_MPCBB_SECCFGRn.
Writes are ignored if SPLCKn bit is set in GTZC1_MPCBB_CFGLOCK.</description>
                <bitOffset>28</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Privileged and unprivileged access to block y, belonging to super-block n</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Only privileged access to block y, belonging to super-block n</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>PRIV29</name>
                <description>Privileged configuration for block y (y = 0 to 31), belonging to super-block n.
Non-secure write to this bit is ignored if SECy bit is set in GTZC1_MPCBB_SECCFGRn.
Writes are ignored if SPLCKn bit is set in GTZC1_MPCBB_CFGLOCK.</description>
                <bitOffset>29</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Privileged and unprivileged access to block y, belonging to super-block n</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Only privileged access to block y, belonging to super-block n</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>PRIV30</name>
                <description>Privileged configuration for block y (y = 0 to 31), belonging to super-block n.
Non-secure write to this bit is ignored if SECy bit is set in GTZC1_MPCBB_SECCFGRn.
Writes are ignored if SPLCKn bit is set in GTZC1_MPCBB_CFGLOCK.</description>
                <bitOffset>30</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Privileged and unprivileged access to block y, belonging to super-block n</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Only privileged access to block y, belonging to super-block n</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>PRIV31</name>
                <description>Privileged configuration for block y (y = 0 to 31), belonging to super-block n.
Non-secure write to this bit is ignored if SECy bit is set in GTZC1_MPCBB_SECCFGRn.
Writes are ignored if SPLCKn bit is set in GTZC1_MPCBB_CFGLOCK.</description>
                <bitOffset>31</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Privileged and unprivileged access to block y, belonging to super-block n</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Only privileged access to block y, belonging to super-block n</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
            </fields>
          </register>
          <register>
            <name>GTZC1_MPCBB_PRIVCFGR2</name>
            <displayName>GTZC1_MPCBB_PRIVCFGR2</displayName>
            <description>GTZC1 MPCBB privileged configuration for super-block 2	register</description>
            <addressOffset>0x208</addressOffset>
            <size>0x20</size>
            <resetValue>0xFFFFFFFF</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>PRIV0</name>
                <description>Privileged configuration for block y (y = 0 to 31), belonging to super-block n.
Non-secure write to this bit is ignored if SECy bit is set in GTZC1_MPCBB_SECCFGRn.
Writes are ignored if SPLCKn bit is set in GTZC1_MPCBB_CFGLOCK.</description>
                <bitOffset>0</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Privileged and unprivileged access to block y, belonging to super-block n</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Only privileged access to block y, belonging to super-block n</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>PRIV1</name>
                <description>Privileged configuration for block y (y = 0 to 31), belonging to super-block n.
Non-secure write to this bit is ignored if SECy bit is set in GTZC1_MPCBB_SECCFGRn.
Writes are ignored if SPLCKn bit is set in GTZC1_MPCBB_CFGLOCK.</description>
                <bitOffset>1</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Privileged and unprivileged access to block y, belonging to super-block n</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Only privileged access to block y, belonging to super-block n</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>PRIV2</name>
                <description>Privileged configuration for block y (y = 0 to 31), belonging to super-block n.
Non-secure write to this bit is ignored if SECy bit is set in GTZC1_MPCBB_SECCFGRn.
Writes are ignored if SPLCKn bit is set in GTZC1_MPCBB_CFGLOCK.</description>
                <bitOffset>2</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Privileged and unprivileged access to block y, belonging to super-block n</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Only privileged access to block y, belonging to super-block n</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>PRIV3</name>
                <description>Privileged configuration for block y (y = 0 to 31), belonging to super-block n.
Non-secure write to this bit is ignored if SECy bit is set in GTZC1_MPCBB_SECCFGRn.
Writes are ignored if SPLCKn bit is set in GTZC1_MPCBB_CFGLOCK.</description>
                <bitOffset>3</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Privileged and unprivileged access to block y, belonging to super-block n</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Only privileged access to block y, belonging to super-block n</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>PRIV4</name>
                <description>Privileged configuration for block y (y = 0 to 31), belonging to super-block n.
Non-secure write to this bit is ignored if SECy bit is set in GTZC1_MPCBB_SECCFGRn.
Writes are ignored if SPLCKn bit is set in GTZC1_MPCBB_CFGLOCK.</description>
                <bitOffset>4</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Privileged and unprivileged access to block y, belonging to super-block n</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Only privileged access to block y, belonging to super-block n</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>PRIV5</name>
                <description>Privileged configuration for block y (y = 0 to 31), belonging to super-block n.
Non-secure write to this bit is ignored if SECy bit is set in GTZC1_MPCBB_SECCFGRn.
Writes are ignored if SPLCKn bit is set in GTZC1_MPCBB_CFGLOCK.</description>
                <bitOffset>5</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Privileged and unprivileged access to block y, belonging to super-block n</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Only privileged access to block y, belonging to super-block n</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>PRIV6</name>
                <description>Privileged configuration for block y (y = 0 to 31), belonging to super-block n.
Non-secure write to this bit is ignored if SECy bit is set in GTZC1_MPCBB_SECCFGRn.
Writes are ignored if SPLCKn bit is set in GTZC1_MPCBB_CFGLOCK.</description>
                <bitOffset>6</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Privileged and unprivileged access to block y, belonging to super-block n</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Only privileged access to block y, belonging to super-block n</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>PRIV7</name>
                <description>Privileged configuration for block y (y = 0 to 31), belonging to super-block n.
Non-secure write to this bit is ignored if SECy bit is set in GTZC1_MPCBB_SECCFGRn.
Writes are ignored if SPLCKn bit is set in GTZC1_MPCBB_CFGLOCK.</description>
                <bitOffset>7</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Privileged and unprivileged access to block y, belonging to super-block n</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Only privileged access to block y, belonging to super-block n</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>PRIV8</name>
                <description>Privileged configuration for block y (y = 0 to 31), belonging to super-block n.
Non-secure write to this bit is ignored if SECy bit is set in GTZC1_MPCBB_SECCFGRn.
Writes are ignored if SPLCKn bit is set in GTZC1_MPCBB_CFGLOCK.</description>
                <bitOffset>8</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Privileged and unprivileged access to block y, belonging to super-block n</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Only privileged access to block y, belonging to super-block n</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>PRIV9</name>
                <description>Privileged configuration for block y (y = 0 to 31), belonging to super-block n.
Non-secure write to this bit is ignored if SECy bit is set in GTZC1_MPCBB_SECCFGRn.
Writes are ignored if SPLCKn bit is set in GTZC1_MPCBB_CFGLOCK.</description>
                <bitOffset>9</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Privileged and unprivileged access to block y, belonging to super-block n</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Only privileged access to block y, belonging to super-block n</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>PRIV10</name>
                <description>Privileged configuration for block y (y = 0 to 31), belonging to super-block n.
Non-secure write to this bit is ignored if SECy bit is set in GTZC1_MPCBB_SECCFGRn.
Writes are ignored if SPLCKn bit is set in GTZC1_MPCBB_CFGLOCK.</description>
                <bitOffset>10</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Privileged and unprivileged access to block y, belonging to super-block n</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Only privileged access to block y, belonging to super-block n</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>PRIV11</name>
                <description>Privileged configuration for block y (y = 0 to 31), belonging to super-block n.
Non-secure write to this bit is ignored if SECy bit is set in GTZC1_MPCBB_SECCFGRn.
Writes are ignored if SPLCKn bit is set in GTZC1_MPCBB_CFGLOCK.</description>
                <bitOffset>11</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Privileged and unprivileged access to block y, belonging to super-block n</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Only privileged access to block y, belonging to super-block n</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>PRIV12</name>
                <description>Privileged configuration for block y (y = 0 to 31), belonging to super-block n.
Non-secure write to this bit is ignored if SECy bit is set in GTZC1_MPCBB_SECCFGRn.
Writes are ignored if SPLCKn bit is set in GTZC1_MPCBB_CFGLOCK.</description>
                <bitOffset>12</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Privileged and unprivileged access to block y, belonging to super-block n</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Only privileged access to block y, belonging to super-block n</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>PRIV13</name>
                <description>Privileged configuration for block y (y = 0 to 31), belonging to super-block n.
Non-secure write to this bit is ignored if SECy bit is set in GTZC1_MPCBB_SECCFGRn.
Writes are ignored if SPLCKn bit is set in GTZC1_MPCBB_CFGLOCK.</description>
                <bitOffset>13</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Privileged and unprivileged access to block y, belonging to super-block n</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Only privileged access to block y, belonging to super-block n</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>PRIV14</name>
                <description>Privileged configuration for block y (y = 0 to 31), belonging to super-block n.
Non-secure write to this bit is ignored if SECy bit is set in GTZC1_MPCBB_SECCFGRn.
Writes are ignored if SPLCKn bit is set in GTZC1_MPCBB_CFGLOCK.</description>
                <bitOffset>14</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Privileged and unprivileged access to block y, belonging to super-block n</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Only privileged access to block y, belonging to super-block n</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>PRIV15</name>
                <description>Privileged configuration for block y (y = 0 to 31), belonging to super-block n.
Non-secure write to this bit is ignored if SECy bit is set in GTZC1_MPCBB_SECCFGRn.
Writes are ignored if SPLCKn bit is set in GTZC1_MPCBB_CFGLOCK.</description>
                <bitOffset>15</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Privileged and unprivileged access to block y, belonging to super-block n</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Only privileged access to block y, belonging to super-block n</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>PRIV16</name>
                <description>Privileged configuration for block y (y = 0 to 31), belonging to super-block n.
Non-secure write to this bit is ignored if SECy bit is set in GTZC1_MPCBB_SECCFGRn.
Writes are ignored if SPLCKn bit is set in GTZC1_MPCBB_CFGLOCK.</description>
                <bitOffset>16</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Privileged and unprivileged access to block y, belonging to super-block n</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Only privileged access to block y, belonging to super-block n</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>PRIV17</name>
                <description>Privileged configuration for block y (y = 0 to 31), belonging to super-block n.
Non-secure write to this bit is ignored if SECy bit is set in GTZC1_MPCBB_SECCFGRn.
Writes are ignored if SPLCKn bit is set in GTZC1_MPCBB_CFGLOCK.</description>
                <bitOffset>17</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Privileged and unprivileged access to block y, belonging to super-block n</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Only privileged access to block y, belonging to super-block n</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>PRIV18</name>
                <description>Privileged configuration for block y (y = 0 to 31), belonging to super-block n.
Non-secure write to this bit is ignored if SECy bit is set in GTZC1_MPCBB_SECCFGRn.
Writes are ignored if SPLCKn bit is set in GTZC1_MPCBB_CFGLOCK.</description>
                <bitOffset>18</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Privileged and unprivileged access to block y, belonging to super-block n</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Only privileged access to block y, belonging to super-block n</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>PRIV19</name>
                <description>Privileged configuration for block y (y = 0 to 31), belonging to super-block n.
Non-secure write to this bit is ignored if SECy bit is set in GTZC1_MPCBB_SECCFGRn.
Writes are ignored if SPLCKn bit is set in GTZC1_MPCBB_CFGLOCK.</description>
                <bitOffset>19</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Privileged and unprivileged access to block y, belonging to super-block n</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Only privileged access to block y, belonging to super-block n</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>PRIV20</name>
                <description>Privileged configuration for block y (y = 0 to 31), belonging to super-block n.
Non-secure write to this bit is ignored if SECy bit is set in GTZC1_MPCBB_SECCFGRn.
Writes are ignored if SPLCKn bit is set in GTZC1_MPCBB_CFGLOCK.</description>
                <bitOffset>20</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Privileged and unprivileged access to block y, belonging to super-block n</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Only privileged access to block y, belonging to super-block n</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>PRIV21</name>
                <description>Privileged configuration for block y (y = 0 to 31), belonging to super-block n.
Non-secure write to this bit is ignored if SECy bit is set in GTZC1_MPCBB_SECCFGRn.
Writes are ignored if SPLCKn bit is set in GTZC1_MPCBB_CFGLOCK.</description>
                <bitOffset>21</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Privileged and unprivileged access to block y, belonging to super-block n</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Only privileged access to block y, belonging to super-block n</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>PRIV22</name>
                <description>Privileged configuration for block y (y = 0 to 31), belonging to super-block n.
Non-secure write to this bit is ignored if SECy bit is set in GTZC1_MPCBB_SECCFGRn.
Writes are ignored if SPLCKn bit is set in GTZC1_MPCBB_CFGLOCK.</description>
                <bitOffset>22</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Privileged and unprivileged access to block y, belonging to super-block n</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Only privileged access to block y, belonging to super-block n</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>PRIV23</name>
                <description>Privileged configuration for block y (y = 0 to 31), belonging to super-block n.
Non-secure write to this bit is ignored if SECy bit is set in GTZC1_MPCBB_SECCFGRn.
Writes are ignored if SPLCKn bit is set in GTZC1_MPCBB_CFGLOCK.</description>
                <bitOffset>23</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Privileged and unprivileged access to block y, belonging to super-block n</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Only privileged access to block y, belonging to super-block n</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>PRIV24</name>
                <description>Privileged configuration for block y (y = 0 to 31), belonging to super-block n.
Non-secure write to this bit is ignored if SECy bit is set in GTZC1_MPCBB_SECCFGRn.
Writes are ignored if SPLCKn bit is set in GTZC1_MPCBB_CFGLOCK.</description>
                <bitOffset>24</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Privileged and unprivileged access to block y, belonging to super-block n</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Only privileged access to block y, belonging to super-block n</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>PRIV25</name>
                <description>Privileged configuration for block y (y = 0 to 31), belonging to super-block n.
Non-secure write to this bit is ignored if SECy bit is set in GTZC1_MPCBB_SECCFGRn.
Writes are ignored if SPLCKn bit is set in GTZC1_MPCBB_CFGLOCK.</description>
                <bitOffset>25</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Privileged and unprivileged access to block y, belonging to super-block n</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Only privileged access to block y, belonging to super-block n</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>PRIV26</name>
                <description>Privileged configuration for block y (y = 0 to 31), belonging to super-block n.
Non-secure write to this bit is ignored if SECy bit is set in GTZC1_MPCBB_SECCFGRn.
Writes are ignored if SPLCKn bit is set in GTZC1_MPCBB_CFGLOCK.</description>
                <bitOffset>26</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Privileged and unprivileged access to block y, belonging to super-block n</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Only privileged access to block y, belonging to super-block n</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>PRIV27</name>
                <description>Privileged configuration for block y (y = 0 to 31), belonging to super-block n.
Non-secure write to this bit is ignored if SECy bit is set in GTZC1_MPCBB_SECCFGRn.
Writes are ignored if SPLCKn bit is set in GTZC1_MPCBB_CFGLOCK.</description>
                <bitOffset>27</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Privileged and unprivileged access to block y, belonging to super-block n</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Only privileged access to block y, belonging to super-block n</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>PRIV28</name>
                <description>Privileged configuration for block y (y = 0 to 31), belonging to super-block n.
Non-secure write to this bit is ignored if SECy bit is set in GTZC1_MPCBB_SECCFGRn.
Writes are ignored if SPLCKn bit is set in GTZC1_MPCBB_CFGLOCK.</description>
                <bitOffset>28</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Privileged and unprivileged access to block y, belonging to super-block n</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Only privileged access to block y, belonging to super-block n</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>PRIV29</name>
                <description>Privileged configuration for block y (y = 0 to 31), belonging to super-block n.
Non-secure write to this bit is ignored if SECy bit is set in GTZC1_MPCBB_SECCFGRn.
Writes are ignored if SPLCKn bit is set in GTZC1_MPCBB_CFGLOCK.</description>
                <bitOffset>29</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Privileged and unprivileged access to block y, belonging to super-block n</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Only privileged access to block y, belonging to super-block n</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>PRIV30</name>
                <description>Privileged configuration for block y (y = 0 to 31), belonging to super-block n.
Non-secure write to this bit is ignored if SECy bit is set in GTZC1_MPCBB_SECCFGRn.
Writes are ignored if SPLCKn bit is set in GTZC1_MPCBB_CFGLOCK.</description>
                <bitOffset>30</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Privileged and unprivileged access to block y, belonging to super-block n</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Only privileged access to block y, belonging to super-block n</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>PRIV31</name>
                <description>Privileged configuration for block y (y = 0 to 31), belonging to super-block n.
Non-secure write to this bit is ignored if SECy bit is set in GTZC1_MPCBB_SECCFGRn.
Writes are ignored if SPLCKn bit is set in GTZC1_MPCBB_CFGLOCK.</description>
                <bitOffset>31</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Privileged and unprivileged access to block y, belonging to super-block n</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Only privileged access to block y, belonging to super-block n</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
            </fields>
          </register>
          <register>
            <name>GTZC1_MPCBB_PRIVCFGR3</name>
            <displayName>GTZC1_MPCBB_PRIVCFGR3</displayName>
            <description>GTZC1 MPCBB privileged configuration for super-block 3	register</description>
            <addressOffset>0x20C</addressOffset>
            <size>0x20</size>
            <resetValue>0xFFFFFFFF</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>PRIV0</name>
                <description>Privileged configuration for block y (y = 0 to 31), belonging to super-block n.
Non-secure write to this bit is ignored if SECy bit is set in GTZC1_MPCBB_SECCFGRn.
Writes are ignored if SPLCKn bit is set in GTZC1_MPCBB_CFGLOCK.</description>
                <bitOffset>0</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Privileged and unprivileged access to block y, belonging to super-block n</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Only privileged access to block y, belonging to super-block n</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>PRIV1</name>
                <description>Privileged configuration for block y (y = 0 to 31), belonging to super-block n.
Non-secure write to this bit is ignored if SECy bit is set in GTZC1_MPCBB_SECCFGRn.
Writes are ignored if SPLCKn bit is set in GTZC1_MPCBB_CFGLOCK.</description>
                <bitOffset>1</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Privileged and unprivileged access to block y, belonging to super-block n</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Only privileged access to block y, belonging to super-block n</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>PRIV2</name>
                <description>Privileged configuration for block y (y = 0 to 31), belonging to super-block n.
Non-secure write to this bit is ignored if SECy bit is set in GTZC1_MPCBB_SECCFGRn.
Writes are ignored if SPLCKn bit is set in GTZC1_MPCBB_CFGLOCK.</description>
                <bitOffset>2</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Privileged and unprivileged access to block y, belonging to super-block n</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Only privileged access to block y, belonging to super-block n</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>PRIV3</name>
                <description>Privileged configuration for block y (y = 0 to 31), belonging to super-block n.
Non-secure write to this bit is ignored if SECy bit is set in GTZC1_MPCBB_SECCFGRn.
Writes are ignored if SPLCKn bit is set in GTZC1_MPCBB_CFGLOCK.</description>
                <bitOffset>3</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Privileged and unprivileged access to block y, belonging to super-block n</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Only privileged access to block y, belonging to super-block n</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>PRIV4</name>
                <description>Privileged configuration for block y (y = 0 to 31), belonging to super-block n.
Non-secure write to this bit is ignored if SECy bit is set in GTZC1_MPCBB_SECCFGRn.
Writes are ignored if SPLCKn bit is set in GTZC1_MPCBB_CFGLOCK.</description>
                <bitOffset>4</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Privileged and unprivileged access to block y, belonging to super-block n</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Only privileged access to block y, belonging to super-block n</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>PRIV5</name>
                <description>Privileged configuration for block y (y = 0 to 31), belonging to super-block n.
Non-secure write to this bit is ignored if SECy bit is set in GTZC1_MPCBB_SECCFGRn.
Writes are ignored if SPLCKn bit is set in GTZC1_MPCBB_CFGLOCK.</description>
                <bitOffset>5</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Privileged and unprivileged access to block y, belonging to super-block n</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Only privileged access to block y, belonging to super-block n</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>PRIV6</name>
                <description>Privileged configuration for block y (y = 0 to 31), belonging to super-block n.
Non-secure write to this bit is ignored if SECy bit is set in GTZC1_MPCBB_SECCFGRn.
Writes are ignored if SPLCKn bit is set in GTZC1_MPCBB_CFGLOCK.</description>
                <bitOffset>6</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Privileged and unprivileged access to block y, belonging to super-block n</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Only privileged access to block y, belonging to super-block n</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>PRIV7</name>
                <description>Privileged configuration for block y (y = 0 to 31), belonging to super-block n.
Non-secure write to this bit is ignored if SECy bit is set in GTZC1_MPCBB_SECCFGRn.
Writes are ignored if SPLCKn bit is set in GTZC1_MPCBB_CFGLOCK.</description>
                <bitOffset>7</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Privileged and unprivileged access to block y, belonging to super-block n</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Only privileged access to block y, belonging to super-block n</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>PRIV8</name>
                <description>Privileged configuration for block y (y = 0 to 31), belonging to super-block n.
Non-secure write to this bit is ignored if SECy bit is set in GTZC1_MPCBB_SECCFGRn.
Writes are ignored if SPLCKn bit is set in GTZC1_MPCBB_CFGLOCK.</description>
                <bitOffset>8</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Privileged and unprivileged access to block y, belonging to super-block n</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Only privileged access to block y, belonging to super-block n</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>PRIV9</name>
                <description>Privileged configuration for block y (y = 0 to 31), belonging to super-block n.
Non-secure write to this bit is ignored if SECy bit is set in GTZC1_MPCBB_SECCFGRn.
Writes are ignored if SPLCKn bit is set in GTZC1_MPCBB_CFGLOCK.</description>
                <bitOffset>9</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Privileged and unprivileged access to block y, belonging to super-block n</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Only privileged access to block y, belonging to super-block n</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>PRIV10</name>
                <description>Privileged configuration for block y (y = 0 to 31), belonging to super-block n.
Non-secure write to this bit is ignored if SECy bit is set in GTZC1_MPCBB_SECCFGRn.
Writes are ignored if SPLCKn bit is set in GTZC1_MPCBB_CFGLOCK.</description>
                <bitOffset>10</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Privileged and unprivileged access to block y, belonging to super-block n</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Only privileged access to block y, belonging to super-block n</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>PRIV11</name>
                <description>Privileged configuration for block y (y = 0 to 31), belonging to super-block n.
Non-secure write to this bit is ignored if SECy bit is set in GTZC1_MPCBB_SECCFGRn.
Writes are ignored if SPLCKn bit is set in GTZC1_MPCBB_CFGLOCK.</description>
                <bitOffset>11</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Privileged and unprivileged access to block y, belonging to super-block n</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Only privileged access to block y, belonging to super-block n</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>PRIV12</name>
                <description>Privileged configuration for block y (y = 0 to 31), belonging to super-block n.
Non-secure write to this bit is ignored if SECy bit is set in GTZC1_MPCBB_SECCFGRn.
Writes are ignored if SPLCKn bit is set in GTZC1_MPCBB_CFGLOCK.</description>
                <bitOffset>12</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Privileged and unprivileged access to block y, belonging to super-block n</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Only privileged access to block y, belonging to super-block n</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>PRIV13</name>
                <description>Privileged configuration for block y (y = 0 to 31), belonging to super-block n.
Non-secure write to this bit is ignored if SECy bit is set in GTZC1_MPCBB_SECCFGRn.
Writes are ignored if SPLCKn bit is set in GTZC1_MPCBB_CFGLOCK.</description>
                <bitOffset>13</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Privileged and unprivileged access to block y, belonging to super-block n</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Only privileged access to block y, belonging to super-block n</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>PRIV14</name>
                <description>Privileged configuration for block y (y = 0 to 31), belonging to super-block n.
Non-secure write to this bit is ignored if SECy bit is set in GTZC1_MPCBB_SECCFGRn.
Writes are ignored if SPLCKn bit is set in GTZC1_MPCBB_CFGLOCK.</description>
                <bitOffset>14</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Privileged and unprivileged access to block y, belonging to super-block n</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Only privileged access to block y, belonging to super-block n</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>PRIV15</name>
                <description>Privileged configuration for block y (y = 0 to 31), belonging to super-block n.
Non-secure write to this bit is ignored if SECy bit is set in GTZC1_MPCBB_SECCFGRn.
Writes are ignored if SPLCKn bit is set in GTZC1_MPCBB_CFGLOCK.</description>
                <bitOffset>15</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Privileged and unprivileged access to block y, belonging to super-block n</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Only privileged access to block y, belonging to super-block n</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>PRIV16</name>
                <description>Privileged configuration for block y (y = 0 to 31), belonging to super-block n.
Non-secure write to this bit is ignored if SECy bit is set in GTZC1_MPCBB_SECCFGRn.
Writes are ignored if SPLCKn bit is set in GTZC1_MPCBB_CFGLOCK.</description>
                <bitOffset>16</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Privileged and unprivileged access to block y, belonging to super-block n</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Only privileged access to block y, belonging to super-block n</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>PRIV17</name>
                <description>Privileged configuration for block y (y = 0 to 31), belonging to super-block n.
Non-secure write to this bit is ignored if SECy bit is set in GTZC1_MPCBB_SECCFGRn.
Writes are ignored if SPLCKn bit is set in GTZC1_MPCBB_CFGLOCK.</description>
                <bitOffset>17</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Privileged and unprivileged access to block y, belonging to super-block n</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Only privileged access to block y, belonging to super-block n</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>PRIV18</name>
                <description>Privileged configuration for block y (y = 0 to 31), belonging to super-block n.
Non-secure write to this bit is ignored if SECy bit is set in GTZC1_MPCBB_SECCFGRn.
Writes are ignored if SPLCKn bit is set in GTZC1_MPCBB_CFGLOCK.</description>
                <bitOffset>18</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Privileged and unprivileged access to block y, belonging to super-block n</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Only privileged access to block y, belonging to super-block n</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>PRIV19</name>
                <description>Privileged configuration for block y (y = 0 to 31), belonging to super-block n.
Non-secure write to this bit is ignored if SECy bit is set in GTZC1_MPCBB_SECCFGRn.
Writes are ignored if SPLCKn bit is set in GTZC1_MPCBB_CFGLOCK.</description>
                <bitOffset>19</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Privileged and unprivileged access to block y, belonging to super-block n</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Only privileged access to block y, belonging to super-block n</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>PRIV20</name>
                <description>Privileged configuration for block y (y = 0 to 31), belonging to super-block n.
Non-secure write to this bit is ignored if SECy bit is set in GTZC1_MPCBB_SECCFGRn.
Writes are ignored if SPLCKn bit is set in GTZC1_MPCBB_CFGLOCK.</description>
                <bitOffset>20</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Privileged and unprivileged access to block y, belonging to super-block n</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Only privileged access to block y, belonging to super-block n</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>PRIV21</name>
                <description>Privileged configuration for block y (y = 0 to 31), belonging to super-block n.
Non-secure write to this bit is ignored if SECy bit is set in GTZC1_MPCBB_SECCFGRn.
Writes are ignored if SPLCKn bit is set in GTZC1_MPCBB_CFGLOCK.</description>
                <bitOffset>21</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Privileged and unprivileged access to block y, belonging to super-block n</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Only privileged access to block y, belonging to super-block n</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>PRIV22</name>
                <description>Privileged configuration for block y (y = 0 to 31), belonging to super-block n.
Non-secure write to this bit is ignored if SECy bit is set in GTZC1_MPCBB_SECCFGRn.
Writes are ignored if SPLCKn bit is set in GTZC1_MPCBB_CFGLOCK.</description>
                <bitOffset>22</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Privileged and unprivileged access to block y, belonging to super-block n</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Only privileged access to block y, belonging to super-block n</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>PRIV23</name>
                <description>Privileged configuration for block y (y = 0 to 31), belonging to super-block n.
Non-secure write to this bit is ignored if SECy bit is set in GTZC1_MPCBB_SECCFGRn.
Writes are ignored if SPLCKn bit is set in GTZC1_MPCBB_CFGLOCK.</description>
                <bitOffset>23</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Privileged and unprivileged access to block y, belonging to super-block n</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Only privileged access to block y, belonging to super-block n</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>PRIV24</name>
                <description>Privileged configuration for block y (y = 0 to 31), belonging to super-block n.
Non-secure write to this bit is ignored if SECy bit is set in GTZC1_MPCBB_SECCFGRn.
Writes are ignored if SPLCKn bit is set in GTZC1_MPCBB_CFGLOCK.</description>
                <bitOffset>24</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Privileged and unprivileged access to block y, belonging to super-block n</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Only privileged access to block y, belonging to super-block n</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>PRIV25</name>
                <description>Privileged configuration for block y (y = 0 to 31), belonging to super-block n.
Non-secure write to this bit is ignored if SECy bit is set in GTZC1_MPCBB_SECCFGRn.
Writes are ignored if SPLCKn bit is set in GTZC1_MPCBB_CFGLOCK.</description>
                <bitOffset>25</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Privileged and unprivileged access to block y, belonging to super-block n</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Only privileged access to block y, belonging to super-block n</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>PRIV26</name>
                <description>Privileged configuration for block y (y = 0 to 31), belonging to super-block n.
Non-secure write to this bit is ignored if SECy bit is set in GTZC1_MPCBB_SECCFGRn.
Writes are ignored if SPLCKn bit is set in GTZC1_MPCBB_CFGLOCK.</description>
                <bitOffset>26</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Privileged and unprivileged access to block y, belonging to super-block n</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Only privileged access to block y, belonging to super-block n</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>PRIV27</name>
                <description>Privileged configuration for block y (y = 0 to 31), belonging to super-block n.
Non-secure write to this bit is ignored if SECy bit is set in GTZC1_MPCBB_SECCFGRn.
Writes are ignored if SPLCKn bit is set in GTZC1_MPCBB_CFGLOCK.</description>
                <bitOffset>27</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Privileged and unprivileged access to block y, belonging to super-block n</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Only privileged access to block y, belonging to super-block n</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>PRIV28</name>
                <description>Privileged configuration for block y (y = 0 to 31), belonging to super-block n.
Non-secure write to this bit is ignored if SECy bit is set in GTZC1_MPCBB_SECCFGRn.
Writes are ignored if SPLCKn bit is set in GTZC1_MPCBB_CFGLOCK.</description>
                <bitOffset>28</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Privileged and unprivileged access to block y, belonging to super-block n</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Only privileged access to block y, belonging to super-block n</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>PRIV29</name>
                <description>Privileged configuration for block y (y = 0 to 31), belonging to super-block n.
Non-secure write to this bit is ignored if SECy bit is set in GTZC1_MPCBB_SECCFGRn.
Writes are ignored if SPLCKn bit is set in GTZC1_MPCBB_CFGLOCK.</description>
                <bitOffset>29</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Privileged and unprivileged access to block y, belonging to super-block n</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Only privileged access to block y, belonging to super-block n</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>PRIV30</name>
                <description>Privileged configuration for block y (y = 0 to 31), belonging to super-block n.
Non-secure write to this bit is ignored if SECy bit is set in GTZC1_MPCBB_SECCFGRn.
Writes are ignored if SPLCKn bit is set in GTZC1_MPCBB_CFGLOCK.</description>
                <bitOffset>30</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Privileged and unprivileged access to block y, belonging to super-block n</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Only privileged access to block y, belonging to super-block n</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>PRIV31</name>
                <description>Privileged configuration for block y (y = 0 to 31), belonging to super-block n.
Non-secure write to this bit is ignored if SECy bit is set in GTZC1_MPCBB_SECCFGRn.
Writes are ignored if SPLCKn bit is set in GTZC1_MPCBB_CFGLOCK.</description>
                <bitOffset>31</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Privileged and unprivileged access to block y, belonging to super-block n</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Only privileged access to block y, belonging to super-block n</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
            </fields>
          </register>
        </registers>
    </peripheral>
	<peripheral derivedFrom="GTZC1_MPCBB1">
      <name>SEC_GTZC1_MPCBB1</name>
      <baseAddress>0x50032C00</baseAddress>
    </peripheral>
	<peripheral derivedFrom="GTZC1_MPCBB1">
      <name>GTZC1_MPCBB2</name>
      <baseAddress>0x40033000</baseAddress>
    </peripheral>
	<peripheral derivedFrom="GTZC1_MPCBB1">
      <name>SEC_GTZC1_MPCBB2</name>
      <baseAddress>0x50033000</baseAddress>
    </peripheral>		
	<peripheral>
        <name>GTZC1_MPCBB6</name>
        <description>GTZC1_MPCBB6 address block description</description>
		<groupName>GTZC</groupName>
        <baseAddress>0x40034000</baseAddress>
        <addressBlock>
          <offset>0x0</offset>
          <size>0x400</size>
          <usage>registers</usage>
        </addressBlock>
        <registers>
        <register>
          <name>GTZC1_MPCBB_CR</name>
          <displayName>GTZC1_MPCBB_CR</displayName>
          <description>MPCBB control register</description>
          <addressOffset>0x0</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
		  <resetMask>0xFFFFFFFF</resetMask>
          <fields>
		     <field>
                <name>GLOCK</name>
                <description>lock the control register of the MPCBB until next reset;
This bit is cleared by default and once set, it can not be reset until system reset.</description>
                <bitOffset>0</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>control register not locked</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>control register locked</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>INVSECSTATE</name>
                <description>SRAM clocks security state;
This bit is used to define the internal SRAM clocks control in RCC as secure or not.</description>
                <bitOffset>30</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>SRAM clock is secured if a secure area exists in the MPCBB. It is non secure if there is no secure area.</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>SRAM clock is non-secure even if a secure area exists in the MPCBB, and secure even if no secure block is set in the MPCBB.</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>SRWILADIS</name>
                <description>secure read/write illegal access disable;
This bit disables the detection of an illegal access when a secure read/write transaction access a non-secure blocks of the block-based SRAM (secure fetch on non-secure block is always considered illegal).</description>
                <bitOffset>31</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>enabled, secure read/write acces not allowed on non-secure SRAM block</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>disabled, secure read/write access allowed on non-secure SRAM block</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
          </fields>
        </register>
        <register>
          <name>GTZC1_MPCBB_CFGLOCK</name>
          <displayName>GTZC1_MPCBB_CFGLOCK</displayName>
          <description>GTZC1 SRAMz MPCBB configuration lock register</description>
          <addressOffset>0x10</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
		  <resetMask>0xFFFFFFFF</resetMask>
          <fields>
		    <field>
                <name>SPLCK0</name>
                <description>Security/privilege configuration lock super-block;
This bit is set by software and can be cleared only by system reset.;
note that bit [3:2] are reserved on sales type STM32WBA5xEx for MPCBB1.</description>
                <bitOffset>0</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>GTZC1_MPCBB_SECCFGRn and GTZC1_MPCBB_PRIVCFGRn can be written.</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Writes to GTZC1_MPCBB_SECCFGRn and GTZC1_MPCBB_PRIVCFGRn are ignored</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
		  </fields>         
        </register>          
        <register>
            <name>GTZC1_MPCBB_SECCFGR0</name>
            <displayName>GTZC1_MPCBB_SECCFGR0</displayName>
            <description>GTZC1 MPCBB security configuration for super-block 0 register</description>
            <addressOffset>0x100</addressOffset>
            <size>0x20</size>
            <resetValue>0xFFFFFFFF</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>SEC0</name>
                <description>Security configuration for block y (y = 0 to 31) in super block n
Unprivileged write to this bit is ignored if PRIVy bit is set in GTZC1_MPCBB_PRIVCFGRn.
Writes are ignored if SPLCKn bit is set in GTZC1_MPCBB_CFGLOCK.</description>
                <bitOffset>0</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Non-secure access only to block y, belonging to super-block n. Secure access is also allowed if the SRWILADIS bit is set in GTZC1_MPCBB_CR.</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Secure access only to block y, belonging to super-block n.</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>SEC1</name>
                <description>Security configuration for block y (y = 0 to 31) in super block n
Unprivileged write to this bit is ignored if PRIVy bit is set in GTZC1_MPCBB_PRIVCFGRn.
Writes are ignored if SPLCKn bit is set in GTZC1_MPCBB_CFGLOCK.</description>
                <bitOffset>1</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Non-secure access only to block y, belonging to super-block n. Secure access is also allowed if the SRWILADIS bit is set in GTZC1_MPCBB_CR.</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Secure access only to block y, belonging to super-block n.</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>SEC2</name>
                <description>Security configuration for block y (y = 0 to 31) in super block n
Unprivileged write to this bit is ignored if PRIVy bit is set in GTZC1_MPCBB_PRIVCFGRn.
Writes are ignored if SPLCKn bit is set in GTZC1_MPCBB_CFGLOCK.</description>
                <bitOffset>2</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Non-secure access only to block y, belonging to super-block n. Secure access is also allowed if the SRWILADIS bit is set in GTZC1_MPCBB_CR.</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Secure access only to block y, belonging to super-block n.</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>SEC3</name>
                <description>Security configuration for block y (y = 0 to 31) in super block n
Unprivileged write to this bit is ignored if PRIVy bit is set in GTZC1_MPCBB_PRIVCFGRn.
Writes are ignored if SPLCKn bit is set in GTZC1_MPCBB_CFGLOCK.</description>
                <bitOffset>3</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Non-secure access only to block y, belonging to super-block n. Secure access is also allowed if the SRWILADIS bit is set in GTZC1_MPCBB_CR.</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Secure access only to block y, belonging to super-block n.</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>SEC4</name>
                <description>Security configuration for block y (y = 0 to 31) in super block n
Unprivileged write to this bit is ignored if PRIVy bit is set in GTZC1_MPCBB_PRIVCFGRn.
Writes are ignored if SPLCKn bit is set in GTZC1_MPCBB_CFGLOCK.</description>
                <bitOffset>4</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Non-secure access only to block y, belonging to super-block n. Secure access is also allowed if the SRWILADIS bit is set in GTZC1_MPCBB_CR.</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Secure access only to block y, belonging to super-block n.</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>SEC5</name>
                <description>Security configuration for block y (y = 0 to 31) in super block n
Unprivileged write to this bit is ignored if PRIVy bit is set in GTZC1_MPCBB_PRIVCFGRn.
Writes are ignored if SPLCKn bit is set in GTZC1_MPCBB_CFGLOCK.</description>
                <bitOffset>5</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Non-secure access only to block y, belonging to super-block n. Secure access is also allowed if the SRWILADIS bit is set in GTZC1_MPCBB_CR.</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Secure access only to block y, belonging to super-block n.</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>SEC6</name>
                <description>Security configuration for block y (y = 0 to 31) in super block n
Unprivileged write to this bit is ignored if PRIVy bit is set in GTZC1_MPCBB_PRIVCFGRn.
Writes are ignored if SPLCKn bit is set in GTZC1_MPCBB_CFGLOCK.</description>
                <bitOffset>6</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Non-secure access only to block y, belonging to super-block n. Secure access is also allowed if the SRWILADIS bit is set in GTZC1_MPCBB_CR.</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Secure access only to block y, belonging to super-block n.</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>SEC7</name>
                <description>Security configuration for block y (y = 0 to 31) in super block n
Unprivileged write to this bit is ignored if PRIVy bit is set in GTZC1_MPCBB_PRIVCFGRn.
Writes are ignored if SPLCKn bit is set in GTZC1_MPCBB_CFGLOCK.</description>
                <bitOffset>7</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Non-secure access only to block y, belonging to super-block n. Secure access is also allowed if the SRWILADIS bit is set in GTZC1_MPCBB_CR.</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Secure access only to block y, belonging to super-block n.</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>SEC8</name>
                <description>Security configuration for block y (y = 0 to 31) in super block n
Unprivileged write to this bit is ignored if PRIVy bit is set in GTZC1_MPCBB_PRIVCFGRn.
Writes are ignored if SPLCKn bit is set in GTZC1_MPCBB_CFGLOCK.</description>
                <bitOffset>8</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Non-secure access only to block y, belonging to super-block n. Secure access is also allowed if the SRWILADIS bit is set in GTZC1_MPCBB_CR.</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Secure access only to block y, belonging to super-block n.</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>SEC9</name>
                <description>Security configuration for block y (y = 0 to 31) in super block n
Unprivileged write to this bit is ignored if PRIVy bit is set in GTZC1_MPCBB_PRIVCFGRn.
Writes are ignored if SPLCKn bit is set in GTZC1_MPCBB_CFGLOCK.</description>
                <bitOffset>9</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Non-secure access only to block y, belonging to super-block n. Secure access is also allowed if the SRWILADIS bit is set in GTZC1_MPCBB_CR.</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Secure access only to block y, belonging to super-block n.</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>SEC10</name>
                <description>Security configuration for block y (y = 0 to 31) in super block n
Unprivileged write to this bit is ignored if PRIVy bit is set in GTZC1_MPCBB_PRIVCFGRn.
Writes are ignored if SPLCKn bit is set in GTZC1_MPCBB_CFGLOCK.</description>
                <bitOffset>10</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Non-secure access only to block y, belonging to super-block n. Secure access is also allowed if the SRWILADIS bit is set in GTZC1_MPCBB_CR.</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Secure access only to block y, belonging to super-block n.</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>SEC11</name>
                <description>Security configuration for block y (y = 0 to 31) in super block n
Unprivileged write to this bit is ignored if PRIVy bit is set in GTZC1_MPCBB_PRIVCFGRn.
Writes are ignored if SPLCKn bit is set in GTZC1_MPCBB_CFGLOCK.</description>
                <bitOffset>11</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Non-secure access only to block y, belonging to super-block n. Secure access is also allowed if the SRWILADIS bit is set in GTZC1_MPCBB_CR.</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Secure access only to block y, belonging to super-block n.</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>SEC12</name>
                <description>Security configuration for block y (y = 0 to 31) in super block n
Unprivileged write to this bit is ignored if PRIVy bit is set in GTZC1_MPCBB_PRIVCFGRn.
Writes are ignored if SPLCKn bit is set in GTZC1_MPCBB_CFGLOCK.</description>
                <bitOffset>12</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Non-secure access only to block y, belonging to super-block n. Secure access is also allowed if the SRWILADIS bit is set in GTZC1_MPCBB_CR.</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Secure access only to block y, belonging to super-block n.</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>SEC13</name>
                <description>Security configuration for block y (y = 0 to 31) in super block n
Unprivileged write to this bit is ignored if PRIVy bit is set in GTZC1_MPCBB_PRIVCFGRn.
Writes are ignored if SPLCKn bit is set in GTZC1_MPCBB_CFGLOCK.</description>
                <bitOffset>13</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Non-secure access only to block y, belonging to super-block n. Secure access is also allowed if the SRWILADIS bit is set in GTZC1_MPCBB_CR.</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Secure access only to block y, belonging to super-block n.</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>SEC14</name>
                <description>Security configuration for block y (y = 0 to 31) in super block n
Unprivileged write to this bit is ignored if PRIVy bit is set in GTZC1_MPCBB_PRIVCFGRn.
Writes are ignored if SPLCKn bit is set in GTZC1_MPCBB_CFGLOCK.</description>
                <bitOffset>14</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Non-secure access only to block y, belonging to super-block n. Secure access is also allowed if the SRWILADIS bit is set in GTZC1_MPCBB_CR.</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Secure access only to block y, belonging to super-block n.</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>SEC15</name>
                <description>Security configuration for block y (y = 0 to 31) in super block n
Unprivileged write to this bit is ignored if PRIVy bit is set in GTZC1_MPCBB_PRIVCFGRn.
Writes are ignored if SPLCKn bit is set in GTZC1_MPCBB_CFGLOCK.</description>
                <bitOffset>15</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Non-secure access only to block y, belonging to super-block n. Secure access is also allowed if the SRWILADIS bit is set in GTZC1_MPCBB_CR.</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Secure access only to block y, belonging to super-block n.</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>SEC16</name>
                <description>Security configuration for block y (y = 0 to 31) in super block n
Unprivileged write to this bit is ignored if PRIVy bit is set in GTZC1_MPCBB_PRIVCFGRn.
Writes are ignored if SPLCKn bit is set in GTZC1_MPCBB_CFGLOCK.</description>
                <bitOffset>16</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Non-secure access only to block y, belonging to super-block n. Secure access is also allowed if the SRWILADIS bit is set in GTZC1_MPCBB_CR.</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Secure access only to block y, belonging to super-block n.</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>SEC17</name>
                <description>Security configuration for block y (y = 0 to 31) in super block n
Unprivileged write to this bit is ignored if PRIVy bit is set in GTZC1_MPCBB_PRIVCFGRn.
Writes are ignored if SPLCKn bit is set in GTZC1_MPCBB_CFGLOCK.</description>
                <bitOffset>17</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Non-secure access only to block y, belonging to super-block n. Secure access is also allowed if the SRWILADIS bit is set in GTZC1_MPCBB_CR.</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Secure access only to block y, belonging to super-block n.</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>SEC18</name>
                <description>Security configuration for block y (y = 0 to 31) in super block n
Unprivileged write to this bit is ignored if PRIVy bit is set in GTZC1_MPCBB_PRIVCFGRn.
Writes are ignored if SPLCKn bit is set in GTZC1_MPCBB_CFGLOCK.</description>
                <bitOffset>18</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Non-secure access only to block y, belonging to super-block n. Secure access is also allowed if the SRWILADIS bit is set in GTZC1_MPCBB_CR.</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Secure access only to block y, belonging to super-block n.</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>SEC19</name>
                <description>Security configuration for block y (y = 0 to 31) in super block n
Unprivileged write to this bit is ignored if PRIVy bit is set in GTZC1_MPCBB_PRIVCFGRn.
Writes are ignored if SPLCKn bit is set in GTZC1_MPCBB_CFGLOCK.</description>
                <bitOffset>19</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Non-secure access only to block y, belonging to super-block n. Secure access is also allowed if the SRWILADIS bit is set in GTZC1_MPCBB_CR.</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Secure access only to block y, belonging to super-block n.</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>SEC20</name>
                <description>Security configuration for block y (y = 0 to 31) in super block n
Unprivileged write to this bit is ignored if PRIVy bit is set in GTZC1_MPCBB_PRIVCFGRn.
Writes are ignored if SPLCKn bit is set in GTZC1_MPCBB_CFGLOCK.</description>
                <bitOffset>20</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Non-secure access only to block y, belonging to super-block n. Secure access is also allowed if the SRWILADIS bit is set in GTZC1_MPCBB_CR.</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Secure access only to block y, belonging to super-block n.</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>SEC21</name>
                <description>Security configuration for block y (y = 0 to 31) in super block n
Unprivileged write to this bit is ignored if PRIVy bit is set in GTZC1_MPCBB_PRIVCFGRn.
Writes are ignored if SPLCKn bit is set in GTZC1_MPCBB_CFGLOCK.</description>
                <bitOffset>21</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Non-secure access only to block y, belonging to super-block n. Secure access is also allowed if the SRWILADIS bit is set in GTZC1_MPCBB_CR.</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Secure access only to block y, belonging to super-block n.</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>SEC22</name>
                <description>Security configuration for block y (y = 0 to 31) in super block n
Unprivileged write to this bit is ignored if PRIVy bit is set in GTZC1_MPCBB_PRIVCFGRn.
Writes are ignored if SPLCKn bit is set in GTZC1_MPCBB_CFGLOCK.</description>
                <bitOffset>22</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Non-secure access only to block y, belonging to super-block n. Secure access is also allowed if the SRWILADIS bit is set in GTZC1_MPCBB_CR.</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Secure access only to block y, belonging to super-block n.</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>SEC23</name>
                <description>Security configuration for block y (y = 0 to 31) in super block n
Unprivileged write to this bit is ignored if PRIVy bit is set in GTZC1_MPCBB_PRIVCFGRn.
Writes are ignored if SPLCKn bit is set in GTZC1_MPCBB_CFGLOCK.</description>
                <bitOffset>23</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Non-secure access only to block y, belonging to super-block n. Secure access is also allowed if the SRWILADIS bit is set in GTZC1_MPCBB_CR.</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Secure access only to block y, belonging to super-block n.</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>SEC24</name>
                <description>Security configuration for block y (y = 0 to 31) in super block n
Unprivileged write to this bit is ignored if PRIVy bit is set in GTZC1_MPCBB_PRIVCFGRn.
Writes are ignored if SPLCKn bit is set in GTZC1_MPCBB_CFGLOCK.</description>
                <bitOffset>24</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Non-secure access only to block y, belonging to super-block n. Secure access is also allowed if the SRWILADIS bit is set in GTZC1_MPCBB_CR.</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Secure access only to block y, belonging to super-block n.</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>SEC25</name>
                <description>Security configuration for block y (y = 0 to 31) in super block n
Unprivileged write to this bit is ignored if PRIVy bit is set in GTZC1_MPCBB_PRIVCFGRn.
Writes are ignored if SPLCKn bit is set in GTZC1_MPCBB_CFGLOCK.</description>
                <bitOffset>25</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Non-secure access only to block y, belonging to super-block n. Secure access is also allowed if the SRWILADIS bit is set in GTZC1_MPCBB_CR.</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Secure access only to block y, belonging to super-block n.</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>SEC26</name>
                <description>Security configuration for block y (y = 0 to 31) in super block n
Unprivileged write to this bit is ignored if PRIVy bit is set in GTZC1_MPCBB_PRIVCFGRn.
Writes are ignored if SPLCKn bit is set in GTZC1_MPCBB_CFGLOCK.</description>
                <bitOffset>26</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Non-secure access only to block y, belonging to super-block n. Secure access is also allowed if the SRWILADIS bit is set in GTZC1_MPCBB_CR.</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Secure access only to block y, belonging to super-block n.</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>SEC27</name>
                <description>Security configuration for block y (y = 0 to 31) in super block n
Unprivileged write to this bit is ignored if PRIVy bit is set in GTZC1_MPCBB_PRIVCFGRn.
Writes are ignored if SPLCKn bit is set in GTZC1_MPCBB_CFGLOCK.</description>
                <bitOffset>27</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Non-secure access only to block y, belonging to super-block n. Secure access is also allowed if the SRWILADIS bit is set in GTZC1_MPCBB_CR.</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Secure access only to block y, belonging to super-block n.</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>SEC28</name>
                <description>Security configuration for block y (y = 0 to 31) in super block n
Unprivileged write to this bit is ignored if PRIVy bit is set in GTZC1_MPCBB_PRIVCFGRn.
Writes are ignored if SPLCKn bit is set in GTZC1_MPCBB_CFGLOCK.</description>
                <bitOffset>28</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Non-secure access only to block y, belonging to super-block n. Secure access is also allowed if the SRWILADIS bit is set in GTZC1_MPCBB_CR.</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Secure access only to block y, belonging to super-block n.</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>SEC29</name>
                <description>Security configuration for block y (y = 0 to 31) in super block n
Unprivileged write to this bit is ignored if PRIVy bit is set in GTZC1_MPCBB_PRIVCFGRn.
Writes are ignored if SPLCKn bit is set in GTZC1_MPCBB_CFGLOCK.</description>
                <bitOffset>29</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Non-secure access only to block y, belonging to super-block n. Secure access is also allowed if the SRWILADIS bit is set in GTZC1_MPCBB_CR.</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Secure access only to block y, belonging to super-block n.</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>SEC30</name>
                <description>Security configuration for block y (y = 0 to 31) in super block n
Unprivileged write to this bit is ignored if PRIVy bit is set in GTZC1_MPCBB_PRIVCFGRn.
Writes are ignored if SPLCKn bit is set in GTZC1_MPCBB_CFGLOCK.</description>
                <bitOffset>30</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Non-secure access only to block y, belonging to super-block n. Secure access is also allowed if the SRWILADIS bit is set in GTZC1_MPCBB_CR.</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Secure access only to block y, belonging to super-block n.</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>SEC31</name>
                <description>Security configuration for block y (y = 0 to 31) in super block n
Unprivileged write to this bit is ignored if PRIVy bit is set in GTZC1_MPCBB_PRIVCFGRn.
Writes are ignored if SPLCKn bit is set in GTZC1_MPCBB_CFGLOCK.</description>
                <bitOffset>31</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Non-secure access only to block y, belonging to super-block n. Secure access is also allowed if the SRWILADIS bit is set in GTZC1_MPCBB_CR.</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Secure access only to block y, belonging to super-block n.</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
            </fields>
          </register>
          <register>
            <name>GTZC1_MPCBB_PRIVCFGR0</name>
            <displayName>GTZC1_MPCBB_PRIVCFGR0</displayName>
            <description>GTZC1 MPCBB privileged configuration for super-block 0	register</description>
            <addressOffset>0x200</addressOffset>
            <size>0x20</size>
            <resetValue>0xFFFFFFFF</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>PRIV0</name>
                <description>Privileged configuration for block y (y = 0 to 31), belonging to super-block n.
Non-secure write to this bit is ignored if SECy bit is set in GTZC1_MPCBB_SECCFGRn.
Writes are ignored if SPLCKn bit is set in GTZC1_MPCBB_CFGLOCK.</description>
                <bitOffset>0</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Privileged and unprivileged access to block y, belonging to super-block n</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Only privileged access to block y, belonging to super-block n</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>PRIV1</name>
                <description>Privileged configuration for block y (y = 0 to 31), belonging to super-block n.
Non-secure write to this bit is ignored if SECy bit is set in GTZC1_MPCBB_SECCFGRn.
Writes are ignored if SPLCKn bit is set in GTZC1_MPCBB_CFGLOCK.</description>
                <bitOffset>1</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Privileged and unprivileged access to block y, belonging to super-block n</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Only privileged access to block y, belonging to super-block n</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>PRIV2</name>
                <description>Privileged configuration for block y (y = 0 to 31), belonging to super-block n.
Non-secure write to this bit is ignored if SECy bit is set in GTZC1_MPCBB_SECCFGRn.
Writes are ignored if SPLCKn bit is set in GTZC1_MPCBB_CFGLOCK.</description>
                <bitOffset>2</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Privileged and unprivileged access to block y, belonging to super-block n</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Only privileged access to block y, belonging to super-block n</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>PRIV3</name>
                <description>Privileged configuration for block y (y = 0 to 31), belonging to super-block n.
Non-secure write to this bit is ignored if SECy bit is set in GTZC1_MPCBB_SECCFGRn.
Writes are ignored if SPLCKn bit is set in GTZC1_MPCBB_CFGLOCK.</description>
                <bitOffset>3</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Privileged and unprivileged access to block y, belonging to super-block n</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Only privileged access to block y, belonging to super-block n</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>PRIV4</name>
                <description>Privileged configuration for block y (y = 0 to 31), belonging to super-block n.
Non-secure write to this bit is ignored if SECy bit is set in GTZC1_MPCBB_SECCFGRn.
Writes are ignored if SPLCKn bit is set in GTZC1_MPCBB_CFGLOCK.</description>
                <bitOffset>4</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Privileged and unprivileged access to block y, belonging to super-block n</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Only privileged access to block y, belonging to super-block n</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>PRIV5</name>
                <description>Privileged configuration for block y (y = 0 to 31), belonging to super-block n.
Non-secure write to this bit is ignored if SECy bit is set in GTZC1_MPCBB_SECCFGRn.
Writes are ignored if SPLCKn bit is set in GTZC1_MPCBB_CFGLOCK.</description>
                <bitOffset>5</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Privileged and unprivileged access to block y, belonging to super-block n</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Only privileged access to block y, belonging to super-block n</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>PRIV6</name>
                <description>Privileged configuration for block y (y = 0 to 31), belonging to super-block n.
Non-secure write to this bit is ignored if SECy bit is set in GTZC1_MPCBB_SECCFGRn.
Writes are ignored if SPLCKn bit is set in GTZC1_MPCBB_CFGLOCK.</description>
                <bitOffset>6</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Privileged and unprivileged access to block y, belonging to super-block n</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Only privileged access to block y, belonging to super-block n</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>PRIV7</name>
                <description>Privileged configuration for block y (y = 0 to 31), belonging to super-block n.
Non-secure write to this bit is ignored if SECy bit is set in GTZC1_MPCBB_SECCFGRn.
Writes are ignored if SPLCKn bit is set in GTZC1_MPCBB_CFGLOCK.</description>
                <bitOffset>7</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Privileged and unprivileged access to block y, belonging to super-block n</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Only privileged access to block y, belonging to super-block n</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>PRIV8</name>
                <description>Privileged configuration for block y (y = 0 to 31), belonging to super-block n.
Non-secure write to this bit is ignored if SECy bit is set in GTZC1_MPCBB_SECCFGRn.
Writes are ignored if SPLCKn bit is set in GTZC1_MPCBB_CFGLOCK.</description>
                <bitOffset>8</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Privileged and unprivileged access to block y, belonging to super-block n</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Only privileged access to block y, belonging to super-block n</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>PRIV9</name>
                <description>Privileged configuration for block y (y = 0 to 31), belonging to super-block n.
Non-secure write to this bit is ignored if SECy bit is set in GTZC1_MPCBB_SECCFGRn.
Writes are ignored if SPLCKn bit is set in GTZC1_MPCBB_CFGLOCK.</description>
                <bitOffset>9</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Privileged and unprivileged access to block y, belonging to super-block n</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Only privileged access to block y, belonging to super-block n</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>PRIV10</name>
                <description>Privileged configuration for block y (y = 0 to 31), belonging to super-block n.
Non-secure write to this bit is ignored if SECy bit is set in GTZC1_MPCBB_SECCFGRn.
Writes are ignored if SPLCKn bit is set in GTZC1_MPCBB_CFGLOCK.</description>
                <bitOffset>10</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Privileged and unprivileged access to block y, belonging to super-block n</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Only privileged access to block y, belonging to super-block n</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>PRIV11</name>
                <description>Privileged configuration for block y (y = 0 to 31), belonging to super-block n.
Non-secure write to this bit is ignored if SECy bit is set in GTZC1_MPCBB_SECCFGRn.
Writes are ignored if SPLCKn bit is set in GTZC1_MPCBB_CFGLOCK.</description>
                <bitOffset>11</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Privileged and unprivileged access to block y, belonging to super-block n</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Only privileged access to block y, belonging to super-block n</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>PRIV12</name>
                <description>Privileged configuration for block y (y = 0 to 31), belonging to super-block n.
Non-secure write to this bit is ignored if SECy bit is set in GTZC1_MPCBB_SECCFGRn.
Writes are ignored if SPLCKn bit is set in GTZC1_MPCBB_CFGLOCK.</description>
                <bitOffset>12</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Privileged and unprivileged access to block y, belonging to super-block n</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Only privileged access to block y, belonging to super-block n</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>PRIV13</name>
                <description>Privileged configuration for block y (y = 0 to 31), belonging to super-block n.
Non-secure write to this bit is ignored if SECy bit is set in GTZC1_MPCBB_SECCFGRn.
Writes are ignored if SPLCKn bit is set in GTZC1_MPCBB_CFGLOCK.</description>
                <bitOffset>13</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Privileged and unprivileged access to block y, belonging to super-block n</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Only privileged access to block y, belonging to super-block n</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>PRIV14</name>
                <description>Privileged configuration for block y (y = 0 to 31), belonging to super-block n.
Non-secure write to this bit is ignored if SECy bit is set in GTZC1_MPCBB_SECCFGRn.
Writes are ignored if SPLCKn bit is set in GTZC1_MPCBB_CFGLOCK.</description>
                <bitOffset>14</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Privileged and unprivileged access to block y, belonging to super-block n</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Only privileged access to block y, belonging to super-block n</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>PRIV15</name>
                <description>Privileged configuration for block y (y = 0 to 31), belonging to super-block n.
Non-secure write to this bit is ignored if SECy bit is set in GTZC1_MPCBB_SECCFGRn.
Writes are ignored if SPLCKn bit is set in GTZC1_MPCBB_CFGLOCK.</description>
                <bitOffset>15</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Privileged and unprivileged access to block y, belonging to super-block n</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Only privileged access to block y, belonging to super-block n</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>PRIV16</name>
                <description>Privileged configuration for block y (y = 0 to 31), belonging to super-block n.
Non-secure write to this bit is ignored if SECy bit is set in GTZC1_MPCBB_SECCFGRn.
Writes are ignored if SPLCKn bit is set in GTZC1_MPCBB_CFGLOCK.</description>
                <bitOffset>16</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Privileged and unprivileged access to block y, belonging to super-block n</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Only privileged access to block y, belonging to super-block n</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>PRIV17</name>
                <description>Privileged configuration for block y (y = 0 to 31), belonging to super-block n.
Non-secure write to this bit is ignored if SECy bit is set in GTZC1_MPCBB_SECCFGRn.
Writes are ignored if SPLCKn bit is set in GTZC1_MPCBB_CFGLOCK.</description>
                <bitOffset>17</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Privileged and unprivileged access to block y, belonging to super-block n</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Only privileged access to block y, belonging to super-block n</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>PRIV18</name>
                <description>Privileged configuration for block y (y = 0 to 31), belonging to super-block n.
Non-secure write to this bit is ignored if SECy bit is set in GTZC1_MPCBB_SECCFGRn.
Writes are ignored if SPLCKn bit is set in GTZC1_MPCBB_CFGLOCK.</description>
                <bitOffset>18</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Privileged and unprivileged access to block y, belonging to super-block n</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Only privileged access to block y, belonging to super-block n</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>PRIV19</name>
                <description>Privileged configuration for block y (y = 0 to 31), belonging to super-block n.
Non-secure write to this bit is ignored if SECy bit is set in GTZC1_MPCBB_SECCFGRn.
Writes are ignored if SPLCKn bit is set in GTZC1_MPCBB_CFGLOCK.</description>
                <bitOffset>19</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Privileged and unprivileged access to block y, belonging to super-block n</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Only privileged access to block y, belonging to super-block n</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>PRIV20</name>
                <description>Privileged configuration for block y (y = 0 to 31), belonging to super-block n.
Non-secure write to this bit is ignored if SECy bit is set in GTZC1_MPCBB_SECCFGRn.
Writes are ignored if SPLCKn bit is set in GTZC1_MPCBB_CFGLOCK.</description>
                <bitOffset>20</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Privileged and unprivileged access to block y, belonging to super-block n</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Only privileged access to block y, belonging to super-block n</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>PRIV21</name>
                <description>Privileged configuration for block y (y = 0 to 31), belonging to super-block n.
Non-secure write to this bit is ignored if SECy bit is set in GTZC1_MPCBB_SECCFGRn.
Writes are ignored if SPLCKn bit is set in GTZC1_MPCBB_CFGLOCK.</description>
                <bitOffset>21</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Privileged and unprivileged access to block y, belonging to super-block n</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Only privileged access to block y, belonging to super-block n</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>PRIV22</name>
                <description>Privileged configuration for block y (y = 0 to 31), belonging to super-block n.
Non-secure write to this bit is ignored if SECy bit is set in GTZC1_MPCBB_SECCFGRn.
Writes are ignored if SPLCKn bit is set in GTZC1_MPCBB_CFGLOCK.</description>
                <bitOffset>22</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Privileged and unprivileged access to block y, belonging to super-block n</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Only privileged access to block y, belonging to super-block n</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>PRIV23</name>
                <description>Privileged configuration for block y (y = 0 to 31), belonging to super-block n.
Non-secure write to this bit is ignored if SECy bit is set in GTZC1_MPCBB_SECCFGRn.
Writes are ignored if SPLCKn bit is set in GTZC1_MPCBB_CFGLOCK.</description>
                <bitOffset>23</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Privileged and unprivileged access to block y, belonging to super-block n</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Only privileged access to block y, belonging to super-block n</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>PRIV24</name>
                <description>Privileged configuration for block y (y = 0 to 31), belonging to super-block n.
Non-secure write to this bit is ignored if SECy bit is set in GTZC1_MPCBB_SECCFGRn.
Writes are ignored if SPLCKn bit is set in GTZC1_MPCBB_CFGLOCK.</description>
                <bitOffset>24</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Privileged and unprivileged access to block y, belonging to super-block n</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Only privileged access to block y, belonging to super-block n</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>PRIV25</name>
                <description>Privileged configuration for block y (y = 0 to 31), belonging to super-block n.
Non-secure write to this bit is ignored if SECy bit is set in GTZC1_MPCBB_SECCFGRn.
Writes are ignored if SPLCKn bit is set in GTZC1_MPCBB_CFGLOCK.</description>
                <bitOffset>25</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Privileged and unprivileged access to block y, belonging to super-block n</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Only privileged access to block y, belonging to super-block n</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>PRIV26</name>
                <description>Privileged configuration for block y (y = 0 to 31), belonging to super-block n.
Non-secure write to this bit is ignored if SECy bit is set in GTZC1_MPCBB_SECCFGRn.
Writes are ignored if SPLCKn bit is set in GTZC1_MPCBB_CFGLOCK.</description>
                <bitOffset>26</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Privileged and unprivileged access to block y, belonging to super-block n</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Only privileged access to block y, belonging to super-block n</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>PRIV27</name>
                <description>Privileged configuration for block y (y = 0 to 31), belonging to super-block n.
Non-secure write to this bit is ignored if SECy bit is set in GTZC1_MPCBB_SECCFGRn.
Writes are ignored if SPLCKn bit is set in GTZC1_MPCBB_CFGLOCK.</description>
                <bitOffset>27</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Privileged and unprivileged access to block y, belonging to super-block n</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Only privileged access to block y, belonging to super-block n</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>PRIV28</name>
                <description>Privileged configuration for block y (y = 0 to 31), belonging to super-block n.
Non-secure write to this bit is ignored if SECy bit is set in GTZC1_MPCBB_SECCFGRn.
Writes are ignored if SPLCKn bit is set in GTZC1_MPCBB_CFGLOCK.</description>
                <bitOffset>28</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Privileged and unprivileged access to block y, belonging to super-block n</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Only privileged access to block y, belonging to super-block n</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>PRIV29</name>
                <description>Privileged configuration for block y (y = 0 to 31), belonging to super-block n.
Non-secure write to this bit is ignored if SECy bit is set in GTZC1_MPCBB_SECCFGRn.
Writes are ignored if SPLCKn bit is set in GTZC1_MPCBB_CFGLOCK.</description>
                <bitOffset>29</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Privileged and unprivileged access to block y, belonging to super-block n</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Only privileged access to block y, belonging to super-block n</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>PRIV30</name>
                <description>Privileged configuration for block y (y = 0 to 31), belonging to super-block n.
Non-secure write to this bit is ignored if SECy bit is set in GTZC1_MPCBB_SECCFGRn.
Writes are ignored if SPLCKn bit is set in GTZC1_MPCBB_CFGLOCK.</description>
                <bitOffset>30</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Privileged and unprivileged access to block y, belonging to super-block n</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Only privileged access to block y, belonging to super-block n</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>PRIV31</name>
                <description>Privileged configuration for block y (y = 0 to 31), belonging to super-block n.
Non-secure write to this bit is ignored if SECy bit is set in GTZC1_MPCBB_SECCFGRn.
Writes are ignored if SPLCKn bit is set in GTZC1_MPCBB_CFGLOCK.</description>
                <bitOffset>31</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Privileged and unprivileged access to block y, belonging to super-block n</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Only privileged access to block y, belonging to super-block n</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
            </fields>
          </register>
        </registers>
    </peripheral>
	<peripheral derivedFrom="GTZC1_MPCBB6">
      <name>SEC_GTZC1_MPCBB6</name>
      <baseAddress>0x50034000</baseAddress>
    </peripheral>	
	<peripheral>
        <name>HASH</name>
        <description>Hash processor</description>
        <groupName>HASH</groupName>
        <baseAddress>0x420C0400</baseAddress>
        <addressBlock>
          <offset>0x0</offset>
          <size>0x400</size>
          <usage>registers</usage>
        </addressBlock>
        <interrupt>
          <name>HASH</name>
          <description>HASH interrupt</description>
          <value>61</value>
        </interrupt>
        <registers>
          <register>
            <name>HASH_CR</name>
            <displayName>HASH_CR</displayName>
            <description>HASH control register</description>
            <addressOffset>0x00</addressOffset>
            <size>0x20</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>INIT</name>
                <description>Initialize message digest calculation
Writing this bit to 1 resets the hash processor core, so that the HASH is ready to compute the message digest of a new message.
Writing this bit to 0 has no effect. Reading this bit always return 0.</description>
                <bitOffset>2</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>DMAE</name>
                <description>DMA enable
After this bit is set it is cleared by hardware while the last data of the message is written into the hash processor.
Setting this bit to 0 while a DMA transfer is ongoing is not aborting this current transfer. Instead, the DMA interface of the IP remains internally enabled until the transfer is completed or INIT is written to 1.
Setting INIT bit to 1 does not clear DMAE bit.</description>
                <bitOffset>3</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>DMA transfers disabled</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>DMA transfers enabled. A DMA request is sent as soon as the HASH core is ready to receive data.</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>DATATYPE</name>
                <description>Data type selection
Defines the format of the data entered into the HASH_DIN register:</description>
                <bitOffset>4</bitOffset>
                <bitWidth>2</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>32-bit data. The data written into HASH_DIN are directly used by the HASH processing, without reordering.</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>16-bit data, or half-word. The data written into HASH_DIN are considered as two half-words, and are swapped before being used by the HASH processing.</description>
                    <value>0x1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x2</name>
                    <description>8-bit data, or bytes. The data written into HASH_DIN are considered as four bytes, and are swapped before being used by the HASH processing.</description>
                    <value>0x2</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x3</name>
                    <description>bit data, or bit-string. The data written into HASH_DIN are considered as 32 bits (1st bit of the string at position 0), and are swapped before being used by the HASH processing (1st bit of the string at position 31).</description>
                    <value>0x3</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>MODE</name>
                <description>Mode selection
This bit selects the HASH or HMAC mode for the selected algorithm:
This selection is only taken into account when the INIT bit is set. Changing this bit during a computation has no effect.</description>
                <bitOffset>6</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Hash mode selected</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>HMAC mode selected. LKEY must be set if the key being used is longer than 64 bytes.</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>ALGO0</name>
                <description>Algorithm selection
These bits select the hash algorithm. 
This selection is only taken into account when the INIT bit is set. Changing this bitfield during a computation has no effect.</description>
                <bitOffset>7</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>SHA-1</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>MD5</description>
                    <value>0x1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x2</name>
                    <description>SHA-224</description>
                    <value>0x2</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x3</name>
                    <description>SHA-256</description>
                    <value>0x3</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>NBW</name>
                <description>Number of words already pushed
This bitfield reflects the number of words in the message that have already been pushed into the IN FIFO. NBW is incremented by one when a write access to the HASH_DIN register is performed (except if DINNE = 0 and the DMA is not used, see below description). NBW goes to zero when the INIT bit is written to 1.
This bitfield is read-only. 
If the DMA is not used
...
If the DMA is used
NBW contains the exact number of words that have been pushed into the IN FIFO by the DMA.</description>
                <bitOffset>8</bitOffset>
                <bitWidth>4</bitWidth>
                <access>read-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>if DINNE = 0, no word has been pushed into the DIN buffer (both HASH_DIN register and IN FIFO are empty), otherwise one word has been pushed into the DIN buffer (HASH_DIN register contains one word and IN FIFO is empty)</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>two words have been pushed into the DIN buffer (that is HASH_DIN register and the IN FIFO contain one word each)</description>
                    <value>0x1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0xF</name>
                    <description>16 words have been pushed into the DIN buffer.</description>
                    <value>0xF</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>DINNE</name>
                <description>DIN not empty
This bit is set when the HASH_DIN register holds valid data (that is after being written at least once). It is cleared when either the INIT bit (initialization) or the DCAL bit (completion of the previous message processing) is written to 1.
This bit is read-only.</description>
                <bitOffset>12</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>No data are present in the data input buffer</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>The input buffer contains at least one word of data</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>MDMAT</name>
                <description>Multiple DMA transfers 
This bit is set when hashing large files when multiple DMA transfers are needed.</description>
                <bitOffset>13</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>DCAL is automatically set at the end of a DMA transfer.</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>DCAL is not automatically set at the end of a DMA transfer.</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>LKEY</name>
                <description>Long key selection
This bit selects between short key ( 64 bytes) or long key (&gt; 64 bytes) in HMAC mode.
This selection is only taken into account when the INIT bit is set and MODE = 1. Changing this bit during a computation has no effect.</description>
                <bitOffset>16</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>the HMAC key is shorter or equal to 64 bytes. The actual key value written to HASH_DIN is used during the HMAC computation.</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>the HMAC key is longer than 64 bytes. The hash of the key is used instead of the real key during the HMAC computation.</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>ALGO1</name>
                <description>Algorithm selection
These bits select the hash algorithm. 
This selection is only taken into account when the INIT bit is set. Changing this bitfield during a computation has no effect.</description>
                <bitOffset>18</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>SHA-1</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>MD5</description>
                    <value>0x1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x2</name>
                    <description>SHA-224</description>
                    <value>0x2</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x3</name>
                    <description>SHA-256</description>
                    <value>0x3</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
            </fields>
          </register>
          <register>
            <name>HASH_DIN</name>
            <displayName>HASH_DIN</displayName>
            <description>HASH data input register</description>
            <addressOffset>0x04</addressOffset>
            <size>0x20</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>DATAIN</name>
                <description>Data input
Writing this register pushes the current register content into the IN FIFO, and the register takes the new value presented on the AHB databus.
Reading this register returns the current register content.</description>
                <bitOffset>0</bitOffset>
                <bitWidth>32</bitWidth>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>HASH_STR</name>
            <displayName>HASH_STR</displayName>
            <description>HASH start register</description>
            <addressOffset>0x08</addressOffset>
            <size>0x20</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>NBLW</name>
                <description>Number of valid bits in the last word
When the last word of the message bit string is written in HASH_DIN register, the hash processor takes only the valid bits specified as below, after internal data swapping:
...
The above mechanism is valid only if DCAL = 0. If NBLW[4:0] bitfield is written while DCAL is set to 1, the NBLW[4:0] bitfield remains unchanged. In other words it is not possible to configure NBLW[4:0] and set DCAL at the same time.
Reading NBLW[4:0] bitfield returns the last value written to NBLW[4:0].</description>
                <bitOffset>0</bitOffset>
                <bitWidth>5</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x00</name>
                    <description>All 32 bits of the last data written are valid message bits that is M[31:0]</description>
                    <value>0x00</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x01</name>
                    <description>Only one bit of the last data written (after swapping) is valid that is M[0]</description>
                    <value>0x01</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x02</name>
                    <description>Only two bits of the last data written (after swapping) are valid that is M[1:0]</description>
                    <value>0x02</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x03</name>
                    <description>Only three bits of the last data written (after swapping) are valid that is M[2:0]</description>
                    <value>0x03</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1F</name>
                    <description>Only 31 bits of the last data written (after swapping) are valid that is M[30:0]</description>
                    <value>0x1F</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>DCAL</name>
                <description>Digest calculation
Writing this bit to 1 starts the message padding, using the previously written value of NBLW[4:0], and starts the calculation of the final message digest with all data words written to the input FIFO since the INIT bit was last written to 1.
Reading this bit returns 0.</description>
                <bitOffset>8</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>HASH_HRA0</name>
            <displayName>HASH_HRA0</displayName>
            <description>HASH aliased digest register 0</description>
            <addressOffset>0xC</addressOffset>
            <size>0x20</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>H0</name>
                <description>Hash data x
Refer to Section 40.7.4: HASH digest registers introduction.</description>
                <bitOffset>0</bitOffset>
                <bitWidth>32</bitWidth>
                <access>read-only</access>
              </field>
            </fields>
          </register>
          <register>
            <name>HASH_HRA1</name>
            <displayName>HASH_HRA1</displayName>
            <description>HASH aliased digest register 1</description>
            <addressOffset>0x10</addressOffset>
            <size>0x20</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>H1</name>
                <description>Hash data x
Refer to Section 40.7.4: HASH digest registers introduction.</description>
                <bitOffset>0</bitOffset>
                <bitWidth>32</bitWidth>
                <access>read-only</access>
              </field>
            </fields>
          </register>
          <register>
            <name>HASH_HRA2</name>
            <displayName>HASH_HRA2</displayName>
            <description>HASH aliased digest register 2</description>
            <addressOffset>0x14</addressOffset>
            <size>0x20</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>H2</name>
                <description>Hash data x
Refer to Section 40.7.4: HASH digest registers introduction.</description>
                <bitOffset>0</bitOffset>
                <bitWidth>32</bitWidth>
                <access>read-only</access>
              </field>
            </fields>
          </register>
          <register>
            <name>HASH_HRA3</name>
            <displayName>HASH_HRA3</displayName>
            <description>HASH aliased digest register 3</description>
            <addressOffset>0x18</addressOffset>
            <size>0x20</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>H3</name>
                <description>Hash data x
Refer to Section 40.7.4: HASH digest registers introduction.</description>
                <bitOffset>0</bitOffset>
                <bitWidth>32</bitWidth>
                <access>read-only</access>
              </field>
            </fields>
          </register>
          <register>
            <name>HASH_HRA4</name>
            <displayName>HASH_HRA4</displayName>
            <description>HASH aliased digest register 4</description>
            <addressOffset>0x1C</addressOffset>
            <size>0x20</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>H4</name>
                <description>Hash data x
Refer to Section 40.7.4: HASH digest registers introduction.</description>
                <bitOffset>0</bitOffset>
                <bitWidth>32</bitWidth>
                <access>read-only</access>
              </field>
            </fields>
          </register>
          <register>
            <name>HASH_IMR</name>
            <displayName>HASH_IMR</displayName>
            <description>HASH interrupt enable register</description>
            <addressOffset>0x20</addressOffset>
            <size>0x20</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>DINIE</name>
                <description>Data input interrupt enable</description>
                <bitOffset>0</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Data input interrupt disabled</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Data input interrupt enabled</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>DCIE</name>
                <description>Digest calculation completion interrupt enable</description>
                <bitOffset>1</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Digest calculation completion interrupt disabled</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Digest calculation completion interrupt enabled.</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
            </fields>
          </register>
          <register>
            <name>HASH_SR</name>
            <displayName>HASH_SR</displayName>
            <description>HASH status register</description>
            <addressOffset>0x24</addressOffset>
            <size>0x20</size>
            <resetValue>0x00000001</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>DINIS</name>
                <description>Data input interrupt status
This bit is set by hardware when the FIFO is ready to get a new block (16 locations are free). It is cleared by writing it to 0 or by writing the HASH_DIN register.
When DINIS=0, HASH_CSRx registers reads as zero.</description>
                <bitOffset>0</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Less than 16 locations are free in the input buffer</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>A new block can be entered into the input buffer. An interrupt is generated if the DINIE bit is set in the HASH_IMR register.</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>DCIS</name>
                <description>Digest calculation completion interrupt status
This bit is set by hardware when a digest becomes ready (the whole message has been processed). It is cleared by writing it to 0 or by writing the INIT bit to 1 in the HASH_CR register.</description>
                <bitOffset>1</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>No digest available in the HASH_HRx registers (zeros are returned)</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Digest calculation complete, a digest is available in the HASH_HRx registers. An interrupt is generated if the DCIE bit is set in the HASH_IMR register.</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>DMAS</name>
                <description>DMA Status
This bit provides information on the DMA interface activity. It is set with DMAE and cleared when DMAE = 0 and no DMA transfer is ongoing. No interrupt is associated with this bit.</description>
                <bitOffset>2</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>DMA interface is disabled (DMAE = 0) and no transfer is ongoing</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>DMA interface is enabled (DMAE = 1) or a transfer is ongoing</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>BUSY</name>
                <description>Busy bit</description>
                <bitOffset>3</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>No block is currently being processed</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>The hash core is processing a block of data</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
            </fields>
          </register>
          <register>
            <name>HASH_CSR0</name>
            <displayName>HASH_CSR0</displayName>
            <description>HASH context swap register 0</description>
            <addressOffset>0xF8</addressOffset>
            <size>0x20</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>CS0</name>
                <description>Context swap x
Refer to Section 40.7.7: HASH context swap registers introduction.</description>
                <bitOffset>0</bitOffset>
                <bitWidth>32</bitWidth>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>HASH_CSR1</name>
            <displayName>HASH_CSR1</displayName>
            <description>HASH context swap register 1</description>
            <addressOffset>0xFC</addressOffset>
            <size>0x20</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>CS1</name>
                <description>Context swap x
Refer to Section 40.7.7: HASH context swap registers introduction.</description>
                <bitOffset>0</bitOffset>
                <bitWidth>32</bitWidth>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>HASH_CSR2</name>
            <displayName>HASH_CSR2</displayName>
            <description>HASH context swap register 2</description>
            <addressOffset>0x100</addressOffset>
            <size>0x20</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>CS2</name>
                <description>Context swap x
Refer to Section 40.7.7: HASH context swap registers introduction.</description>
                <bitOffset>0</bitOffset>
                <bitWidth>32</bitWidth>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>HASH_CSR3</name>
            <displayName>HASH_CSR3</displayName>
            <description>HASH context swap register 3</description>
            <addressOffset>0x104</addressOffset>
            <size>0x20</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>CS3</name>
                <description>Context swap x
Refer to Section 40.7.7: HASH context swap registers introduction.</description>
                <bitOffset>0</bitOffset>
                <bitWidth>32</bitWidth>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>HASH_CSR4</name>
            <displayName>HASH_CSR4</displayName>
            <description>HASH context swap register 4</description>
            <addressOffset>0x108</addressOffset>
            <size>0x20</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>CS4</name>
                <description>Context swap x
Refer to Section 40.7.7: HASH context swap registers introduction.</description>
                <bitOffset>0</bitOffset>
                <bitWidth>32</bitWidth>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>HASH_CSR5</name>
            <displayName>HASH_CSR5</displayName>
            <description>HASH context swap register 5</description>
            <addressOffset>0x10C</addressOffset>
            <size>0x20</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>CS5</name>
                <description>Context swap x
Refer to Section 40.7.7: HASH context swap registers introduction.</description>
                <bitOffset>0</bitOffset>
                <bitWidth>32</bitWidth>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>HASH_CSR6</name>
            <displayName>HASH_CSR6</displayName>
            <description>HASH context swap register 6</description>
            <addressOffset>0x110</addressOffset>
            <size>0x20</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>CS6</name>
                <description>Context swap x
Refer to Section 40.7.7: HASH context swap registers introduction.</description>
                <bitOffset>0</bitOffset>
                <bitWidth>32</bitWidth>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>HASH_CSR7</name>
            <displayName>HASH_CSR7</displayName>
            <description>HASH context swap register 7</description>
            <addressOffset>0x114</addressOffset>
            <size>0x20</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>CS7</name>
                <description>Context swap x
Refer to Section 40.7.7: HASH context swap registers introduction.</description>
                <bitOffset>0</bitOffset>
                <bitWidth>32</bitWidth>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>HASH_CSR8</name>
            <displayName>HASH_CSR8</displayName>
            <description>HASH context swap register 8</description>
            <addressOffset>0x118</addressOffset>
            <size>0x20</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>CS8</name>
                <description>Context swap x
Refer to Section 40.7.7: HASH context swap registers introduction.</description>
                <bitOffset>0</bitOffset>
                <bitWidth>32</bitWidth>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>HASH_CSR9</name>
            <displayName>HASH_CSR9</displayName>
            <description>HASH context swap register 9</description>
            <addressOffset>0x11C</addressOffset>
            <size>0x20</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>CS9</name>
                <description>Context swap x
Refer to Section 40.7.7: HASH context swap registers introduction.</description>
                <bitOffset>0</bitOffset>
                <bitWidth>32</bitWidth>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>HASH_CSR10</name>
            <displayName>HASH_CSR10</displayName>
            <description>HASH context swap register 10</description>
            <addressOffset>0x120</addressOffset>
            <size>0x20</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>CS10</name>
                <description>Context swap x
Refer to Section 40.7.7: HASH context swap registers introduction.</description>
                <bitOffset>0</bitOffset>
                <bitWidth>32</bitWidth>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>HASH_CSR11</name>
            <displayName>HASH_CSR11</displayName>
            <description>HASH context swap register 11</description>
            <addressOffset>0x124</addressOffset>
            <size>0x20</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>CS11</name>
                <description>Context swap x
Refer to Section 40.7.7: HASH context swap registers introduction.</description>
                <bitOffset>0</bitOffset>
                <bitWidth>32</bitWidth>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>HASH_CSR12</name>
            <displayName>HASH_CSR12</displayName>
            <description>HASH context swap register 12</description>
            <addressOffset>0x128</addressOffset>
            <size>0x20</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>CS12</name>
                <description>Context swap x
Refer to Section 40.7.7: HASH context swap registers introduction.</description>
                <bitOffset>0</bitOffset>
                <bitWidth>32</bitWidth>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>HASH_CSR13</name>
            <displayName>HASH_CSR13</displayName>
            <description>HASH context swap register 13</description>
            <addressOffset>0x12C</addressOffset>
            <size>0x20</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>CS13</name>
                <description>Context swap x
Refer to Section 40.7.7: HASH context swap registers introduction.</description>
                <bitOffset>0</bitOffset>
                <bitWidth>32</bitWidth>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>HASH_CSR14</name>
            <displayName>HASH_CSR14</displayName>
            <description>HASH context swap register 14</description>
            <addressOffset>0x130</addressOffset>
            <size>0x20</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>CS14</name>
                <description>Context swap x
Refer to Section 40.7.7: HASH context swap registers introduction.</description>
                <bitOffset>0</bitOffset>
                <bitWidth>32</bitWidth>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>HASH_CSR15</name>
            <displayName>HASH_CSR15</displayName>
            <description>HASH context swap register 15</description>
            <addressOffset>0x134</addressOffset>
            <size>0x20</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>CS15</name>
                <description>Context swap x
Refer to Section 40.7.7: HASH context swap registers introduction.</description>
                <bitOffset>0</bitOffset>
                <bitWidth>32</bitWidth>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>HASH_CSR16</name>
            <displayName>HASH_CSR16</displayName>
            <description>HASH context swap register 16</description>
            <addressOffset>0x138</addressOffset>
            <size>0x20</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>CS16</name>
                <description>Context swap x
Refer to Section 40.7.7: HASH context swap registers introduction.</description>
                <bitOffset>0</bitOffset>
                <bitWidth>32</bitWidth>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>HASH_CSR17</name>
            <displayName>HASH_CSR17</displayName>
            <description>HASH context swap register 17</description>
            <addressOffset>0x13C</addressOffset>
            <size>0x20</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>CS17</name>
                <description>Context swap x
Refer to Section 40.7.7: HASH context swap registers introduction.</description>
                <bitOffset>0</bitOffset>
                <bitWidth>32</bitWidth>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>HASH_CSR18</name>
            <displayName>HASH_CSR18</displayName>
            <description>HASH context swap register 18</description>
            <addressOffset>0x140</addressOffset>
            <size>0x20</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>CS18</name>
                <description>Context swap x
Refer to Section 40.7.7: HASH context swap registers introduction.</description>
                <bitOffset>0</bitOffset>
                <bitWidth>32</bitWidth>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>HASH_CSR19</name>
            <displayName>HASH_CSR19</displayName>
            <description>HASH context swap register 19</description>
            <addressOffset>0x144</addressOffset>
            <size>0x20</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>CS19</name>
                <description>Context swap x
Refer to Section 40.7.7: HASH context swap registers introduction.</description>
                <bitOffset>0</bitOffset>
                <bitWidth>32</bitWidth>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>HASH_CSR20</name>
            <displayName>HASH_CSR20</displayName>
            <description>HASH context swap register 20</description>
            <addressOffset>0x148</addressOffset>
            <size>0x20</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>CS20</name>
                <description>Context swap x
Refer to Section 40.7.7: HASH context swap registers introduction.</description>
                <bitOffset>0</bitOffset>
                <bitWidth>32</bitWidth>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>HASH_CSR21</name>
            <displayName>HASH_CSR21</displayName>
            <description>HASH context swap register 21</description>
            <addressOffset>0x14C</addressOffset>
            <size>0x20</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>CS21</name>
                <description>Context swap x
Refer to Section 40.7.7: HASH context swap registers introduction.</description>
                <bitOffset>0</bitOffset>
                <bitWidth>32</bitWidth>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>HASH_CSR22</name>
            <displayName>HASH_CSR22</displayName>
            <description>HASH context swap register 22</description>
            <addressOffset>0x150</addressOffset>
            <size>0x20</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>CS22</name>
                <description>Context swap x
Refer to Section 40.7.7: HASH context swap registers introduction.</description>
                <bitOffset>0</bitOffset>
                <bitWidth>32</bitWidth>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>HASH_CSR23</name>
            <displayName>HASH_CSR23</displayName>
            <description>HASH context swap register 23</description>
            <addressOffset>0x154</addressOffset>
            <size>0x20</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>CS23</name>
                <description>Context swap x
Refer to Section 40.7.7: HASH context swap registers introduction.</description>
                <bitOffset>0</bitOffset>
                <bitWidth>32</bitWidth>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>HASH_CSR24</name>
            <displayName>HASH_CSR24</displayName>
            <description>HASH context swap register 24</description>
            <addressOffset>0x158</addressOffset>
            <size>0x20</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>CS24</name>
                <description>Context swap x
Refer to Section 40.7.7: HASH context swap registers introduction.</description>
                <bitOffset>0</bitOffset>
                <bitWidth>32</bitWidth>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>HASH_CSR25</name>
            <displayName>HASH_CSR25</displayName>
            <description>HASH context swap register 25</description>
            <addressOffset>0x15C</addressOffset>
            <size>0x20</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>CS25</name>
                <description>Context swap x
Refer to Section 40.7.7: HASH context swap registers introduction.</description>
                <bitOffset>0</bitOffset>
                <bitWidth>32</bitWidth>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>HASH_CSR26</name>
            <displayName>HASH_CSR26</displayName>
            <description>HASH context swap register 26</description>
            <addressOffset>0x160</addressOffset>
            <size>0x20</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>CS26</name>
                <description>Context swap x
Refer to Section 40.7.7: HASH context swap registers introduction.</description>
                <bitOffset>0</bitOffset>
                <bitWidth>32</bitWidth>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>HASH_CSR27</name>
            <displayName>HASH_CSR27</displayName>
            <description>HASH context swap register 27</description>
            <addressOffset>0x164</addressOffset>
            <size>0x20</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>CS27</name>
                <description>Context swap x
Refer to Section 40.7.7: HASH context swap registers introduction.</description>
                <bitOffset>0</bitOffset>
                <bitWidth>32</bitWidth>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>HASH_CSR28</name>
            <displayName>HASH_CSR28</displayName>
            <description>HASH context swap register 28</description>
            <addressOffset>0x168</addressOffset>
            <size>0x20</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>CS28</name>
                <description>Context swap x
Refer to Section 40.7.7: HASH context swap registers introduction.</description>
                <bitOffset>0</bitOffset>
                <bitWidth>32</bitWidth>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>HASH_CSR29</name>
            <displayName>HASH_CSR29</displayName>
            <description>HASH context swap register 29</description>
            <addressOffset>0x16C</addressOffset>
            <size>0x20</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>CS29</name>
                <description>Context swap x
Refer to Section 40.7.7: HASH context swap registers introduction.</description>
                <bitOffset>0</bitOffset>
                <bitWidth>32</bitWidth>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>HASH_CSR30</name>
            <displayName>HASH_CSR30</displayName>
            <description>HASH context swap register 30</description>
            <addressOffset>0x170</addressOffset>
            <size>0x20</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>CS30</name>
                <description>Context swap x
Refer to Section 40.7.7: HASH context swap registers introduction.</description>
                <bitOffset>0</bitOffset>
                <bitWidth>32</bitWidth>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>HASH_CSR31</name>
            <displayName>HASH_CSR31</displayName>
            <description>HASH context swap register 31</description>
            <addressOffset>0x174</addressOffset>
            <size>0x20</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>CS31</name>
                <description>Context swap x
Refer to Section 40.7.7: HASH context swap registers introduction.</description>
                <bitOffset>0</bitOffset>
                <bitWidth>32</bitWidth>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>HASH_CSR32</name>
            <displayName>HASH_CSR32</displayName>
            <description>HASH context swap register 32</description>
            <addressOffset>0x178</addressOffset>
            <size>0x20</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>CS32</name>
                <description>Context swap x
Refer to Section 40.7.7: HASH context swap registers introduction.</description>
                <bitOffset>0</bitOffset>
                <bitWidth>32</bitWidth>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>HASH_CSR33</name>
            <displayName>HASH_CSR33</displayName>
            <description>HASH context swap register 33</description>
            <addressOffset>0x17C</addressOffset>
            <size>0x20</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>CS33</name>
                <description>Context swap x
Refer to Section 40.7.7: HASH context swap registers introduction.</description>
                <bitOffset>0</bitOffset>
                <bitWidth>32</bitWidth>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>HASH_CSR34</name>
            <displayName>HASH_CSR34</displayName>
            <description>HASH context swap register 34</description>
            <addressOffset>0x180</addressOffset>
            <size>0x20</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>CS34</name>
                <description>Context swap x
Refer to Section 40.7.7: HASH context swap registers introduction.</description>
                <bitOffset>0</bitOffset>
                <bitWidth>32</bitWidth>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>HASH_CSR35</name>
            <displayName>HASH_CSR35</displayName>
            <description>HASH context swap register 35</description>
            <addressOffset>0x184</addressOffset>
            <size>0x20</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>CS35</name>
                <description>Context swap x
Refer to Section 40.7.7: HASH context swap registers introduction.</description>
                <bitOffset>0</bitOffset>
                <bitWidth>32</bitWidth>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>HASH_CSR36</name>
            <displayName>HASH_CSR36</displayName>
            <description>HASH context swap register 36</description>
            <addressOffset>0x188</addressOffset>
            <size>0x20</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>CS36</name>
                <description>Context swap x
Refer to Section 40.7.7: HASH context swap registers introduction.</description>
                <bitOffset>0</bitOffset>
                <bitWidth>32</bitWidth>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>HASH_CSR37</name>
            <displayName>HASH_CSR37</displayName>
            <description>HASH context swap register 37</description>
            <addressOffset>0x18C</addressOffset>
            <size>0x20</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>CS37</name>
                <description>Context swap x
Refer to Section 40.7.7: HASH context swap registers introduction.</description>
                <bitOffset>0</bitOffset>
                <bitWidth>32</bitWidth>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>HASH_CSR38</name>
            <displayName>HASH_CSR38</displayName>
            <description>HASH context swap register 38</description>
            <addressOffset>0x190</addressOffset>
            <size>0x20</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>CS38</name>
                <description>Context swap x
Refer to Section 40.7.7: HASH context swap registers introduction.</description>
                <bitOffset>0</bitOffset>
                <bitWidth>32</bitWidth>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>HASH_CSR39</name>
            <displayName>HASH_CSR39</displayName>
            <description>HASH context swap register 39</description>
            <addressOffset>0x194</addressOffset>
            <size>0x20</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>CS39</name>
                <description>Context swap x
Refer to Section 40.7.7: HASH context swap registers introduction.</description>
                <bitOffset>0</bitOffset>
                <bitWidth>32</bitWidth>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>HASH_CSR40</name>
            <displayName>HASH_CSR40</displayName>
            <description>HASH context swap register 40</description>
            <addressOffset>0x198</addressOffset>
            <size>0x20</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>CS40</name>
                <description>Context swap x
Refer to Section 40.7.7: HASH context swap registers introduction.</description>
                <bitOffset>0</bitOffset>
                <bitWidth>32</bitWidth>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>HASH_CSR41</name>
            <displayName>HASH_CSR41</displayName>
            <description>HASH context swap register 41</description>
            <addressOffset>0x19C</addressOffset>
            <size>0x20</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>CS41</name>
                <description>Context swap x
Refer to Section 40.7.7: HASH context swap registers introduction.</description>
                <bitOffset>0</bitOffset>
                <bitWidth>32</bitWidth>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>HASH_CSR42</name>
            <displayName>HASH_CSR42</displayName>
            <description>HASH context swap register 42</description>
            <addressOffset>0x1A0</addressOffset>
            <size>0x20</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>CS42</name>
                <description>Context swap x
Refer to Section 40.7.7: HASH context swap registers introduction.</description>
                <bitOffset>0</bitOffset>
                <bitWidth>32</bitWidth>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>HASH_CSR43</name>
            <displayName>HASH_CSR43</displayName>
            <description>HASH context swap register 43</description>
            <addressOffset>0x1A4</addressOffset>
            <size>0x20</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>CS43</name>
                <description>Context swap x
Refer to Section 40.7.7: HASH context swap registers introduction.</description>
                <bitOffset>0</bitOffset>
                <bitWidth>32</bitWidth>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>HASH_CSR44</name>
            <displayName>HASH_CSR44</displayName>
            <description>HASH context swap register 44</description>
            <addressOffset>0x1A8</addressOffset>
            <size>0x20</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>CS44</name>
                <description>Context swap x
Refer to Section 40.7.7: HASH context swap registers introduction.</description>
                <bitOffset>0</bitOffset>
                <bitWidth>32</bitWidth>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>HASH_CSR45</name>
            <displayName>HASH_CSR45</displayName>
            <description>HASH context swap register 45</description>
            <addressOffset>0x1AC</addressOffset>
            <size>0x20</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>CS45</name>
                <description>Context swap x
Refer to Section 40.7.7: HASH context swap registers introduction.</description>
                <bitOffset>0</bitOffset>
                <bitWidth>32</bitWidth>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>HASH_CSR46</name>
            <displayName>HASH_CSR46</displayName>
            <description>HASH context swap register 46</description>
            <addressOffset>0x1B0</addressOffset>
            <size>0x20</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>CS46</name>
                <description>Context swap x
Refer to Section 40.7.7: HASH context swap registers introduction.</description>
                <bitOffset>0</bitOffset>
                <bitWidth>32</bitWidth>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>HASH_CSR47</name>
            <displayName>HASH_CSR47</displayName>
            <description>HASH context swap register 47</description>
            <addressOffset>0x1B4</addressOffset>
            <size>0x20</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>CS47</name>
                <description>Context swap x
Refer to Section 40.7.7: HASH context swap registers introduction.</description>
                <bitOffset>0</bitOffset>
                <bitWidth>32</bitWidth>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>HASH_CSR48</name>
            <displayName>HASH_CSR48</displayName>
            <description>HASH context swap register 48</description>
            <addressOffset>0x1B8</addressOffset>
            <size>0x20</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>CS48</name>
                <description>Context swap x
Refer to Section 40.7.7: HASH context swap registers introduction.</description>
                <bitOffset>0</bitOffset>
                <bitWidth>32</bitWidth>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>HASH_CSR49</name>
            <displayName>HASH_CSR49</displayName>
            <description>HASH context swap register 49</description>
            <addressOffset>0x1BC</addressOffset>
            <size>0x20</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>CS49</name>
                <description>Context swap x
Refer to Section 40.7.7: HASH context swap registers introduction.</description>
                <bitOffset>0</bitOffset>
                <bitWidth>32</bitWidth>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>HASH_CSR50</name>
            <displayName>HASH_CSR50</displayName>
            <description>HASH context swap register 50</description>
            <addressOffset>0x1C0</addressOffset>
            <size>0x20</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>CS50</name>
                <description>Context swap x
Refer to Section 40.7.7: HASH context swap registers introduction.</description>
                <bitOffset>0</bitOffset>
                <bitWidth>32</bitWidth>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>HASH_CSR51</name>
            <displayName>HASH_CSR51</displayName>
            <description>HASH context swap register 51</description>
            <addressOffset>0x1C4</addressOffset>
            <size>0x20</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>CS51</name>
                <description>Context swap x
Refer to Section 40.7.7: HASH context swap registers introduction.</description>
                <bitOffset>0</bitOffset>
                <bitWidth>32</bitWidth>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>HASH_CSR52</name>
            <displayName>HASH_CSR52</displayName>
            <description>HASH context swap register 52</description>
            <addressOffset>0x1C8</addressOffset>
            <size>0x20</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>CS52</name>
                <description>Context swap x
Refer to Section 40.7.7: HASH context swap registers introduction.</description>
                <bitOffset>0</bitOffset>
                <bitWidth>32</bitWidth>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>HASH_CSR53</name>
            <displayName>HASH_CSR53</displayName>
            <description>HASH context swap register 53</description>
            <addressOffset>0x1CC</addressOffset>
            <size>0x20</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>CS53</name>
                <description>Context swap x
Refer to Section 40.7.7: HASH context swap registers introduction.</description>
                <bitOffset>0</bitOffset>
                <bitWidth>32</bitWidth>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>HASH_HR0</name>
            <displayName>HASH_HR0</displayName>
            <description>HASH digest register 0</description>
            <addressOffset>0x310</addressOffset>
            <size>0x20</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>H0</name>
                <description>Hash data x
Refer to Section 40.7.4: HASH digest registers introduction.</description>
                <bitOffset>0</bitOffset>
                <bitWidth>32</bitWidth>
                <access>read-only</access>
              </field>
            </fields>
          </register>
          <register>
            <name>HASH_HR1</name>
            <displayName>HASH_HR1</displayName>
            <description>HASH digest register 1</description>
            <addressOffset>0x314</addressOffset>
            <size>0x20</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>H1</name>
                <description>Hash data x
Refer to Section 40.7.4: HASH digest registers introduction.</description>
                <bitOffset>0</bitOffset>
                <bitWidth>32</bitWidth>
                <access>read-only</access>
              </field>
            </fields>
          </register>
          <register>
            <name>HASH_HR2</name>
            <displayName>HASH_HR2</displayName>
            <description>HASH digest register 2</description>
            <addressOffset>0x318</addressOffset>
            <size>0x20</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>H2</name>
                <description>Hash data x
Refer to Section 40.7.4: HASH digest registers introduction.</description>
                <bitOffset>0</bitOffset>
                <bitWidth>32</bitWidth>
                <access>read-only</access>
              </field>
            </fields>
          </register>
          <register>
            <name>HASH_HR3</name>
            <displayName>HASH_HR3</displayName>
            <description>HASH digest register 3</description>
            <addressOffset>0x31C</addressOffset>
            <size>0x20</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>H3</name>
                <description>Hash data x
Refer to Section 40.7.4: HASH digest registers introduction.</description>
                <bitOffset>0</bitOffset>
                <bitWidth>32</bitWidth>
                <access>read-only</access>
              </field>
            </fields>
          </register>
          <register>
            <name>HASH_HR4</name>
            <displayName>HASH_HR4</displayName>
            <description>HASH digest register 4</description>
            <addressOffset>0x320</addressOffset>
            <size>0x20</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>H4</name>
                <description>Hash data x
Refer to Section 40.7.4: HASH digest registers introduction.</description>
                <bitOffset>0</bitOffset>
                <bitWidth>32</bitWidth>
                <access>read-only</access>
              </field>
            </fields>
          </register>
          <register>
            <name>HASH_HR5</name>
            <displayName>HASH_HR5</displayName>
            <description>HASH supplementary digest register 5</description>
            <addressOffset>0x324</addressOffset>
            <size>0x20</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>H5</name>
                <description>Hash data x
Refer to Section 40.7.4: HASH digest registers introduction.</description>
                <bitOffset>0</bitOffset>
                <bitWidth>32</bitWidth>
                <access>read-only</access>
              </field>
            </fields>
          </register>
          <register>
            <name>HASH_HR6</name>
            <displayName>HASH_HR6</displayName>
            <description>HASH supplementary digest register 6</description>
            <addressOffset>0x328</addressOffset>
            <size>0x20</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>H6</name>
                <description>Hash data x
Refer to Section 40.7.4: HASH digest registers introduction.</description>
                <bitOffset>0</bitOffset>
                <bitWidth>32</bitWidth>
                <access>read-only</access>
              </field>
            </fields>
          </register>
          <register>
            <name>HASH_HR7</name>
            <displayName>HASH_HR7</displayName>
            <description>HASH supplementary digest register 7</description>
            <addressOffset>0x32C</addressOffset>
            <size>0x20</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>H7</name>
                <description>Hash data x
Refer to Section 40.7.4: HASH digest registers introduction.</description>
                <bitOffset>0</bitOffset>
                <bitWidth>32</bitWidth>
                <access>read-only</access>
              </field>
            </fields>
          </register>
        </registers>
    </peripheral>
	<peripheral derivedFrom="HASH">
        <name>SEC_HASH</name>
        <baseAddress>0x520C0400</baseAddress>
    </peripheral>
	<peripheral>
        <name>HSEM</name>
        <description>Hardware semaphore</description>
		<groupName>HSEM</groupName>
        <baseAddress>0x420C1C00</baseAddress>
        <addressBlock>
          <offset>0x0</offset>
          <size>0x400</size>
          <usage>registers</usage>
        </addressBlock>
        <interrupt>
          <name>HSEM</name>
          <description>HSEM non-secure interrupt</description>
          <value>68</value>
        </interrupt>
		<interrupt>
          <name>HSEM_S</name>
          <description>HSEM secure interrupt</description>
          <value>69</value>
        </interrupt>
        <registers>
          <register>
            <name>HSEM_R0</name>
            <displayName>HSEM_R0</displayName>
            <description>HSEM register semaphore 0</description>
            <addressOffset>0x420C1C00</addressOffset>
            <size>0x20</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>PROCID</name>
                <description>Semaphore PROCID
Written by software
-When the semaphore is free and the LOCK is written to 1, and the LOCKID matches the AHB bus master ID, SEC and PRIV matches the AHB bus master definition, PROCID is set to the written data.
- When the semaphore is unlocked, LOCK written to 0 and AHB bus master ID matched LOCKID, SEC and PRIV matches the AHB bus master protection, the PROCID is cleared to 0.
- When the semaphore is unlocked, LOCK bit written to 0 and AHB bus master ID does not match LOCKID and/or SEC or PRIV do not match the AHB bus master definition, the PROCID is not affected.
- Write when LOCK bit is already 1 (semaphore locked), the PROCID is not affected.
- An authorized read returns the stored PROCID value.</description>
                <bitOffset>0</bitOffset>
                <bitWidth>8</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>LOCKID</name>
                <description>Semaphore LOCKID
Written by software
- When the semaphore is free and the LOCK bit is at the same time written to 1 and the LOCKID matches the AHB bus master ID, SEC and PRIV matches the AHB bus master protection.
- When the semaphore is unlocked (LOCK written to 0 and AHB bus master ID matched LOCKID, SEC and PRIV matches the AHB bus master protection, the LOCKID is cleared to 0.
- When the semaphore is unlocked (LOCK bit written to 0 or AHB bus master ID does not match LOCKID and/or SEC or PRIV do not match AHB bus master protection, the LOCKID is not affected.
- Write when LOCK bit is already 1 (semaphore locked), the LOCKID is not affected.
- An authorized read returns the stored LOCKID value.</description>
                <bitOffset>8</bitOffset>
                <bitWidth>4</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>SEC</name>
                <description>Semaphore secure
Written by software
- When the semaphore is free and the LOCK bit is at the same time written to 1, and the LOCKID matches the AHB bus master ID, SEC and PRIV matches the AHB bus master definition.
- When the semaphore is unlocked (LOCK written to 0 and AHB bus master ID matched LOCKID, SEC and PRIV matches the AHB bus master definition, the SEC is cleared to 0.
- When the semaphore is unlocked (LOCK bit written to 0 and AHB bus master ID  does not match LOCKID and/or SEC or PRIV do not match AHB bus master definition, the SEC is not affected.
- Write when LOCK bit is already 1 (semaphore locked), the SEC is not affected.
- An authorized read returns the stored SEC value.</description>
                <bitOffset>12</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Semaphore free or locked by non-secure compartment.</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Semaphore locked by secure compartment.</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>PRIV</name>
                <description>Semaphore privilege
Written by software
- When the semaphore is free and the LOCK bit is at the same time written to 1, and the LOCKID matches the AHB bus master ID, SEC and PRIV matches the AHB bus master definition.
- When the semaphore is unlocked (LOCK written to 0 and AHB bus master ID matched LOCKID, SEC and PRIV matches the AHB bus master definition, the PRIV is cleared to 0.
- When the semaphore is unlocked (LOCK bit written to 0 and AHB bus master ID  does not match LOCKID and/or SEC or PRIV do not match AHB bus master definition, the PRIV is not affected.
- Write when LOCK bit is already 1 (semaphore locked), the PRIV is not affected.
- An authorized read returns the stored PRIV value.</description>
                <bitOffset>13</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Semaphore free or locked by unprivileged compartment.</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Semaphore locked by privilege compartment.</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>LOCK</name>
                <description>Lock indication
This bit can be written and read by software.</description>
                <bitOffset>31</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>On write free semaphore (only when LOCKID and PROCID match), on read semaphore is free.</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>On write try to lock semaphore, on read semaphore is locked.</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
            </fields>
          </register>
          <register>
            <name>HSEM_R1</name>
            <displayName>HSEM_R1</displayName>
            <description>HSEM register semaphore 1</description>
            <addressOffset>0x4</addressOffset>
            <size>0x20</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>PROCID</name>
                <description>Semaphore PROCID
Written by software
-When the semaphore is free and the LOCK is written to 1, and the LOCKID matches the AHB bus master ID, SEC and PRIV matches the AHB bus master definition, PROCID is set to the written data.
- When the semaphore is unlocked, LOCK written to 0 and AHB bus master ID matched LOCKID, SEC and PRIV matches the AHB bus master protection, the PROCID is cleared to 0.
- When the semaphore is unlocked, LOCK bit written to 0 and AHB bus master ID does not match LOCKID and/or SEC or PRIV do not match the AHB bus master definition, the PROCID is not affected.
- Write when LOCK bit is already 1 (semaphore locked), the PROCID is not affected.
- An authorized read returns the stored PROCID value.</description>
                <bitOffset>0</bitOffset>
                <bitWidth>8</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>LOCKID</name>
                <description>Semaphore LOCKID
Written by software
- When the semaphore is free and the LOCK bit is at the same time written to 1 and the LOCKID matches the AHB bus master ID, SEC and PRIV matches the AHB bus master protection.
- When the semaphore is unlocked (LOCK written to 0 and AHB bus master ID matched LOCKID, SEC and PRIV matches the AHB bus master protection, the LOCKID is cleared to 0.
- When the semaphore is unlocked (LOCK bit written to 0 or AHB bus master ID does not match LOCKID and/or SEC or PRIV do not match AHB bus master protection, the LOCKID is not affected.
- Write when LOCK bit is already 1 (semaphore locked), the LOCKID is not affected.
- An authorized read returns the stored LOCKID value.</description>
                <bitOffset>8</bitOffset>
                <bitWidth>4</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>SEC</name>
                <description>Semaphore secure
Written by software
- When the semaphore is free and the LOCK bit is at the same time written to 1, and the LOCKID matches the AHB bus master ID, SEC and PRIV matches the AHB bus master definition.
- When the semaphore is unlocked (LOCK written to 0 and AHB bus master ID matched LOCKID, SEC and PRIV matches the AHB bus master definition, the SEC is cleared to 0.
- When the semaphore is unlocked (LOCK bit written to 0 and AHB bus master ID  does not match LOCKID and/or SEC or PRIV do not match AHB bus master definition, the SEC is not affected.
- Write when LOCK bit is already 1 (semaphore locked), the SEC is not affected.
- An authorized read returns the stored SEC value.</description>
                <bitOffset>12</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Semaphore free or locked by non-secure compartment.</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Semaphore locked by secure compartment.</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>PRIV</name>
                <description>Semaphore privilege
Written by software
- When the semaphore is free and the LOCK bit is at the same time written to 1, and the LOCKID matches the AHB bus master ID, SEC and PRIV matches the AHB bus master definition.
- When the semaphore is unlocked (LOCK written to 0 and AHB bus master ID matched LOCKID, SEC and PRIV matches the AHB bus master definition, the PRIV is cleared to 0.
- When the semaphore is unlocked (LOCK bit written to 0 and AHB bus master ID  does not match LOCKID and/or SEC or PRIV do not match AHB bus master definition, the PRIV is not affected.
- Write when LOCK bit is already 1 (semaphore locked), the PRIV is not affected.
- An authorized read returns the stored PRIV value.</description>
                <bitOffset>13</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Semaphore free or locked by unprivileged compartment.</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Semaphore locked by privilege compartment.</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>LOCK</name>
                <description>Lock indication
This bit can be written and read by software.</description>
                <bitOffset>31</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>On write free semaphore (only when LOCKID and PROCID match), on read semaphore is free.</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>On write try to lock semaphore, on read semaphore is locked.</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
            </fields>
          </register>
          <register>
            <name>HSEM_R2</name>
            <displayName>HSEM_R2</displayName>
            <description>HSEM register semaphore 2</description>
            <addressOffset>0x8</addressOffset>
            <size>0x20</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>PROCID</name>
                <description>Semaphore PROCID
Written by software
-When the semaphore is free and the LOCK is written to 1, and the LOCKID matches the AHB bus master ID, SEC and PRIV matches the AHB bus master definition, PROCID is set to the written data.
- When the semaphore is unlocked, LOCK written to 0 and AHB bus master ID matched LOCKID, SEC and PRIV matches the AHB bus master protection, the PROCID is cleared to 0.
- When the semaphore is unlocked, LOCK bit written to 0 and AHB bus master ID does not match LOCKID and/or SEC or PRIV do not match the AHB bus master definition, the PROCID is not affected.
- Write when LOCK bit is already 1 (semaphore locked), the PROCID is not affected.
- An authorized read returns the stored PROCID value.</description>
                <bitOffset>0</bitOffset>
                <bitWidth>8</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>LOCKID</name>
                <description>Semaphore LOCKID
Written by software
- When the semaphore is free and the LOCK bit is at the same time written to 1 and the LOCKID matches the AHB bus master ID, SEC and PRIV matches the AHB bus master protection.
- When the semaphore is unlocked (LOCK written to 0 and AHB bus master ID matched LOCKID, SEC and PRIV matches the AHB bus master protection, the LOCKID is cleared to 0.
- When the semaphore is unlocked (LOCK bit written to 0 or AHB bus master ID does not match LOCKID and/or SEC or PRIV do not match AHB bus master protection, the LOCKID is not affected.
- Write when LOCK bit is already 1 (semaphore locked), the LOCKID is not affected.
- An authorized read returns the stored LOCKID value.</description>
                <bitOffset>8</bitOffset>
                <bitWidth>4</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>SEC</name>
                <description>Semaphore secure
Written by software
- When the semaphore is free and the LOCK bit is at the same time written to 1, and the LOCKID matches the AHB bus master ID, SEC and PRIV matches the AHB bus master definition.
- When the semaphore is unlocked (LOCK written to 0 and AHB bus master ID matched LOCKID, SEC and PRIV matches the AHB bus master definition, the SEC is cleared to 0.
- When the semaphore is unlocked (LOCK bit written to 0 and AHB bus master ID  does not match LOCKID and/or SEC or PRIV do not match AHB bus master definition, the SEC is not affected.
- Write when LOCK bit is already 1 (semaphore locked), the SEC is not affected.
- An authorized read returns the stored SEC value.</description>
                <bitOffset>12</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Semaphore free or locked by non-secure compartment.</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Semaphore locked by secure compartment.</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>PRIV</name>
                <description>Semaphore privilege
Written by software
- When the semaphore is free and the LOCK bit is at the same time written to 1, and the LOCKID matches the AHB bus master ID, SEC and PRIV matches the AHB bus master definition.
- When the semaphore is unlocked (LOCK written to 0 and AHB bus master ID matched LOCKID, SEC and PRIV matches the AHB bus master definition, the PRIV is cleared to 0.
- When the semaphore is unlocked (LOCK bit written to 0 and AHB bus master ID  does not match LOCKID and/or SEC or PRIV do not match AHB bus master definition, the PRIV is not affected.
- Write when LOCK bit is already 1 (semaphore locked), the PRIV is not affected.
- An authorized read returns the stored PRIV value.</description>
                <bitOffset>13</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Semaphore free or locked by unprivileged compartment.</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Semaphore locked by privilege compartment.</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>LOCK</name>
                <description>Lock indication
This bit can be written and read by software.</description>
                <bitOffset>31</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>On write free semaphore (only when LOCKID and PROCID match), on read semaphore is free.</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>On write try to lock semaphore, on read semaphore is locked.</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
            </fields>
          </register>
          <register>
            <name>HSEM_R3</name>
            <displayName>HSEM_R3</displayName>
            <description>HSEM register semaphore 3</description>
            <addressOffset>0xC</addressOffset>
            <size>0x20</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>PROCID</name>
                <description>Semaphore PROCID
Written by software
-When the semaphore is free and the LOCK is written to 1, and the LOCKID matches the AHB bus master ID, SEC and PRIV matches the AHB bus master definition, PROCID is set to the written data.
- When the semaphore is unlocked, LOCK written to 0 and AHB bus master ID matched LOCKID, SEC and PRIV matches the AHB bus master protection, the PROCID is cleared to 0.
- When the semaphore is unlocked, LOCK bit written to 0 and AHB bus master ID does not match LOCKID and/or SEC or PRIV do not match the AHB bus master definition, the PROCID is not affected.
- Write when LOCK bit is already 1 (semaphore locked), the PROCID is not affected.
- An authorized read returns the stored PROCID value.</description>
                <bitOffset>0</bitOffset>
                <bitWidth>8</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>LOCKID</name>
                <description>Semaphore LOCKID
Written by software
- When the semaphore is free and the LOCK bit is at the same time written to 1 and the LOCKID matches the AHB bus master ID, SEC and PRIV matches the AHB bus master protection.
- When the semaphore is unlocked (LOCK written to 0 and AHB bus master ID matched LOCKID, SEC and PRIV matches the AHB bus master protection, the LOCKID is cleared to 0.
- When the semaphore is unlocked (LOCK bit written to 0 or AHB bus master ID does not match LOCKID and/or SEC or PRIV do not match AHB bus master protection, the LOCKID is not affected.
- Write when LOCK bit is already 1 (semaphore locked), the LOCKID is not affected.
- An authorized read returns the stored LOCKID value.</description>
                <bitOffset>8</bitOffset>
                <bitWidth>4</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>SEC</name>
                <description>Semaphore secure
Written by software
- When the semaphore is free and the LOCK bit is at the same time written to 1, and the LOCKID matches the AHB bus master ID, SEC and PRIV matches the AHB bus master definition.
- When the semaphore is unlocked (LOCK written to 0 and AHB bus master ID matched LOCKID, SEC and PRIV matches the AHB bus master definition, the SEC is cleared to 0.
- When the semaphore is unlocked (LOCK bit written to 0 and AHB bus master ID  does not match LOCKID and/or SEC or PRIV do not match AHB bus master definition, the SEC is not affected.
- Write when LOCK bit is already 1 (semaphore locked), the SEC is not affected.
- An authorized read returns the stored SEC value.</description>
                <bitOffset>12</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Semaphore free or locked by non-secure compartment.</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Semaphore locked by secure compartment.</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>PRIV</name>
                <description>Semaphore privilege
Written by software
- When the semaphore is free and the LOCK bit is at the same time written to 1, and the LOCKID matches the AHB bus master ID, SEC and PRIV matches the AHB bus master definition.
- When the semaphore is unlocked (LOCK written to 0 and AHB bus master ID matched LOCKID, SEC and PRIV matches the AHB bus master definition, the PRIV is cleared to 0.
- When the semaphore is unlocked (LOCK bit written to 0 and AHB bus master ID  does not match LOCKID and/or SEC or PRIV do not match AHB bus master definition, the PRIV is not affected.
- Write when LOCK bit is already 1 (semaphore locked), the PRIV is not affected.
- An authorized read returns the stored PRIV value.</description>
                <bitOffset>13</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Semaphore free or locked by unprivileged compartment.</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Semaphore locked by privilege compartment.</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>LOCK</name>
                <description>Lock indication
This bit can be written and read by software.</description>
                <bitOffset>31</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>On write free semaphore (only when LOCKID and PROCID match), on read semaphore is free.</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>On write try to lock semaphore, on read semaphore is locked.</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
            </fields>
          </register>
          <register>
            <name>HSEM_R4</name>
            <displayName>HSEM_R4</displayName>
            <description>HSEM register semaphore 4</description>
            <addressOffset>0x10</addressOffset>
            <size>0x20</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>PROCID</name>
                <description>Semaphore PROCID
Written by software
-When the semaphore is free and the LOCK is written to 1, and the LOCKID matches the AHB bus master ID, SEC and PRIV matches the AHB bus master definition, PROCID is set to the written data.
- When the semaphore is unlocked, LOCK written to 0 and AHB bus master ID matched LOCKID, SEC and PRIV matches the AHB bus master protection, the PROCID is cleared to 0.
- When the semaphore is unlocked, LOCK bit written to 0 and AHB bus master ID does not match LOCKID and/or SEC or PRIV do not match the AHB bus master definition, the PROCID is not affected.
- Write when LOCK bit is already 1 (semaphore locked), the PROCID is not affected.
- An authorized read returns the stored PROCID value.</description>
                <bitOffset>0</bitOffset>
                <bitWidth>8</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>LOCKID</name>
                <description>Semaphore LOCKID
Written by software
- When the semaphore is free and the LOCK bit is at the same time written to 1 and the LOCKID matches the AHB bus master ID, SEC and PRIV matches the AHB bus master protection.
- When the semaphore is unlocked (LOCK written to 0 and AHB bus master ID matched LOCKID, SEC and PRIV matches the AHB bus master protection, the LOCKID is cleared to 0.
- When the semaphore is unlocked (LOCK bit written to 0 or AHB bus master ID does not match LOCKID and/or SEC or PRIV do not match AHB bus master protection, the LOCKID is not affected.
- Write when LOCK bit is already 1 (semaphore locked), the LOCKID is not affected.
- An authorized read returns the stored LOCKID value.</description>
                <bitOffset>8</bitOffset>
                <bitWidth>4</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>SEC</name>
                <description>Semaphore secure
Written by software
- When the semaphore is free and the LOCK bit is at the same time written to 1, and the LOCKID matches the AHB bus master ID, SEC and PRIV matches the AHB bus master definition.
- When the semaphore is unlocked (LOCK written to 0 and AHB bus master ID matched LOCKID, SEC and PRIV matches the AHB bus master definition, the SEC is cleared to 0.
- When the semaphore is unlocked (LOCK bit written to 0 and AHB bus master ID  does not match LOCKID and/or SEC or PRIV do not match AHB bus master definition, the SEC is not affected.
- Write when LOCK bit is already 1 (semaphore locked), the SEC is not affected.
- An authorized read returns the stored SEC value.</description>
                <bitOffset>12</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Semaphore free or locked by non-secure compartment.</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Semaphore locked by secure compartment.</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>PRIV</name>
                <description>Semaphore privilege
Written by software
- When the semaphore is free and the LOCK bit is at the same time written to 1, and the LOCKID matches the AHB bus master ID, SEC and PRIV matches the AHB bus master definition.
- When the semaphore is unlocked (LOCK written to 0 and AHB bus master ID matched LOCKID, SEC and PRIV matches the AHB bus master definition, the PRIV is cleared to 0.
- When the semaphore is unlocked (LOCK bit written to 0 and AHB bus master ID  does not match LOCKID and/or SEC or PRIV do not match AHB bus master definition, the PRIV is not affected.
- Write when LOCK bit is already 1 (semaphore locked), the PRIV is not affected.
- An authorized read returns the stored PRIV value.</description>
                <bitOffset>13</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Semaphore free or locked by unprivileged compartment.</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Semaphore locked by privilege compartment.</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>LOCK</name>
                <description>Lock indication
This bit can be written and read by software.</description>
                <bitOffset>31</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>On write free semaphore (only when LOCKID and PROCID match), on read semaphore is free.</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>On write try to lock semaphore, on read semaphore is locked.</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
            </fields>
          </register>
          <register>
            <name>HSEM_R5</name>
            <displayName>HSEM_R5</displayName>
            <description>HSEM register semaphore 5</description>
            <addressOffset>0x14</addressOffset>
            <size>0x20</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>PROCID</name>
                <description>Semaphore PROCID
Written by software
-When the semaphore is free and the LOCK is written to 1, and the LOCKID matches the AHB bus master ID, SEC and PRIV matches the AHB bus master definition, PROCID is set to the written data.
- When the semaphore is unlocked, LOCK written to 0 and AHB bus master ID matched LOCKID, SEC and PRIV matches the AHB bus master protection, the PROCID is cleared to 0.
- When the semaphore is unlocked, LOCK bit written to 0 and AHB bus master ID does not match LOCKID and/or SEC or PRIV do not match the AHB bus master definition, the PROCID is not affected.
- Write when LOCK bit is already 1 (semaphore locked), the PROCID is not affected.
- An authorized read returns the stored PROCID value.</description>
                <bitOffset>0</bitOffset>
                <bitWidth>8</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>LOCKID</name>
                <description>Semaphore LOCKID
Written by software
- When the semaphore is free and the LOCK bit is at the same time written to 1 and the LOCKID matches the AHB bus master ID, SEC and PRIV matches the AHB bus master protection.
- When the semaphore is unlocked (LOCK written to 0 and AHB bus master ID matched LOCKID, SEC and PRIV matches the AHB bus master protection, the LOCKID is cleared to 0.
- When the semaphore is unlocked (LOCK bit written to 0 or AHB bus master ID does not match LOCKID and/or SEC or PRIV do not match AHB bus master protection, the LOCKID is not affected.
- Write when LOCK bit is already 1 (semaphore locked), the LOCKID is not affected.
- An authorized read returns the stored LOCKID value.</description>
                <bitOffset>8</bitOffset>
                <bitWidth>4</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>SEC</name>
                <description>Semaphore secure
Written by software
- When the semaphore is free and the LOCK bit is at the same time written to 1, and the LOCKID matches the AHB bus master ID, SEC and PRIV matches the AHB bus master definition.
- When the semaphore is unlocked (LOCK written to 0 and AHB bus master ID matched LOCKID, SEC and PRIV matches the AHB bus master definition, the SEC is cleared to 0.
- When the semaphore is unlocked (LOCK bit written to 0 and AHB bus master ID  does not match LOCKID and/or SEC or PRIV do not match AHB bus master definition, the SEC is not affected.
- Write when LOCK bit is already 1 (semaphore locked), the SEC is not affected.
- An authorized read returns the stored SEC value.</description>
                <bitOffset>12</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Semaphore free or locked by non-secure compartment.</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Semaphore locked by secure compartment.</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>PRIV</name>
                <description>Semaphore privilege
Written by software
- When the semaphore is free and the LOCK bit is at the same time written to 1, and the LOCKID matches the AHB bus master ID, SEC and PRIV matches the AHB bus master definition.
- When the semaphore is unlocked (LOCK written to 0 and AHB bus master ID matched LOCKID, SEC and PRIV matches the AHB bus master definition, the PRIV is cleared to 0.
- When the semaphore is unlocked (LOCK bit written to 0 and AHB bus master ID  does not match LOCKID and/or SEC or PRIV do not match AHB bus master definition, the PRIV is not affected.
- Write when LOCK bit is already 1 (semaphore locked), the PRIV is not affected.
- An authorized read returns the stored PRIV value.</description>
                <bitOffset>13</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Semaphore free or locked by unprivileged compartment.</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Semaphore locked by privilege compartment.</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>LOCK</name>
                <description>Lock indication
This bit can be written and read by software.</description>
                <bitOffset>31</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>On write free semaphore (only when LOCKID and PROCID match), on read semaphore is free.</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>On write try to lock semaphore, on read semaphore is locked.</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
            </fields>
          </register>
          <register>
            <name>HSEM_R6</name>
            <displayName>HSEM_R6</displayName>
            <description>HSEM register semaphore 6</description>
            <addressOffset>0x18</addressOffset>
            <size>0x20</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>PROCID</name>
                <description>Semaphore PROCID
Written by software
-When the semaphore is free and the LOCK is written to 1, and the LOCKID matches the AHB bus master ID, SEC and PRIV matches the AHB bus master definition, PROCID is set to the written data.
- When the semaphore is unlocked, LOCK written to 0 and AHB bus master ID matched LOCKID, SEC and PRIV matches the AHB bus master protection, the PROCID is cleared to 0.
- When the semaphore is unlocked, LOCK bit written to 0 and AHB bus master ID does not match LOCKID and/or SEC or PRIV do not match the AHB bus master definition, the PROCID is not affected.
- Write when LOCK bit is already 1 (semaphore locked), the PROCID is not affected.
- An authorized read returns the stored PROCID value.</description>
                <bitOffset>0</bitOffset>
                <bitWidth>8</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>LOCKID</name>
                <description>Semaphore LOCKID
Written by software
- When the semaphore is free and the LOCK bit is at the same time written to 1 and the LOCKID matches the AHB bus master ID, SEC and PRIV matches the AHB bus master protection.
- When the semaphore is unlocked (LOCK written to 0 and AHB bus master ID matched LOCKID, SEC and PRIV matches the AHB bus master protection, the LOCKID is cleared to 0.
- When the semaphore is unlocked (LOCK bit written to 0 or AHB bus master ID does not match LOCKID and/or SEC or PRIV do not match AHB bus master protection, the LOCKID is not affected.
- Write when LOCK bit is already 1 (semaphore locked), the LOCKID is not affected.
- An authorized read returns the stored LOCKID value.</description>
                <bitOffset>8</bitOffset>
                <bitWidth>4</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>SEC</name>
                <description>Semaphore secure
Written by software
- When the semaphore is free and the LOCK bit is at the same time written to 1, and the LOCKID matches the AHB bus master ID, SEC and PRIV matches the AHB bus master definition.
- When the semaphore is unlocked (LOCK written to 0 and AHB bus master ID matched LOCKID, SEC and PRIV matches the AHB bus master definition, the SEC is cleared to 0.
- When the semaphore is unlocked (LOCK bit written to 0 and AHB bus master ID  does not match LOCKID and/or SEC or PRIV do not match AHB bus master definition, the SEC is not affected.
- Write when LOCK bit is already 1 (semaphore locked), the SEC is not affected.
- An authorized read returns the stored SEC value.</description>
                <bitOffset>12</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Semaphore free or locked by non-secure compartment.</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Semaphore locked by secure compartment.</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>PRIV</name>
                <description>Semaphore privilege
Written by software
- When the semaphore is free and the LOCK bit is at the same time written to 1, and the LOCKID matches the AHB bus master ID, SEC and PRIV matches the AHB bus master definition.
- When the semaphore is unlocked (LOCK written to 0 and AHB bus master ID matched LOCKID, SEC and PRIV matches the AHB bus master definition, the PRIV is cleared to 0.
- When the semaphore is unlocked (LOCK bit written to 0 and AHB bus master ID  does not match LOCKID and/or SEC or PRIV do not match AHB bus master definition, the PRIV is not affected.
- Write when LOCK bit is already 1 (semaphore locked), the PRIV is not affected.
- An authorized read returns the stored PRIV value.</description>
                <bitOffset>13</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Semaphore free or locked by unprivileged compartment.</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Semaphore locked by privilege compartment.</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>LOCK</name>
                <description>Lock indication
This bit can be written and read by software.</description>
                <bitOffset>31</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>On write free semaphore (only when LOCKID and PROCID match), on read semaphore is free.</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>On write try to lock semaphore, on read semaphore is locked.</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
            </fields>
          </register>
          <register>
            <name>HSEM_R7</name>
            <displayName>HSEM_R7</displayName>
            <description>HSEM register semaphore 7</description>
            <addressOffset>0x1C</addressOffset>
            <size>0x20</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>PROCID</name>
                <description>Semaphore PROCID
Written by software
-When the semaphore is free and the LOCK is written to 1, and the LOCKID matches the AHB bus master ID, SEC and PRIV matches the AHB bus master definition, PROCID is set to the written data.
- When the semaphore is unlocked, LOCK written to 0 and AHB bus master ID matched LOCKID, SEC and PRIV matches the AHB bus master protection, the PROCID is cleared to 0.
- When the semaphore is unlocked, LOCK bit written to 0 and AHB bus master ID does not match LOCKID and/or SEC or PRIV do not match the AHB bus master definition, the PROCID is not affected.
- Write when LOCK bit is already 1 (semaphore locked), the PROCID is not affected.
- An authorized read returns the stored PROCID value.</description>
                <bitOffset>0</bitOffset>
                <bitWidth>8</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>LOCKID</name>
                <description>Semaphore LOCKID
Written by software
- When the semaphore is free and the LOCK bit is at the same time written to 1 and the LOCKID matches the AHB bus master ID, SEC and PRIV matches the AHB bus master protection.
- When the semaphore is unlocked (LOCK written to 0 and AHB bus master ID matched LOCKID, SEC and PRIV matches the AHB bus master protection, the LOCKID is cleared to 0.
- When the semaphore is unlocked (LOCK bit written to 0 or AHB bus master ID does not match LOCKID and/or SEC or PRIV do not match AHB bus master protection, the LOCKID is not affected.
- Write when LOCK bit is already 1 (semaphore locked), the LOCKID is not affected.
- An authorized read returns the stored LOCKID value.</description>
                <bitOffset>8</bitOffset>
                <bitWidth>4</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>SEC</name>
                <description>Semaphore secure
Written by software
- When the semaphore is free and the LOCK bit is at the same time written to 1, and the LOCKID matches the AHB bus master ID, SEC and PRIV matches the AHB bus master definition.
- When the semaphore is unlocked (LOCK written to 0 and AHB bus master ID matched LOCKID, SEC and PRIV matches the AHB bus master definition, the SEC is cleared to 0.
- When the semaphore is unlocked (LOCK bit written to 0 and AHB bus master ID  does not match LOCKID and/or SEC or PRIV do not match AHB bus master definition, the SEC is not affected.
- Write when LOCK bit is already 1 (semaphore locked), the SEC is not affected.
- An authorized read returns the stored SEC value.</description>
                <bitOffset>12</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Semaphore free or locked by non-secure compartment.</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Semaphore locked by secure compartment.</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>PRIV</name>
                <description>Semaphore privilege
Written by software
- When the semaphore is free and the LOCK bit is at the same time written to 1, and the LOCKID matches the AHB bus master ID, SEC and PRIV matches the AHB bus master definition.
- When the semaphore is unlocked (LOCK written to 0 and AHB bus master ID matched LOCKID, SEC and PRIV matches the AHB bus master definition, the PRIV is cleared to 0.
- When the semaphore is unlocked (LOCK bit written to 0 and AHB bus master ID  does not match LOCKID and/or SEC or PRIV do not match AHB bus master definition, the PRIV is not affected.
- Write when LOCK bit is already 1 (semaphore locked), the PRIV is not affected.
- An authorized read returns the stored PRIV value.</description>
                <bitOffset>13</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Semaphore free or locked by unprivileged compartment.</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Semaphore locked by privilege compartment.</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>LOCK</name>
                <description>Lock indication
This bit can be written and read by software.</description>
                <bitOffset>31</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>On write free semaphore (only when LOCKID and PROCID match), on read semaphore is free.</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>On write try to lock semaphore, on read semaphore is locked.</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
            </fields>
          </register>
          <register>
            <name>HSEM_R8</name>
            <displayName>HSEM_R8</displayName>
            <description>HSEM register semaphore 8</description>
            <addressOffset>0x20</addressOffset>
            <size>0x20</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>PROCID</name>
                <description>Semaphore PROCID
Written by software
-When the semaphore is free and the LOCK is written to 1, and the LOCKID matches the AHB bus master ID, SEC and PRIV matches the AHB bus master definition, PROCID is set to the written data.
- When the semaphore is unlocked, LOCK written to 0 and AHB bus master ID matched LOCKID, SEC and PRIV matches the AHB bus master protection, the PROCID is cleared to 0.
- When the semaphore is unlocked, LOCK bit written to 0 and AHB bus master ID does not match LOCKID and/or SEC or PRIV do not match the AHB bus master definition, the PROCID is not affected.
- Write when LOCK bit is already 1 (semaphore locked), the PROCID is not affected.
- An authorized read returns the stored PROCID value.</description>
                <bitOffset>0</bitOffset>
                <bitWidth>8</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>LOCKID</name>
                <description>Semaphore LOCKID
Written by software
- When the semaphore is free and the LOCK bit is at the same time written to 1 and the LOCKID matches the AHB bus master ID, SEC and PRIV matches the AHB bus master protection.
- When the semaphore is unlocked (LOCK written to 0 and AHB bus master ID matched LOCKID, SEC and PRIV matches the AHB bus master protection, the LOCKID is cleared to 0.
- When the semaphore is unlocked (LOCK bit written to 0 or AHB bus master ID does not match LOCKID and/or SEC or PRIV do not match AHB bus master protection, the LOCKID is not affected.
- Write when LOCK bit is already 1 (semaphore locked), the LOCKID is not affected.
- An authorized read returns the stored LOCKID value.</description>
                <bitOffset>8</bitOffset>
                <bitWidth>4</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>SEC</name>
                <description>Semaphore secure
Written by software
- When the semaphore is free and the LOCK bit is at the same time written to 1, and the LOCKID matches the AHB bus master ID, SEC and PRIV matches the AHB bus master definition.
- When the semaphore is unlocked (LOCK written to 0 and AHB bus master ID matched LOCKID, SEC and PRIV matches the AHB bus master definition, the SEC is cleared to 0.
- When the semaphore is unlocked (LOCK bit written to 0 and AHB bus master ID  does not match LOCKID and/or SEC or PRIV do not match AHB bus master definition, the SEC is not affected.
- Write when LOCK bit is already 1 (semaphore locked), the SEC is not affected.
- An authorized read returns the stored SEC value.</description>
                <bitOffset>12</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Semaphore free or locked by non-secure compartment.</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Semaphore locked by secure compartment.</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>PRIV</name>
                <description>Semaphore privilege
Written by software
- When the semaphore is free and the LOCK bit is at the same time written to 1, and the LOCKID matches the AHB bus master ID, SEC and PRIV matches the AHB bus master definition.
- When the semaphore is unlocked (LOCK written to 0 and AHB bus master ID matched LOCKID, SEC and PRIV matches the AHB bus master definition, the PRIV is cleared to 0.
- When the semaphore is unlocked (LOCK bit written to 0 and AHB bus master ID  does not match LOCKID and/or SEC or PRIV do not match AHB bus master definition, the PRIV is not affected.
- Write when LOCK bit is already 1 (semaphore locked), the PRIV is not affected.
- An authorized read returns the stored PRIV value.</description>
                <bitOffset>13</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Semaphore free or locked by unprivileged compartment.</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Semaphore locked by privilege compartment.</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>LOCK</name>
                <description>Lock indication
This bit can be written and read by software.</description>
                <bitOffset>31</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>On write free semaphore (only when LOCKID and PROCID match), on read semaphore is free.</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>On write try to lock semaphore, on read semaphore is locked.</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
            </fields>
          </register>
          <register>
            <name>HSEM_R9</name>
            <displayName>HSEM_R9</displayName>
            <description>HSEM register semaphore 9</description>
            <addressOffset>0x24</addressOffset>
            <size>0x20</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>PROCID</name>
                <description>Semaphore PROCID
Written by software
-When the semaphore is free and the LOCK is written to 1, and the LOCKID matches the AHB bus master ID, SEC and PRIV matches the AHB bus master definition, PROCID is set to the written data.
- When the semaphore is unlocked, LOCK written to 0 and AHB bus master ID matched LOCKID, SEC and PRIV matches the AHB bus master protection, the PROCID is cleared to 0.
- When the semaphore is unlocked, LOCK bit written to 0 and AHB bus master ID does not match LOCKID and/or SEC or PRIV do not match the AHB bus master definition, the PROCID is not affected.
- Write when LOCK bit is already 1 (semaphore locked), the PROCID is not affected.
- An authorized read returns the stored PROCID value.</description>
                <bitOffset>0</bitOffset>
                <bitWidth>8</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>LOCKID</name>
                <description>Semaphore LOCKID
Written by software
- When the semaphore is free and the LOCK bit is at the same time written to 1 and the LOCKID matches the AHB bus master ID, SEC and PRIV matches the AHB bus master protection.
- When the semaphore is unlocked (LOCK written to 0 and AHB bus master ID matched LOCKID, SEC and PRIV matches the AHB bus master protection, the LOCKID is cleared to 0.
- When the semaphore is unlocked (LOCK bit written to 0 or AHB bus master ID does not match LOCKID and/or SEC or PRIV do not match AHB bus master protection, the LOCKID is not affected.
- Write when LOCK bit is already 1 (semaphore locked), the LOCKID is not affected.
- An authorized read returns the stored LOCKID value.</description>
                <bitOffset>8</bitOffset>
                <bitWidth>4</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>SEC</name>
                <description>Semaphore secure
Written by software
- When the semaphore is free and the LOCK bit is at the same time written to 1, and the LOCKID matches the AHB bus master ID, SEC and PRIV matches the AHB bus master definition.
- When the semaphore is unlocked (LOCK written to 0 and AHB bus master ID matched LOCKID, SEC and PRIV matches the AHB bus master definition, the SEC is cleared to 0.
- When the semaphore is unlocked (LOCK bit written to 0 and AHB bus master ID  does not match LOCKID and/or SEC or PRIV do not match AHB bus master definition, the SEC is not affected.
- Write when LOCK bit is already 1 (semaphore locked), the SEC is not affected.
- An authorized read returns the stored SEC value.</description>
                <bitOffset>12</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Semaphore free or locked by non-secure compartment.</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Semaphore locked by secure compartment.</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>PRIV</name>
                <description>Semaphore privilege
Written by software
- When the semaphore is free and the LOCK bit is at the same time written to 1, and the LOCKID matches the AHB bus master ID, SEC and PRIV matches the AHB bus master definition.
- When the semaphore is unlocked (LOCK written to 0 and AHB bus master ID matched LOCKID, SEC and PRIV matches the AHB bus master definition, the PRIV is cleared to 0.
- When the semaphore is unlocked (LOCK bit written to 0 and AHB bus master ID  does not match LOCKID and/or SEC or PRIV do not match AHB bus master definition, the PRIV is not affected.
- Write when LOCK bit is already 1 (semaphore locked), the PRIV is not affected.
- An authorized read returns the stored PRIV value.</description>
                <bitOffset>13</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Semaphore free or locked by unprivileged compartment.</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Semaphore locked by privilege compartment.</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>LOCK</name>
                <description>Lock indication
This bit can be written and read by software.</description>
                <bitOffset>31</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>On write free semaphore (only when LOCKID and PROCID match), on read semaphore is free.</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>On write try to lock semaphore, on read semaphore is locked.</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
            </fields>
          </register>
          <register>
            <name>HSEM_R10</name>
            <displayName>HSEM_R10</displayName>
            <description>HSEM register semaphore 10</description>
            <addressOffset>0x28</addressOffset>
            <size>0x20</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>PROCID</name>
                <description>Semaphore PROCID
Written by software
-When the semaphore is free and the LOCK is written to 1, and the LOCKID matches the AHB bus master ID, SEC and PRIV matches the AHB bus master definition, PROCID is set to the written data.
- When the semaphore is unlocked, LOCK written to 0 and AHB bus master ID matched LOCKID, SEC and PRIV matches the AHB bus master protection, the PROCID is cleared to 0.
- When the semaphore is unlocked, LOCK bit written to 0 and AHB bus master ID does not match LOCKID and/or SEC or PRIV do not match the AHB bus master definition, the PROCID is not affected.
- Write when LOCK bit is already 1 (semaphore locked), the PROCID is not affected.
- An authorized read returns the stored PROCID value.</description>
                <bitOffset>0</bitOffset>
                <bitWidth>8</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>LOCKID</name>
                <description>Semaphore LOCKID
Written by software
- When the semaphore is free and the LOCK bit is at the same time written to 1 and the LOCKID matches the AHB bus master ID, SEC and PRIV matches the AHB bus master protection.
- When the semaphore is unlocked (LOCK written to 0 and AHB bus master ID matched LOCKID, SEC and PRIV matches the AHB bus master protection, the LOCKID is cleared to 0.
- When the semaphore is unlocked (LOCK bit written to 0 or AHB bus master ID does not match LOCKID and/or SEC or PRIV do not match AHB bus master protection, the LOCKID is not affected.
- Write when LOCK bit is already 1 (semaphore locked), the LOCKID is not affected.
- An authorized read returns the stored LOCKID value.</description>
                <bitOffset>8</bitOffset>
                <bitWidth>4</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>SEC</name>
                <description>Semaphore secure
Written by software
- When the semaphore is free and the LOCK bit is at the same time written to 1, and the LOCKID matches the AHB bus master ID, SEC and PRIV matches the AHB bus master definition.
- When the semaphore is unlocked (LOCK written to 0 and AHB bus master ID matched LOCKID, SEC and PRIV matches the AHB bus master definition, the SEC is cleared to 0.
- When the semaphore is unlocked (LOCK bit written to 0 and AHB bus master ID  does not match LOCKID and/or SEC or PRIV do not match AHB bus master definition, the SEC is not affected.
- Write when LOCK bit is already 1 (semaphore locked), the SEC is not affected.
- An authorized read returns the stored SEC value.</description>
                <bitOffset>12</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Semaphore free or locked by non-secure compartment.</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Semaphore locked by secure compartment.</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>PRIV</name>
                <description>Semaphore privilege
Written by software
- When the semaphore is free and the LOCK bit is at the same time written to 1, and the LOCKID matches the AHB bus master ID, SEC and PRIV matches the AHB bus master definition.
- When the semaphore is unlocked (LOCK written to 0 and AHB bus master ID matched LOCKID, SEC and PRIV matches the AHB bus master definition, the PRIV is cleared to 0.
- When the semaphore is unlocked (LOCK bit written to 0 and AHB bus master ID  does not match LOCKID and/or SEC or PRIV do not match AHB bus master definition, the PRIV is not affected.
- Write when LOCK bit is already 1 (semaphore locked), the PRIV is not affected.
- An authorized read returns the stored PRIV value.</description>
                <bitOffset>13</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Semaphore free or locked by unprivileged compartment.</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Semaphore locked by privilege compartment.</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>LOCK</name>
                <description>Lock indication
This bit can be written and read by software.</description>
                <bitOffset>31</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>On write free semaphore (only when LOCKID and PROCID match), on read semaphore is free.</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>On write try to lock semaphore, on read semaphore is locked.</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
            </fields>
          </register>
          <register>
            <name>HSEM_R11</name>
            <displayName>HSEM_R11</displayName>
            <description>HSEM register semaphore 11</description>
            <addressOffset>0x2C</addressOffset>
            <size>0x20</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>PROCID</name>
                <description>Semaphore PROCID
Written by software
-When the semaphore is free and the LOCK is written to 1, and the LOCKID matches the AHB bus master ID, SEC and PRIV matches the AHB bus master definition, PROCID is set to the written data.
- When the semaphore is unlocked, LOCK written to 0 and AHB bus master ID matched LOCKID, SEC and PRIV matches the AHB bus master protection, the PROCID is cleared to 0.
- When the semaphore is unlocked, LOCK bit written to 0 and AHB bus master ID does not match LOCKID and/or SEC or PRIV do not match the AHB bus master definition, the PROCID is not affected.
- Write when LOCK bit is already 1 (semaphore locked), the PROCID is not affected.
- An authorized read returns the stored PROCID value.</description>
                <bitOffset>0</bitOffset>
                <bitWidth>8</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>LOCKID</name>
                <description>Semaphore LOCKID
Written by software
- When the semaphore is free and the LOCK bit is at the same time written to 1 and the LOCKID matches the AHB bus master ID, SEC and PRIV matches the AHB bus master protection.
- When the semaphore is unlocked (LOCK written to 0 and AHB bus master ID matched LOCKID, SEC and PRIV matches the AHB bus master protection, the LOCKID is cleared to 0.
- When the semaphore is unlocked (LOCK bit written to 0 or AHB bus master ID does not match LOCKID and/or SEC or PRIV do not match AHB bus master protection, the LOCKID is not affected.
- Write when LOCK bit is already 1 (semaphore locked), the LOCKID is not affected.
- An authorized read returns the stored LOCKID value.</description>
                <bitOffset>8</bitOffset>
                <bitWidth>4</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>SEC</name>
                <description>Semaphore secure
Written by software
- When the semaphore is free and the LOCK bit is at the same time written to 1, and the LOCKID matches the AHB bus master ID, SEC and PRIV matches the AHB bus master definition.
- When the semaphore is unlocked (LOCK written to 0 and AHB bus master ID matched LOCKID, SEC and PRIV matches the AHB bus master definition, the SEC is cleared to 0.
- When the semaphore is unlocked (LOCK bit written to 0 and AHB bus master ID  does not match LOCKID and/or SEC or PRIV do not match AHB bus master definition, the SEC is not affected.
- Write when LOCK bit is already 1 (semaphore locked), the SEC is not affected.
- An authorized read returns the stored SEC value.</description>
                <bitOffset>12</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Semaphore free or locked by non-secure compartment.</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Semaphore locked by secure compartment.</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>PRIV</name>
                <description>Semaphore privilege
Written by software
- When the semaphore is free and the LOCK bit is at the same time written to 1, and the LOCKID matches the AHB bus master ID, SEC and PRIV matches the AHB bus master definition.
- When the semaphore is unlocked (LOCK written to 0 and AHB bus master ID matched LOCKID, SEC and PRIV matches the AHB bus master definition, the PRIV is cleared to 0.
- When the semaphore is unlocked (LOCK bit written to 0 and AHB bus master ID  does not match LOCKID and/or SEC or PRIV do not match AHB bus master definition, the PRIV is not affected.
- Write when LOCK bit is already 1 (semaphore locked), the PRIV is not affected.
- An authorized read returns the stored PRIV value.</description>
                <bitOffset>13</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Semaphore free or locked by unprivileged compartment.</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Semaphore locked by privilege compartment.</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>LOCK</name>
                <description>Lock indication
This bit can be written and read by software.</description>
                <bitOffset>31</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>On write free semaphore (only when LOCKID and PROCID match), on read semaphore is free.</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>On write try to lock semaphore, on read semaphore is locked.</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
            </fields>
          </register>
          <register>
            <name>HSEM_R12</name>
            <displayName>HSEM_R12</displayName>
            <description>HSEM register semaphore 12</description>
            <addressOffset>0x30</addressOffset>
            <size>0x20</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>PROCID</name>
                <description>Semaphore PROCID
Written by software
-When the semaphore is free and the LOCK is written to 1, and the LOCKID matches the AHB bus master ID, SEC and PRIV matches the AHB bus master definition, PROCID is set to the written data.
- When the semaphore is unlocked, LOCK written to 0 and AHB bus master ID matched LOCKID, SEC and PRIV matches the AHB bus master protection, the PROCID is cleared to 0.
- When the semaphore is unlocked, LOCK bit written to 0 and AHB bus master ID does not match LOCKID and/or SEC or PRIV do not match the AHB bus master definition, the PROCID is not affected.
- Write when LOCK bit is already 1 (semaphore locked), the PROCID is not affected.
- An authorized read returns the stored PROCID value.</description>
                <bitOffset>0</bitOffset>
                <bitWidth>8</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>LOCKID</name>
                <description>Semaphore LOCKID
Written by software
- When the semaphore is free and the LOCK bit is at the same time written to 1 and the LOCKID matches the AHB bus master ID, SEC and PRIV matches the AHB bus master protection.
- When the semaphore is unlocked (LOCK written to 0 and AHB bus master ID matched LOCKID, SEC and PRIV matches the AHB bus master protection, the LOCKID is cleared to 0.
- When the semaphore is unlocked (LOCK bit written to 0 or AHB bus master ID does not match LOCKID and/or SEC or PRIV do not match AHB bus master protection, the LOCKID is not affected.
- Write when LOCK bit is already 1 (semaphore locked), the LOCKID is not affected.
- An authorized read returns the stored LOCKID value.</description>
                <bitOffset>8</bitOffset>
                <bitWidth>4</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>SEC</name>
                <description>Semaphore secure
Written by software
- When the semaphore is free and the LOCK bit is at the same time written to 1, and the LOCKID matches the AHB bus master ID, SEC and PRIV matches the AHB bus master definition.
- When the semaphore is unlocked (LOCK written to 0 and AHB bus master ID matched LOCKID, SEC and PRIV matches the AHB bus master definition, the SEC is cleared to 0.
- When the semaphore is unlocked (LOCK bit written to 0 and AHB bus master ID  does not match LOCKID and/or SEC or PRIV do not match AHB bus master definition, the SEC is not affected.
- Write when LOCK bit is already 1 (semaphore locked), the SEC is not affected.
- An authorized read returns the stored SEC value.</description>
                <bitOffset>12</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Semaphore free or locked by non-secure compartment.</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Semaphore locked by secure compartment.</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>PRIV</name>
                <description>Semaphore privilege
Written by software
- When the semaphore is free and the LOCK bit is at the same time written to 1, and the LOCKID matches the AHB bus master ID, SEC and PRIV matches the AHB bus master definition.
- When the semaphore is unlocked (LOCK written to 0 and AHB bus master ID matched LOCKID, SEC and PRIV matches the AHB bus master definition, the PRIV is cleared to 0.
- When the semaphore is unlocked (LOCK bit written to 0 and AHB bus master ID  does not match LOCKID and/or SEC or PRIV do not match AHB bus master definition, the PRIV is not affected.
- Write when LOCK bit is already 1 (semaphore locked), the PRIV is not affected.
- An authorized read returns the stored PRIV value.</description>
                <bitOffset>13</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Semaphore free or locked by unprivileged compartment.</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Semaphore locked by privilege compartment.</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>LOCK</name>
                <description>Lock indication
This bit can be written and read by software.</description>
                <bitOffset>31</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>On write free semaphore (only when LOCKID and PROCID match), on read semaphore is free.</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>On write try to lock semaphore, on read semaphore is locked.</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
            </fields>
          </register>
          <register>
            <name>HSEM_R13</name>
            <displayName>HSEM_R13</displayName>
            <description>HSEM register semaphore 13</description>
            <addressOffset>0x34</addressOffset>
            <size>0x20</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>PROCID</name>
                <description>Semaphore PROCID
Written by software
-When the semaphore is free and the LOCK is written to 1, and the LOCKID matches the AHB bus master ID, SEC and PRIV matches the AHB bus master definition, PROCID is set to the written data.
- When the semaphore is unlocked, LOCK written to 0 and AHB bus master ID matched LOCKID, SEC and PRIV matches the AHB bus master protection, the PROCID is cleared to 0.
- When the semaphore is unlocked, LOCK bit written to 0 and AHB bus master ID does not match LOCKID and/or SEC or PRIV do not match the AHB bus master definition, the PROCID is not affected.
- Write when LOCK bit is already 1 (semaphore locked), the PROCID is not affected.
- An authorized read returns the stored PROCID value.</description>
                <bitOffset>0</bitOffset>
                <bitWidth>8</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>LOCKID</name>
                <description>Semaphore LOCKID
Written by software
- When the semaphore is free and the LOCK bit is at the same time written to 1 and the LOCKID matches the AHB bus master ID, SEC and PRIV matches the AHB bus master protection.
- When the semaphore is unlocked (LOCK written to 0 and AHB bus master ID matched LOCKID, SEC and PRIV matches the AHB bus master protection, the LOCKID is cleared to 0.
- When the semaphore is unlocked (LOCK bit written to 0 or AHB bus master ID does not match LOCKID and/or SEC or PRIV do not match AHB bus master protection, the LOCKID is not affected.
- Write when LOCK bit is already 1 (semaphore locked), the LOCKID is not affected.
- An authorized read returns the stored LOCKID value.</description>
                <bitOffset>8</bitOffset>
                <bitWidth>4</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>SEC</name>
                <description>Semaphore secure
Written by software
- When the semaphore is free and the LOCK bit is at the same time written to 1, and the LOCKID matches the AHB bus master ID, SEC and PRIV matches the AHB bus master definition.
- When the semaphore is unlocked (LOCK written to 0 and AHB bus master ID matched LOCKID, SEC and PRIV matches the AHB bus master definition, the SEC is cleared to 0.
- When the semaphore is unlocked (LOCK bit written to 0 and AHB bus master ID  does not match LOCKID and/or SEC or PRIV do not match AHB bus master definition, the SEC is not affected.
- Write when LOCK bit is already 1 (semaphore locked), the SEC is not affected.
- An authorized read returns the stored SEC value.</description>
                <bitOffset>12</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Semaphore free or locked by non-secure compartment.</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Semaphore locked by secure compartment.</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>PRIV</name>
                <description>Semaphore privilege
Written by software
- When the semaphore is free and the LOCK bit is at the same time written to 1, and the LOCKID matches the AHB bus master ID, SEC and PRIV matches the AHB bus master definition.
- When the semaphore is unlocked (LOCK written to 0 and AHB bus master ID matched LOCKID, SEC and PRIV matches the AHB bus master definition, the PRIV is cleared to 0.
- When the semaphore is unlocked (LOCK bit written to 0 and AHB bus master ID  does not match LOCKID and/or SEC or PRIV do not match AHB bus master definition, the PRIV is not affected.
- Write when LOCK bit is already 1 (semaphore locked), the PRIV is not affected.
- An authorized read returns the stored PRIV value.</description>
                <bitOffset>13</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Semaphore free or locked by unprivileged compartment.</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Semaphore locked by privilege compartment.</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>LOCK</name>
                <description>Lock indication
This bit can be written and read by software.</description>
                <bitOffset>31</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>On write free semaphore (only when LOCKID and PROCID match), on read semaphore is free.</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>On write try to lock semaphore, on read semaphore is locked.</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
            </fields>
          </register>
          <register>
            <name>HSEM_R14</name>
            <displayName>HSEM_R14</displayName>
            <description>HSEM register semaphore 14</description>
            <addressOffset>0x38</addressOffset>
            <size>0x20</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>PROCID</name>
                <description>Semaphore PROCID
Written by software
-When the semaphore is free and the LOCK is written to 1, and the LOCKID matches the AHB bus master ID, SEC and PRIV matches the AHB bus master definition, PROCID is set to the written data.
- When the semaphore is unlocked, LOCK written to 0 and AHB bus master ID matched LOCKID, SEC and PRIV matches the AHB bus master protection, the PROCID is cleared to 0.
- When the semaphore is unlocked, LOCK bit written to 0 and AHB bus master ID does not match LOCKID and/or SEC or PRIV do not match the AHB bus master definition, the PROCID is not affected.
- Write when LOCK bit is already 1 (semaphore locked), the PROCID is not affected.
- An authorized read returns the stored PROCID value.</description>
                <bitOffset>0</bitOffset>
                <bitWidth>8</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>LOCKID</name>
                <description>Semaphore LOCKID
Written by software
- When the semaphore is free and the LOCK bit is at the same time written to 1 and the LOCKID matches the AHB bus master ID, SEC and PRIV matches the AHB bus master protection.
- When the semaphore is unlocked (LOCK written to 0 and AHB bus master ID matched LOCKID, SEC and PRIV matches the AHB bus master protection, the LOCKID is cleared to 0.
- When the semaphore is unlocked (LOCK bit written to 0 or AHB bus master ID does not match LOCKID and/or SEC or PRIV do not match AHB bus master protection, the LOCKID is not affected.
- Write when LOCK bit is already 1 (semaphore locked), the LOCKID is not affected.
- An authorized read returns the stored LOCKID value.</description>
                <bitOffset>8</bitOffset>
                <bitWidth>4</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>SEC</name>
                <description>Semaphore secure
Written by software
- When the semaphore is free and the LOCK bit is at the same time written to 1, and the LOCKID matches the AHB bus master ID, SEC and PRIV matches the AHB bus master definition.
- When the semaphore is unlocked (LOCK written to 0 and AHB bus master ID matched LOCKID, SEC and PRIV matches the AHB bus master definition, the SEC is cleared to 0.
- When the semaphore is unlocked (LOCK bit written to 0 and AHB bus master ID  does not match LOCKID and/or SEC or PRIV do not match AHB bus master definition, the SEC is not affected.
- Write when LOCK bit is already 1 (semaphore locked), the SEC is not affected.
- An authorized read returns the stored SEC value.</description>
                <bitOffset>12</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Semaphore free or locked by non-secure compartment.</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Semaphore locked by secure compartment.</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>PRIV</name>
                <description>Semaphore privilege
Written by software
- When the semaphore is free and the LOCK bit is at the same time written to 1, and the LOCKID matches the AHB bus master ID, SEC and PRIV matches the AHB bus master definition.
- When the semaphore is unlocked (LOCK written to 0 and AHB bus master ID matched LOCKID, SEC and PRIV matches the AHB bus master definition, the PRIV is cleared to 0.
- When the semaphore is unlocked (LOCK bit written to 0 and AHB bus master ID  does not match LOCKID and/or SEC or PRIV do not match AHB bus master definition, the PRIV is not affected.
- Write when LOCK bit is already 1 (semaphore locked), the PRIV is not affected.
- An authorized read returns the stored PRIV value.</description>
                <bitOffset>13</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Semaphore free or locked by unprivileged compartment.</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Semaphore locked by privilege compartment.</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>LOCK</name>
                <description>Lock indication
This bit can be written and read by software.</description>
                <bitOffset>31</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>On write free semaphore (only when LOCKID and PROCID match), on read semaphore is free.</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>On write try to lock semaphore, on read semaphore is locked.</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
            </fields>
          </register>
          <register>
            <name>HSEM_R15</name>
            <displayName>HSEM_R15</displayName>
            <description>HSEM register semaphore 15</description>
            <addressOffset>0x3C</addressOffset>
            <size>0x20</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>PROCID</name>
                <description>Semaphore PROCID
Written by software
-When the semaphore is free and the LOCK is written to 1, and the LOCKID matches the AHB bus master ID, SEC and PRIV matches the AHB bus master definition, PROCID is set to the written data.
- When the semaphore is unlocked, LOCK written to 0 and AHB bus master ID matched LOCKID, SEC and PRIV matches the AHB bus master protection, the PROCID is cleared to 0.
- When the semaphore is unlocked, LOCK bit written to 0 and AHB bus master ID does not match LOCKID and/or SEC or PRIV do not match the AHB bus master definition, the PROCID is not affected.
- Write when LOCK bit is already 1 (semaphore locked), the PROCID is not affected.
- An authorized read returns the stored PROCID value.</description>
                <bitOffset>0</bitOffset>
                <bitWidth>8</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>LOCKID</name>
                <description>Semaphore LOCKID
Written by software
- When the semaphore is free and the LOCK bit is at the same time written to 1 and the LOCKID matches the AHB bus master ID, SEC and PRIV matches the AHB bus master protection.
- When the semaphore is unlocked (LOCK written to 0 and AHB bus master ID matched LOCKID, SEC and PRIV matches the AHB bus master protection, the LOCKID is cleared to 0.
- When the semaphore is unlocked (LOCK bit written to 0 or AHB bus master ID does not match LOCKID and/or SEC or PRIV do not match AHB bus master protection, the LOCKID is not affected.
- Write when LOCK bit is already 1 (semaphore locked), the LOCKID is not affected.
- An authorized read returns the stored LOCKID value.</description>
                <bitOffset>8</bitOffset>
                <bitWidth>4</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>SEC</name>
                <description>Semaphore secure
Written by software
- When the semaphore is free and the LOCK bit is at the same time written to 1, and the LOCKID matches the AHB bus master ID, SEC and PRIV matches the AHB bus master definition.
- When the semaphore is unlocked (LOCK written to 0 and AHB bus master ID matched LOCKID, SEC and PRIV matches the AHB bus master definition, the SEC is cleared to 0.
- When the semaphore is unlocked (LOCK bit written to 0 and AHB bus master ID  does not match LOCKID and/or SEC or PRIV do not match AHB bus master definition, the SEC is not affected.
- Write when LOCK bit is already 1 (semaphore locked), the SEC is not affected.
- An authorized read returns the stored SEC value.</description>
                <bitOffset>12</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Semaphore free or locked by non-secure compartment.</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Semaphore locked by secure compartment.</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>PRIV</name>
                <description>Semaphore privilege
Written by software
- When the semaphore is free and the LOCK bit is at the same time written to 1, and the LOCKID matches the AHB bus master ID, SEC and PRIV matches the AHB bus master definition.
- When the semaphore is unlocked (LOCK written to 0 and AHB bus master ID matched LOCKID, SEC and PRIV matches the AHB bus master definition, the PRIV is cleared to 0.
- When the semaphore is unlocked (LOCK bit written to 0 and AHB bus master ID  does not match LOCKID and/or SEC or PRIV do not match AHB bus master definition, the PRIV is not affected.
- Write when LOCK bit is already 1 (semaphore locked), the PRIV is not affected.
- An authorized read returns the stored PRIV value.</description>
                <bitOffset>13</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Semaphore free or locked by unprivileged compartment.</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Semaphore locked by privilege compartment.</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>LOCK</name>
                <description>Lock indication
This bit can be written and read by software.</description>
                <bitOffset>31</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>On write free semaphore (only when LOCKID and PROCID match), on read semaphore is free.</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>On write try to lock semaphore, on read semaphore is locked.</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
            </fields>
          </register>
          <register>
            <name>HSEM_RLR0</name>
            <displayName>HSEM_RLR0</displayName>
            <description>HSEM read lock register semaphore 0</description>
            <addressOffset>0x80</addressOffset>
            <size>0x20</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>PROCID</name>
                <description>Semaphore processor ID
This field is read only by software at this address.
- On a read when the semaphore is free:
A read with a valid AHB bus master ID and SEC and PRIV locks the semaphore and hardware sets the PROCID to 0.
- When the semaphore is locked:
A read with a valid AHB bus master ID and SEC and PRIV returns the PROCID of the AHB bus master that has locked the semaphore.</description>
                <bitOffset>0</bitOffset>
                <bitWidth>8</bitWidth>
                <access>read-only</access>
              </field>
              <field>
                <name>LOCKID</name>
                <description>Semaphore LOCKID
This field is read only by software at this address.
On a read, when the semaphore is free, the hardware sets the LOCKID to the AHB bus master ID reading the semaphore. The LOCKID of the AHB bus master locking the semaphore is read.
On a read when the semaphore is locked, this field returns the LOCKID of the AHB bus master that has locked the semaphore.</description>
                <bitOffset>8</bitOffset>
                <bitWidth>4</bitWidth>
                <access>read-only</access>
              </field>
              <field>
                <name>SEC</name>
                <description>Semaphore secure.
This field is read only by software at this address.
- When the semaphore is free:
A read with a valid AHB bus master ID and SEC and PRIV locks the semaphore and hardware sets the SEC to the valid AHB bus master security definition.
- When the semaphore is locked:
A read with a valid AHB bus master ID and SEC and PRIV returns the SEC of the AHB bus master that has locked the semaphore.</description>
                <bitOffset>12</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Semaphore free or locked by non-secure compartment.</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Semaphore locked by secure compartment.</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>PRIV</name>
                <description>Semaphore privilege
This field is read only by software at this address.
- When the semaphore is free:
A read with a valid AHB bus master ID and SEC and PRIV locks the semaphore and hardware sets the PRIV to the valid AHB bus master privileged definition.
- When the semaphore is locked:
A read with a valid AHB bus master ID and SEC and PRIV returns the PRIV of the AHB bus master that has locked the semaphore.</description>
                <bitOffset>13</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Semaphore free or locked by unprivileged compartment.</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Semaphore locked by privileged compartment.</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>LOCK</name>
                <description>Lock indication
This bit is read only by software at this address. 
- When the semaphore is free:
A read with a valid AHB bus master ID and SEC and PRIV locks the semaphore and returns 1.
- When the semaphore is locked:
A read with a valid AHB bus master ID and SEC and PRIV returns 1 (the LOCKID and SEC and PRIV and PROCID reflect the already locked semaphore information).</description>
                <bitOffset>31</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-only</access>
              </field>
            </fields>
          </register>
          <register>
            <name>HSEM_RLR1</name>
            <displayName>HSEM_RLR1</displayName>
            <description>HSEM read lock register semaphore 1</description>
            <addressOffset>0x84</addressOffset>
            <size>0x20</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>PROCID</name>
                <description>Semaphore processor ID
This field is read only by software at this address.
- On a read when the semaphore is free:
A read with a valid AHB bus master ID and SEC and PRIV locks the semaphore and hardware sets the PROCID to 0.
- When the semaphore is locked:
A read with a valid AHB bus master ID and SEC and PRIV returns the PROCID of the AHB bus master that has locked the semaphore.</description>
                <bitOffset>0</bitOffset>
                <bitWidth>8</bitWidth>
                <access>read-only</access>
              </field>
              <field>
                <name>LOCKID</name>
                <description>Semaphore LOCKID
This field is read only by software at this address.
On a read, when the semaphore is free, the hardware sets the LOCKID to the AHB bus master ID reading the semaphore. The LOCKID of the AHB bus master locking the semaphore is read.
On a read when the semaphore is locked, this field returns the LOCKID of the AHB bus master that has locked the semaphore.</description>
                <bitOffset>8</bitOffset>
                <bitWidth>4</bitWidth>
                <access>read-only</access>
              </field>
              <field>
                <name>SEC</name>
                <description>Semaphore secure.
This field is read only by software at this address.
- When the semaphore is free:
A read with a valid AHB bus master ID and SEC and PRIV locks the semaphore and hardware sets the SEC to the valid AHB bus master security definition.
- When the semaphore is locked:
A read with a valid AHB bus master ID and SEC and PRIV returns the SEC of the AHB bus master that has locked the semaphore.</description>
                <bitOffset>12</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Semaphore free or locked by non-secure compartment.</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Semaphore locked by secure compartment.</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>PRIV</name>
                <description>Semaphore privilege
This field is read only by software at this address.
- When the semaphore is free:
A read with a valid AHB bus master ID and SEC and PRIV locks the semaphore and hardware sets the PRIV to the valid AHB bus master privileged definition.
- When the semaphore is locked:
A read with a valid AHB bus master ID and SEC and PRIV returns the PRIV of the AHB bus master that has locked the semaphore.</description>
                <bitOffset>13</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Semaphore free or locked by unprivileged compartment.</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Semaphore locked by privileged compartment.</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>LOCK</name>
                <description>Lock indication
This bit is read only by software at this address. 
- When the semaphore is free:
A read with a valid AHB bus master ID and SEC and PRIV locks the semaphore and returns 1.
- When the semaphore is locked:
A read with a valid AHB bus master ID and SEC and PRIV returns 1 (the LOCKID and SEC and PRIV and PROCID reflect the already locked semaphore information).</description>
                <bitOffset>31</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-only</access>
              </field>
            </fields>
          </register>
          <register>
            <name>HSEM_RLR2</name>
            <displayName>HSEM_RLR2</displayName>
            <description>HSEM read lock register semaphore 2</description>
            <addressOffset>0x88</addressOffset>
            <size>0x20</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>PROCID</name>
                <description>Semaphore processor ID
This field is read only by software at this address.
- On a read when the semaphore is free:
A read with a valid AHB bus master ID and SEC and PRIV locks the semaphore and hardware sets the PROCID to 0.
- When the semaphore is locked:
A read with a valid AHB bus master ID and SEC and PRIV returns the PROCID of the AHB bus master that has locked the semaphore.</description>
                <bitOffset>0</bitOffset>
                <bitWidth>8</bitWidth>
                <access>read-only</access>
              </field>
              <field>
                <name>LOCKID</name>
                <description>Semaphore LOCKID
This field is read only by software at this address.
On a read, when the semaphore is free, the hardware sets the LOCKID to the AHB bus master ID reading the semaphore. The LOCKID of the AHB bus master locking the semaphore is read.
On a read when the semaphore is locked, this field returns the LOCKID of the AHB bus master that has locked the semaphore.</description>
                <bitOffset>8</bitOffset>
                <bitWidth>4</bitWidth>
                <access>read-only</access>
              </field>
              <field>
                <name>SEC</name>
                <description>Semaphore secure.
This field is read only by software at this address.
- When the semaphore is free:
A read with a valid AHB bus master ID and SEC and PRIV locks the semaphore and hardware sets the SEC to the valid AHB bus master security definition.
- When the semaphore is locked:
A read with a valid AHB bus master ID and SEC and PRIV returns the SEC of the AHB bus master that has locked the semaphore.</description>
                <bitOffset>12</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Semaphore free or locked by non-secure compartment.</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Semaphore locked by secure compartment.</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>PRIV</name>
                <description>Semaphore privilege
This field is read only by software at this address.
- When the semaphore is free:
A read with a valid AHB bus master ID and SEC and PRIV locks the semaphore and hardware sets the PRIV to the valid AHB bus master privileged definition.
- When the semaphore is locked:
A read with a valid AHB bus master ID and SEC and PRIV returns the PRIV of the AHB bus master that has locked the semaphore.</description>
                <bitOffset>13</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Semaphore free or locked by unprivileged compartment.</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Semaphore locked by privileged compartment.</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>LOCK</name>
                <description>Lock indication
This bit is read only by software at this address. 
- When the semaphore is free:
A read with a valid AHB bus master ID and SEC and PRIV locks the semaphore and returns 1.
- When the semaphore is locked:
A read with a valid AHB bus master ID and SEC and PRIV returns 1 (the LOCKID and SEC and PRIV and PROCID reflect the already locked semaphore information).</description>
                <bitOffset>31</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-only</access>
              </field>
            </fields>
          </register>
          <register>
            <name>HSEM_RLR3</name>
            <displayName>HSEM_RLR3</displayName>
            <description>HSEM read lock register semaphore 3</description>
            <addressOffset>0x8C</addressOffset>
            <size>0x20</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>PROCID</name>
                <description>Semaphore processor ID
This field is read only by software at this address.
- On a read when the semaphore is free:
A read with a valid AHB bus master ID and SEC and PRIV locks the semaphore and hardware sets the PROCID to 0.
- When the semaphore is locked:
A read with a valid AHB bus master ID and SEC and PRIV returns the PROCID of the AHB bus master that has locked the semaphore.</description>
                <bitOffset>0</bitOffset>
                <bitWidth>8</bitWidth>
                <access>read-only</access>
              </field>
              <field>
                <name>LOCKID</name>
                <description>Semaphore LOCKID
This field is read only by software at this address.
On a read, when the semaphore is free, the hardware sets the LOCKID to the AHB bus master ID reading the semaphore. The LOCKID of the AHB bus master locking the semaphore is read.
On a read when the semaphore is locked, this field returns the LOCKID of the AHB bus master that has locked the semaphore.</description>
                <bitOffset>8</bitOffset>
                <bitWidth>4</bitWidth>
                <access>read-only</access>
              </field>
              <field>
                <name>SEC</name>
                <description>Semaphore secure.
This field is read only by software at this address.
- When the semaphore is free:
A read with a valid AHB bus master ID and SEC and PRIV locks the semaphore and hardware sets the SEC to the valid AHB bus master security definition.
- When the semaphore is locked:
A read with a valid AHB bus master ID and SEC and PRIV returns the SEC of the AHB bus master that has locked the semaphore.</description>
                <bitOffset>12</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Semaphore free or locked by non-secure compartment.</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Semaphore locked by secure compartment.</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>PRIV</name>
                <description>Semaphore privilege
This field is read only by software at this address.
- When the semaphore is free:
A read with a valid AHB bus master ID and SEC and PRIV locks the semaphore and hardware sets the PRIV to the valid AHB bus master privileged definition.
- When the semaphore is locked:
A read with a valid AHB bus master ID and SEC and PRIV returns the PRIV of the AHB bus master that has locked the semaphore.</description>
                <bitOffset>13</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Semaphore free or locked by unprivileged compartment.</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Semaphore locked by privileged compartment.</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>LOCK</name>
                <description>Lock indication
This bit is read only by software at this address. 
- When the semaphore is free:
A read with a valid AHB bus master ID and SEC and PRIV locks the semaphore and returns 1.
- When the semaphore is locked:
A read with a valid AHB bus master ID and SEC and PRIV returns 1 (the LOCKID and SEC and PRIV and PROCID reflect the already locked semaphore information).</description>
                <bitOffset>31</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-only</access>
              </field>
            </fields>
          </register>
          <register>
            <name>HSEM_RLR4</name>
            <displayName>HSEM_RLR4</displayName>
            <description>HSEM read lock register semaphore 4</description>
            <addressOffset>0x90</addressOffset>
            <size>0x20</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>PROCID</name>
                <description>Semaphore processor ID
This field is read only by software at this address.
- On a read when the semaphore is free:
A read with a valid AHB bus master ID and SEC and PRIV locks the semaphore and hardware sets the PROCID to 0.
- When the semaphore is locked:
A read with a valid AHB bus master ID and SEC and PRIV returns the PROCID of the AHB bus master that has locked the semaphore.</description>
                <bitOffset>0</bitOffset>
                <bitWidth>8</bitWidth>
                <access>read-only</access>
              </field>
              <field>
                <name>LOCKID</name>
                <description>Semaphore LOCKID
This field is read only by software at this address.
On a read, when the semaphore is free, the hardware sets the LOCKID to the AHB bus master ID reading the semaphore. The LOCKID of the AHB bus master locking the semaphore is read.
On a read when the semaphore is locked, this field returns the LOCKID of the AHB bus master that has locked the semaphore.</description>
                <bitOffset>8</bitOffset>
                <bitWidth>4</bitWidth>
                <access>read-only</access>
              </field>
              <field>
                <name>SEC</name>
                <description>Semaphore secure.
This field is read only by software at this address.
- When the semaphore is free:
A read with a valid AHB bus master ID and SEC and PRIV locks the semaphore and hardware sets the SEC to the valid AHB bus master security definition.
- When the semaphore is locked:
A read with a valid AHB bus master ID and SEC and PRIV returns the SEC of the AHB bus master that has locked the semaphore.</description>
                <bitOffset>12</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Semaphore free or locked by non-secure compartment.</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Semaphore locked by secure compartment.</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>PRIV</name>
                <description>Semaphore privilege
This field is read only by software at this address.
- When the semaphore is free:
A read with a valid AHB bus master ID and SEC and PRIV locks the semaphore and hardware sets the PRIV to the valid AHB bus master privileged definition.
- When the semaphore is locked:
A read with a valid AHB bus master ID and SEC and PRIV returns the PRIV of the AHB bus master that has locked the semaphore.</description>
                <bitOffset>13</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Semaphore free or locked by unprivileged compartment.</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Semaphore locked by privileged compartment.</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>LOCK</name>
                <description>Lock indication
This bit is read only by software at this address. 
- When the semaphore is free:
A read with a valid AHB bus master ID and SEC and PRIV locks the semaphore and returns 1.
- When the semaphore is locked:
A read with a valid AHB bus master ID and SEC and PRIV returns 1 (the LOCKID and SEC and PRIV and PROCID reflect the already locked semaphore information).</description>
                <bitOffset>31</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-only</access>
              </field>
            </fields>
          </register>
          <register>
            <name>HSEM_RLR5</name>
            <displayName>HSEM_RLR5</displayName>
            <description>HSEM read lock register semaphore 5</description>
            <addressOffset>0x94</addressOffset>
            <size>0x20</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>PROCID</name>
                <description>Semaphore processor ID
This field is read only by software at this address.
- On a read when the semaphore is free:
A read with a valid AHB bus master ID and SEC and PRIV locks the semaphore and hardware sets the PROCID to 0.
- When the semaphore is locked:
A read with a valid AHB bus master ID and SEC and PRIV returns the PROCID of the AHB bus master that has locked the semaphore.</description>
                <bitOffset>0</bitOffset>
                <bitWidth>8</bitWidth>
                <access>read-only</access>
              </field>
              <field>
                <name>LOCKID</name>
                <description>Semaphore LOCKID
This field is read only by software at this address.
On a read, when the semaphore is free, the hardware sets the LOCKID to the AHB bus master ID reading the semaphore. The LOCKID of the AHB bus master locking the semaphore is read.
On a read when the semaphore is locked, this field returns the LOCKID of the AHB bus master that has locked the semaphore.</description>
                <bitOffset>8</bitOffset>
                <bitWidth>4</bitWidth>
                <access>read-only</access>
              </field>
              <field>
                <name>SEC</name>
                <description>Semaphore secure.
This field is read only by software at this address.
- When the semaphore is free:
A read with a valid AHB bus master ID and SEC and PRIV locks the semaphore and hardware sets the SEC to the valid AHB bus master security definition.
- When the semaphore is locked:
A read with a valid AHB bus master ID and SEC and PRIV returns the SEC of the AHB bus master that has locked the semaphore.</description>
                <bitOffset>12</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Semaphore free or locked by non-secure compartment.</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Semaphore locked by secure compartment.</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>PRIV</name>
                <description>Semaphore privilege
This field is read only by software at this address.
- When the semaphore is free:
A read with a valid AHB bus master ID and SEC and PRIV locks the semaphore and hardware sets the PRIV to the valid AHB bus master privileged definition.
- When the semaphore is locked:
A read with a valid AHB bus master ID and SEC and PRIV returns the PRIV of the AHB bus master that has locked the semaphore.</description>
                <bitOffset>13</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Semaphore free or locked by unprivileged compartment.</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Semaphore locked by privileged compartment.</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>LOCK</name>
                <description>Lock indication
This bit is read only by software at this address. 
- When the semaphore is free:
A read with a valid AHB bus master ID and SEC and PRIV locks the semaphore and returns 1.
- When the semaphore is locked:
A read with a valid AHB bus master ID and SEC and PRIV returns 1 (the LOCKID and SEC and PRIV and PROCID reflect the already locked semaphore information).</description>
                <bitOffset>31</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-only</access>
              </field>
            </fields>
          </register>
          <register>
            <name>HSEM_RLR6</name>
            <displayName>HSEM_RLR6</displayName>
            <description>HSEM read lock register semaphore 6</description>
            <addressOffset>0x98</addressOffset>
            <size>0x20</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>PROCID</name>
                <description>Semaphore processor ID
This field is read only by software at this address.
- On a read when the semaphore is free:
A read with a valid AHB bus master ID and SEC and PRIV locks the semaphore and hardware sets the PROCID to 0.
- When the semaphore is locked:
A read with a valid AHB bus master ID and SEC and PRIV returns the PROCID of the AHB bus master that has locked the semaphore.</description>
                <bitOffset>0</bitOffset>
                <bitWidth>8</bitWidth>
                <access>read-only</access>
              </field>
              <field>
                <name>LOCKID</name>
                <description>Semaphore LOCKID
This field is read only by software at this address.
On a read, when the semaphore is free, the hardware sets the LOCKID to the AHB bus master ID reading the semaphore. The LOCKID of the AHB bus master locking the semaphore is read.
On a read when the semaphore is locked, this field returns the LOCKID of the AHB bus master that has locked the semaphore.</description>
                <bitOffset>8</bitOffset>
                <bitWidth>4</bitWidth>
                <access>read-only</access>
              </field>
              <field>
                <name>SEC</name>
                <description>Semaphore secure.
This field is read only by software at this address.
- When the semaphore is free:
A read with a valid AHB bus master ID and SEC and PRIV locks the semaphore and hardware sets the SEC to the valid AHB bus master security definition.
- When the semaphore is locked:
A read with a valid AHB bus master ID and SEC and PRIV returns the SEC of the AHB bus master that has locked the semaphore.</description>
                <bitOffset>12</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Semaphore free or locked by non-secure compartment.</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Semaphore locked by secure compartment.</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>PRIV</name>
                <description>Semaphore privilege
This field is read only by software at this address.
- When the semaphore is free:
A read with a valid AHB bus master ID and SEC and PRIV locks the semaphore and hardware sets the PRIV to the valid AHB bus master privileged definition.
- When the semaphore is locked:
A read with a valid AHB bus master ID and SEC and PRIV returns the PRIV of the AHB bus master that has locked the semaphore.</description>
                <bitOffset>13</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Semaphore free or locked by unprivileged compartment.</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Semaphore locked by privileged compartment.</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>LOCK</name>
                <description>Lock indication
This bit is read only by software at this address. 
- When the semaphore is free:
A read with a valid AHB bus master ID and SEC and PRIV locks the semaphore and returns 1.
- When the semaphore is locked:
A read with a valid AHB bus master ID and SEC and PRIV returns 1 (the LOCKID and SEC and PRIV and PROCID reflect the already locked semaphore information).</description>
                <bitOffset>31</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-only</access>
              </field>
            </fields>
          </register>
          <register>
            <name>HSEM_RLR7</name>
            <displayName>HSEM_RLR7</displayName>
            <description>HSEM read lock register semaphore 7</description>
            <addressOffset>0x9C</addressOffset>
            <size>0x20</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>PROCID</name>
                <description>Semaphore processor ID
This field is read only by software at this address.
- On a read when the semaphore is free:
A read with a valid AHB bus master ID and SEC and PRIV locks the semaphore and hardware sets the PROCID to 0.
- When the semaphore is locked:
A read with a valid AHB bus master ID and SEC and PRIV returns the PROCID of the AHB bus master that has locked the semaphore.</description>
                <bitOffset>0</bitOffset>
                <bitWidth>8</bitWidth>
                <access>read-only</access>
              </field>
              <field>
                <name>LOCKID</name>
                <description>Semaphore LOCKID
This field is read only by software at this address.
On a read, when the semaphore is free, the hardware sets the LOCKID to the AHB bus master ID reading the semaphore. The LOCKID of the AHB bus master locking the semaphore is read.
On a read when the semaphore is locked, this field returns the LOCKID of the AHB bus master that has locked the semaphore.</description>
                <bitOffset>8</bitOffset>
                <bitWidth>4</bitWidth>
                <access>read-only</access>
              </field>
              <field>
                <name>SEC</name>
                <description>Semaphore secure.
This field is read only by software at this address.
- When the semaphore is free:
A read with a valid AHB bus master ID and SEC and PRIV locks the semaphore and hardware sets the SEC to the valid AHB bus master security definition.
- When the semaphore is locked:
A read with a valid AHB bus master ID and SEC and PRIV returns the SEC of the AHB bus master that has locked the semaphore.</description>
                <bitOffset>12</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Semaphore free or locked by non-secure compartment.</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Semaphore locked by secure compartment.</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>PRIV</name>
                <description>Semaphore privilege
This field is read only by software at this address.
- When the semaphore is free:
A read with a valid AHB bus master ID and SEC and PRIV locks the semaphore and hardware sets the PRIV to the valid AHB bus master privileged definition.
- When the semaphore is locked:
A read with a valid AHB bus master ID and SEC and PRIV returns the PRIV of the AHB bus master that has locked the semaphore.</description>
                <bitOffset>13</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Semaphore free or locked by unprivileged compartment.</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Semaphore locked by privileged compartment.</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>LOCK</name>
                <description>Lock indication
This bit is read only by software at this address. 
- When the semaphore is free:
A read with a valid AHB bus master ID and SEC and PRIV locks the semaphore and returns 1.
- When the semaphore is locked:
A read with a valid AHB bus master ID and SEC and PRIV returns 1 (the LOCKID and SEC and PRIV and PROCID reflect the already locked semaphore information).</description>
                <bitOffset>31</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-only</access>
              </field>
            </fields>
          </register>
          <register>
            <name>HSEM_RLR8</name>
            <displayName>HSEM_RLR8</displayName>
            <description>HSEM read lock register semaphore 8</description>
            <addressOffset>0xA0</addressOffset>
            <size>0x20</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>PROCID</name>
                <description>Semaphore processor ID
This field is read only by software at this address.
- On a read when the semaphore is free:
A read with a valid AHB bus master ID and SEC and PRIV locks the semaphore and hardware sets the PROCID to 0.
- When the semaphore is locked:
A read with a valid AHB bus master ID and SEC and PRIV returns the PROCID of the AHB bus master that has locked the semaphore.</description>
                <bitOffset>0</bitOffset>
                <bitWidth>8</bitWidth>
                <access>read-only</access>
              </field>
              <field>
                <name>LOCKID</name>
                <description>Semaphore LOCKID
This field is read only by software at this address.
On a read, when the semaphore is free, the hardware sets the LOCKID to the AHB bus master ID reading the semaphore. The LOCKID of the AHB bus master locking the semaphore is read.
On a read when the semaphore is locked, this field returns the LOCKID of the AHB bus master that has locked the semaphore.</description>
                <bitOffset>8</bitOffset>
                <bitWidth>4</bitWidth>
                <access>read-only</access>
              </field>
              <field>
                <name>SEC</name>
                <description>Semaphore secure.
This field is read only by software at this address.
- When the semaphore is free:
A read with a valid AHB bus master ID and SEC and PRIV locks the semaphore and hardware sets the SEC to the valid AHB bus master security definition.
- When the semaphore is locked:
A read with a valid AHB bus master ID and SEC and PRIV returns the SEC of the AHB bus master that has locked the semaphore.</description>
                <bitOffset>12</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Semaphore free or locked by non-secure compartment.</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Semaphore locked by secure compartment.</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>PRIV</name>
                <description>Semaphore privilege
This field is read only by software at this address.
- When the semaphore is free:
A read with a valid AHB bus master ID and SEC and PRIV locks the semaphore and hardware sets the PRIV to the valid AHB bus master privileged definition.
- When the semaphore is locked:
A read with a valid AHB bus master ID and SEC and PRIV returns the PRIV of the AHB bus master that has locked the semaphore.</description>
                <bitOffset>13</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Semaphore free or locked by unprivileged compartment.</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Semaphore locked by privileged compartment.</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>LOCK</name>
                <description>Lock indication
This bit is read only by software at this address. 
- When the semaphore is free:
A read with a valid AHB bus master ID and SEC and PRIV locks the semaphore and returns 1.
- When the semaphore is locked:
A read with a valid AHB bus master ID and SEC and PRIV returns 1 (the LOCKID and SEC and PRIV and PROCID reflect the already locked semaphore information).</description>
                <bitOffset>31</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-only</access>
              </field>
            </fields>
          </register>
          <register>
            <name>HSEM_RLR9</name>
            <displayName>HSEM_RLR9</displayName>
            <description>HSEM read lock register semaphore 9</description>
            <addressOffset>0xA4</addressOffset>
            <size>0x20</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>PROCID</name>
                <description>Semaphore processor ID
This field is read only by software at this address.
- On a read when the semaphore is free:
A read with a valid AHB bus master ID and SEC and PRIV locks the semaphore and hardware sets the PROCID to 0.
- When the semaphore is locked:
A read with a valid AHB bus master ID and SEC and PRIV returns the PROCID of the AHB bus master that has locked the semaphore.</description>
                <bitOffset>0</bitOffset>
                <bitWidth>8</bitWidth>
                <access>read-only</access>
              </field>
              <field>
                <name>LOCKID</name>
                <description>Semaphore LOCKID
This field is read only by software at this address.
On a read, when the semaphore is free, the hardware sets the LOCKID to the AHB bus master ID reading the semaphore. The LOCKID of the AHB bus master locking the semaphore is read.
On a read when the semaphore is locked, this field returns the LOCKID of the AHB bus master that has locked the semaphore.</description>
                <bitOffset>8</bitOffset>
                <bitWidth>4</bitWidth>
                <access>read-only</access>
              </field>
              <field>
                <name>SEC</name>
                <description>Semaphore secure.
This field is read only by software at this address.
- When the semaphore is free:
A read with a valid AHB bus master ID and SEC and PRIV locks the semaphore and hardware sets the SEC to the valid AHB bus master security definition.
- When the semaphore is locked:
A read with a valid AHB bus master ID and SEC and PRIV returns the SEC of the AHB bus master that has locked the semaphore.</description>
                <bitOffset>12</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Semaphore free or locked by non-secure compartment.</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Semaphore locked by secure compartment.</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>PRIV</name>
                <description>Semaphore privilege
This field is read only by software at this address.
- When the semaphore is free:
A read with a valid AHB bus master ID and SEC and PRIV locks the semaphore and hardware sets the PRIV to the valid AHB bus master privileged definition.
- When the semaphore is locked:
A read with a valid AHB bus master ID and SEC and PRIV returns the PRIV of the AHB bus master that has locked the semaphore.</description>
                <bitOffset>13</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Semaphore free or locked by unprivileged compartment.</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Semaphore locked by privileged compartment.</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>LOCK</name>
                <description>Lock indication
This bit is read only by software at this address. 
- When the semaphore is free:
A read with a valid AHB bus master ID and SEC and PRIV locks the semaphore and returns 1.
- When the semaphore is locked:
A read with a valid AHB bus master ID and SEC and PRIV returns 1 (the LOCKID and SEC and PRIV and PROCID reflect the already locked semaphore information).</description>
                <bitOffset>31</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-only</access>
              </field>
            </fields>
          </register>
          <register>
            <name>HSEM_RLR10</name>
            <displayName>HSEM_RLR10</displayName>
            <description>HSEM read lock register semaphore 10</description>
            <addressOffset>0xA8</addressOffset>
            <size>0x20</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>PROCID</name>
                <description>Semaphore processor ID
This field is read only by software at this address.
- On a read when the semaphore is free:
A read with a valid AHB bus master ID and SEC and PRIV locks the semaphore and hardware sets the PROCID to 0.
- When the semaphore is locked:
A read with a valid AHB bus master ID and SEC and PRIV returns the PROCID of the AHB bus master that has locked the semaphore.</description>
                <bitOffset>0</bitOffset>
                <bitWidth>8</bitWidth>
                <access>read-only</access>
              </field>
              <field>
                <name>LOCKID</name>
                <description>Semaphore LOCKID
This field is read only by software at this address.
On a read, when the semaphore is free, the hardware sets the LOCKID to the AHB bus master ID reading the semaphore. The LOCKID of the AHB bus master locking the semaphore is read.
On a read when the semaphore is locked, this field returns the LOCKID of the AHB bus master that has locked the semaphore.</description>
                <bitOffset>8</bitOffset>
                <bitWidth>4</bitWidth>
                <access>read-only</access>
              </field>
              <field>
                <name>SEC</name>
                <description>Semaphore secure.
This field is read only by software at this address.
- When the semaphore is free:
A read with a valid AHB bus master ID and SEC and PRIV locks the semaphore and hardware sets the SEC to the valid AHB bus master security definition.
- When the semaphore is locked:
A read with a valid AHB bus master ID and SEC and PRIV returns the SEC of the AHB bus master that has locked the semaphore.</description>
                <bitOffset>12</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Semaphore free or locked by non-secure compartment.</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Semaphore locked by secure compartment.</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>PRIV</name>
                <description>Semaphore privilege
This field is read only by software at this address.
- When the semaphore is free:
A read with a valid AHB bus master ID and SEC and PRIV locks the semaphore and hardware sets the PRIV to the valid AHB bus master privileged definition.
- When the semaphore is locked:
A read with a valid AHB bus master ID and SEC and PRIV returns the PRIV of the AHB bus master that has locked the semaphore.</description>
                <bitOffset>13</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Semaphore free or locked by unprivileged compartment.</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Semaphore locked by privileged compartment.</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>LOCK</name>
                <description>Lock indication
This bit is read only by software at this address. 
- When the semaphore is free:
A read with a valid AHB bus master ID and SEC and PRIV locks the semaphore and returns 1.
- When the semaphore is locked:
A read with a valid AHB bus master ID and SEC and PRIV returns 1 (the LOCKID and SEC and PRIV and PROCID reflect the already locked semaphore information).</description>
                <bitOffset>31</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-only</access>
              </field>
            </fields>
          </register>
          <register>
            <name>HSEM_RLR11</name>
            <displayName>HSEM_RLR11</displayName>
            <description>HSEM read lock register semaphore 11</description>
            <addressOffset>0xAC</addressOffset>
            <size>0x20</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>PROCID</name>
                <description>Semaphore processor ID
This field is read only by software at this address.
- On a read when the semaphore is free:
A read with a valid AHB bus master ID and SEC and PRIV locks the semaphore and hardware sets the PROCID to 0.
- When the semaphore is locked:
A read with a valid AHB bus master ID and SEC and PRIV returns the PROCID of the AHB bus master that has locked the semaphore.</description>
                <bitOffset>0</bitOffset>
                <bitWidth>8</bitWidth>
                <access>read-only</access>
              </field>
              <field>
                <name>LOCKID</name>
                <description>Semaphore LOCKID
This field is read only by software at this address.
On a read, when the semaphore is free, the hardware sets the LOCKID to the AHB bus master ID reading the semaphore. The LOCKID of the AHB bus master locking the semaphore is read.
On a read when the semaphore is locked, this field returns the LOCKID of the AHB bus master that has locked the semaphore.</description>
                <bitOffset>8</bitOffset>
                <bitWidth>4</bitWidth>
                <access>read-only</access>
              </field>
              <field>
                <name>SEC</name>
                <description>Semaphore secure.
This field is read only by software at this address.
- When the semaphore is free:
A read with a valid AHB bus master ID and SEC and PRIV locks the semaphore and hardware sets the SEC to the valid AHB bus master security definition.
- When the semaphore is locked:
A read with a valid AHB bus master ID and SEC and PRIV returns the SEC of the AHB bus master that has locked the semaphore.</description>
                <bitOffset>12</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Semaphore free or locked by non-secure compartment.</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Semaphore locked by secure compartment.</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>PRIV</name>
                <description>Semaphore privilege
This field is read only by software at this address.
- When the semaphore is free:
A read with a valid AHB bus master ID and SEC and PRIV locks the semaphore and hardware sets the PRIV to the valid AHB bus master privileged definition.
- When the semaphore is locked:
A read with a valid AHB bus master ID and SEC and PRIV returns the PRIV of the AHB bus master that has locked the semaphore.</description>
                <bitOffset>13</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Semaphore free or locked by unprivileged compartment.</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Semaphore locked by privileged compartment.</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>LOCK</name>
                <description>Lock indication
This bit is read only by software at this address. 
- When the semaphore is free:
A read with a valid AHB bus master ID and SEC and PRIV locks the semaphore and returns 1.
- When the semaphore is locked:
A read with a valid AHB bus master ID and SEC and PRIV returns 1 (the LOCKID and SEC and PRIV and PROCID reflect the already locked semaphore information).</description>
                <bitOffset>31</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-only</access>
              </field>
            </fields>
          </register>
          <register>
            <name>HSEM_RLR12</name>
            <displayName>HSEM_RLR12</displayName>
            <description>HSEM read lock register semaphore 12</description>
            <addressOffset>0xB0</addressOffset>
            <size>0x20</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>PROCID</name>
                <description>Semaphore processor ID
This field is read only by software at this address.
- On a read when the semaphore is free:
A read with a valid AHB bus master ID and SEC and PRIV locks the semaphore and hardware sets the PROCID to 0.
- When the semaphore is locked:
A read with a valid AHB bus master ID and SEC and PRIV returns the PROCID of the AHB bus master that has locked the semaphore.</description>
                <bitOffset>0</bitOffset>
                <bitWidth>8</bitWidth>
                <access>read-only</access>
              </field>
              <field>
                <name>LOCKID</name>
                <description>Semaphore LOCKID
This field is read only by software at this address.
On a read, when the semaphore is free, the hardware sets the LOCKID to the AHB bus master ID reading the semaphore. The LOCKID of the AHB bus master locking the semaphore is read.
On a read when the semaphore is locked, this field returns the LOCKID of the AHB bus master that has locked the semaphore.</description>
                <bitOffset>8</bitOffset>
                <bitWidth>4</bitWidth>
                <access>read-only</access>
              </field>
              <field>
                <name>SEC</name>
                <description>Semaphore secure.
This field is read only by software at this address.
- When the semaphore is free:
A read with a valid AHB bus master ID and SEC and PRIV locks the semaphore and hardware sets the SEC to the valid AHB bus master security definition.
- When the semaphore is locked:
A read with a valid AHB bus master ID and SEC and PRIV returns the SEC of the AHB bus master that has locked the semaphore.</description>
                <bitOffset>12</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Semaphore free or locked by non-secure compartment.</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Semaphore locked by secure compartment.</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>PRIV</name>
                <description>Semaphore privilege
This field is read only by software at this address.
- When the semaphore is free:
A read with a valid AHB bus master ID and SEC and PRIV locks the semaphore and hardware sets the PRIV to the valid AHB bus master privileged definition.
- When the semaphore is locked:
A read with a valid AHB bus master ID and SEC and PRIV returns the PRIV of the AHB bus master that has locked the semaphore.</description>
                <bitOffset>13</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Semaphore free or locked by unprivileged compartment.</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Semaphore locked by privileged compartment.</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>LOCK</name>
                <description>Lock indication
This bit is read only by software at this address. 
- When the semaphore is free:
A read with a valid AHB bus master ID and SEC and PRIV locks the semaphore and returns 1.
- When the semaphore is locked:
A read with a valid AHB bus master ID and SEC and PRIV returns 1 (the LOCKID and SEC and PRIV and PROCID reflect the already locked semaphore information).</description>
                <bitOffset>31</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-only</access>
              </field>
            </fields>
          </register>
          <register>
            <name>HSEM_RLR13</name>
            <displayName>HSEM_RLR13</displayName>
            <description>HSEM read lock register semaphore 13</description>
            <addressOffset>0xB4</addressOffset>
            <size>0x20</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>PROCID</name>
                <description>Semaphore processor ID
This field is read only by software at this address.
- On a read when the semaphore is free:
A read with a valid AHB bus master ID and SEC and PRIV locks the semaphore and hardware sets the PROCID to 0.
- When the semaphore is locked:
A read with a valid AHB bus master ID and SEC and PRIV returns the PROCID of the AHB bus master that has locked the semaphore.</description>
                <bitOffset>0</bitOffset>
                <bitWidth>8</bitWidth>
                <access>read-only</access>
              </field>
              <field>
                <name>LOCKID</name>
                <description>Semaphore LOCKID
This field is read only by software at this address.
On a read, when the semaphore is free, the hardware sets the LOCKID to the AHB bus master ID reading the semaphore. The LOCKID of the AHB bus master locking the semaphore is read.
On a read when the semaphore is locked, this field returns the LOCKID of the AHB bus master that has locked the semaphore.</description>
                <bitOffset>8</bitOffset>
                <bitWidth>4</bitWidth>
                <access>read-only</access>
              </field>
              <field>
                <name>SEC</name>
                <description>Semaphore secure.
This field is read only by software at this address.
- When the semaphore is free:
A read with a valid AHB bus master ID and SEC and PRIV locks the semaphore and hardware sets the SEC to the valid AHB bus master security definition.
- When the semaphore is locked:
A read with a valid AHB bus master ID and SEC and PRIV returns the SEC of the AHB bus master that has locked the semaphore.</description>
                <bitOffset>12</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Semaphore free or locked by non-secure compartment.</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Semaphore locked by secure compartment.</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>PRIV</name>
                <description>Semaphore privilege
This field is read only by software at this address.
- When the semaphore is free:
A read with a valid AHB bus master ID and SEC and PRIV locks the semaphore and hardware sets the PRIV to the valid AHB bus master privileged definition.
- When the semaphore is locked:
A read with a valid AHB bus master ID and SEC and PRIV returns the PRIV of the AHB bus master that has locked the semaphore.</description>
                <bitOffset>13</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Semaphore free or locked by unprivileged compartment.</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Semaphore locked by privileged compartment.</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>LOCK</name>
                <description>Lock indication
This bit is read only by software at this address. 
- When the semaphore is free:
A read with a valid AHB bus master ID and SEC and PRIV locks the semaphore and returns 1.
- When the semaphore is locked:
A read with a valid AHB bus master ID and SEC and PRIV returns 1 (the LOCKID and SEC and PRIV and PROCID reflect the already locked semaphore information).</description>
                <bitOffset>31</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-only</access>
              </field>
            </fields>
          </register>
          <register>
            <name>HSEM_RLR14</name>
            <displayName>HSEM_RLR14</displayName>
            <description>HSEM read lock register semaphore 14</description>
            <addressOffset>0xB8</addressOffset>
            <size>0x20</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>PROCID</name>
                <description>Semaphore processor ID
This field is read only by software at this address.
- On a read when the semaphore is free:
A read with a valid AHB bus master ID and SEC and PRIV locks the semaphore and hardware sets the PROCID to 0.
- When the semaphore is locked:
A read with a valid AHB bus master ID and SEC and PRIV returns the PROCID of the AHB bus master that has locked the semaphore.</description>
                <bitOffset>0</bitOffset>
                <bitWidth>8</bitWidth>
                <access>read-only</access>
              </field>
              <field>
                <name>LOCKID</name>
                <description>Semaphore LOCKID
This field is read only by software at this address.
On a read, when the semaphore is free, the hardware sets the LOCKID to the AHB bus master ID reading the semaphore. The LOCKID of the AHB bus master locking the semaphore is read.
On a read when the semaphore is locked, this field returns the LOCKID of the AHB bus master that has locked the semaphore.</description>
                <bitOffset>8</bitOffset>
                <bitWidth>4</bitWidth>
                <access>read-only</access>
              </field>
              <field>
                <name>SEC</name>
                <description>Semaphore secure.
This field is read only by software at this address.
- When the semaphore is free:
A read with a valid AHB bus master ID and SEC and PRIV locks the semaphore and hardware sets the SEC to the valid AHB bus master security definition.
- When the semaphore is locked:
A read with a valid AHB bus master ID and SEC and PRIV returns the SEC of the AHB bus master that has locked the semaphore.</description>
                <bitOffset>12</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Semaphore free or locked by non-secure compartment.</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Semaphore locked by secure compartment.</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>PRIV</name>
                <description>Semaphore privilege
This field is read only by software at this address.
- When the semaphore is free:
A read with a valid AHB bus master ID and SEC and PRIV locks the semaphore and hardware sets the PRIV to the valid AHB bus master privileged definition.
- When the semaphore is locked:
A read with a valid AHB bus master ID and SEC and PRIV returns the PRIV of the AHB bus master that has locked the semaphore.</description>
                <bitOffset>13</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Semaphore free or locked by unprivileged compartment.</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Semaphore locked by privileged compartment.</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>LOCK</name>
                <description>Lock indication
This bit is read only by software at this address. 
- When the semaphore is free:
A read with a valid AHB bus master ID and SEC and PRIV locks the semaphore and returns 1.
- When the semaphore is locked:
A read with a valid AHB bus master ID and SEC and PRIV returns 1 (the LOCKID and SEC and PRIV and PROCID reflect the already locked semaphore information).</description>
                <bitOffset>31</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-only</access>
              </field>
            </fields>
          </register>
          <register>
            <name>HSEM_RLR15</name>
            <displayName>HSEM_RLR15</displayName>
            <description>HSEM read lock register semaphore 15</description>
            <addressOffset>0xBC</addressOffset>
            <size>0x20</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>PROCID</name>
                <description>Semaphore processor ID
This field is read only by software at this address.
- On a read when the semaphore is free:
A read with a valid AHB bus master ID and SEC and PRIV locks the semaphore and hardware sets the PROCID to 0.
- When the semaphore is locked:
A read with a valid AHB bus master ID and SEC and PRIV returns the PROCID of the AHB bus master that has locked the semaphore.</description>
                <bitOffset>0</bitOffset>
                <bitWidth>8</bitWidth>
                <access>read-only</access>
              </field>
              <field>
                <name>LOCKID</name>
                <description>Semaphore LOCKID
This field is read only by software at this address.
On a read, when the semaphore is free, the hardware sets the LOCKID to the AHB bus master ID reading the semaphore. The LOCKID of the AHB bus master locking the semaphore is read.
On a read when the semaphore is locked, this field returns the LOCKID of the AHB bus master that has locked the semaphore.</description>
                <bitOffset>8</bitOffset>
                <bitWidth>4</bitWidth>
                <access>read-only</access>
              </field>
              <field>
                <name>SEC</name>
                <description>Semaphore secure.
This field is read only by software at this address.
- When the semaphore is free:
A read with a valid AHB bus master ID and SEC and PRIV locks the semaphore and hardware sets the SEC to the valid AHB bus master security definition.
- When the semaphore is locked:
A read with a valid AHB bus master ID and SEC and PRIV returns the SEC of the AHB bus master that has locked the semaphore.</description>
                <bitOffset>12</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Semaphore free or locked by non-secure compartment.</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Semaphore locked by secure compartment.</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>PRIV</name>
                <description>Semaphore privilege
This field is read only by software at this address.
- When the semaphore is free:
A read with a valid AHB bus master ID and SEC and PRIV locks the semaphore and hardware sets the PRIV to the valid AHB bus master privileged definition.
- When the semaphore is locked:
A read with a valid AHB bus master ID and SEC and PRIV returns the PRIV of the AHB bus master that has locked the semaphore.</description>
                <bitOffset>13</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Semaphore free or locked by unprivileged compartment.</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Semaphore locked by privileged compartment.</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>LOCK</name>
                <description>Lock indication
This bit is read only by software at this address. 
- When the semaphore is free:
A read with a valid AHB bus master ID and SEC and PRIV locks the semaphore and returns 1.
- When the semaphore is locked:
A read with a valid AHB bus master ID and SEC and PRIV returns 1 (the LOCKID and SEC and PRIV and PROCID reflect the already locked semaphore information).</description>
                <bitOffset>31</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-only</access>
              </field>
            </fields>
          </register>
          <register>
            <name>HSEM_IER</name>
            <displayName>HSEM_IER</displayName>
            <description>HSEM non-secure interrupt enable register</description>
            <addressOffset>0x100</addressOffset>
            <size>0x20</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>ISE</name>
                <description>Non-secure Interrupt semaphore x enable bit
This bit is read and written by software.
When semaphore x SECx is disabled, bit x can be accessed with secure and non-secure access.
When semaphore x SECx is enabled, bit x is forced to 0 and cannot be accessed, write to this bit is discarded and a read returns 0.
When semaphore x PRIVx is disabled, bit x can be accessed with privilege and unprivileged access.
When semaphore x PRIVx is enabled, bit x can be accessed only with privileged access. Unprivileged write to this bit is discarded, unprivileged read returns 0.</description>
                <bitOffset>0</bitOffset>
                <bitWidth>16</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Non-secure Interrupt generation for semaphore x disabled (masked)</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Non-secure Interrupt generation for semaphore x enabled (not masked)</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
            </fields>
          </register>
          <register>
            <name>HSEM_ICR</name>
            <displayName>HSEM_ICR</displayName>
            <description>HSEM non-secure interrupt clear register</description>
            <addressOffset>0x104</addressOffset>
            <size>0x20</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>ISC</name>
                <description>Non-secure Interrupt semaphore x clear bit
This bit is written by software, and is always read 0.
When semaphore x SECx is disabled, bit x can be accessed with secure and non-secure access.
When semaphore x SECx is enabled, bit x cannot be accessed, write to this bit is discarded.
When semaphore x PRIVx is disabled, bit x can be accessed with privileged and unprivileged access.
When semaphore x PRIVx is enabled, bit x can only be accessed with privileged access. Unprivileged write to this bit is discarded.</description>
                <bitOffset>0</bitOffset>
                <bitWidth>16</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>non-secure Interrupt semaphore x status ISFx and masked status MISFx not affected.</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>non-secure Interrupt semaphore x status ISFx and masked status MISFx cleared.</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
            </fields>
          </register>
          <register>
            <name>HSEM_ISR</name>
            <displayName>HSEM_ISR</displayName>
            <description>HSEM non-secure interrupt status register</description>
            <addressOffset>0x108</addressOffset>
            <size>0x20</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>ISF</name>
                <description>Interrupt semaphore x status bit before enable (mask)
This bit is set by hardware, and reset only by software. This bit is cleared by software writing the corresponding HSEM_ICR bit.</description>
                <bitOffset>0</bitOffset>
                <bitWidth>16</bitWidth>
                <access>read-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Interrupt semaphore x status, no interrupt pending</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Interrupt semaphore x status, interrupt pending</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
            </fields>
          </register>
          <register>
            <name>HSEM_MISR</name>
            <displayName>HSEM_MISR</displayName>
            <description>HSEM non-secure interrupt status register</description>
            <addressOffset>0x10C</addressOffset>
            <size>0x20</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>MISF</name>
                <description>Masked non-secure interrupt semaphore x status bit after enable (mask)
This bit is set by hardware and read only by software. This bit is cleared by software writing the corresponding HSEM_ICR bit. This bit is read as 0 when semaphore x status is masked in HSEM_IER bit x.
When semaphore x SECx is disabled, bit x can be accessed with secure and non-secure access.
When semaphore x SECx is enabled, bit x cannot be accessed, read returns 0.
When semaphore x PRIVx is disabled, bit x can be accessed with privileged and unprivileged access.
When semaphore x PRIVx is enabled, bit x can be accessed only with privileged access. Unprivileged read returns 0.</description>
                <bitOffset>0</bitOffset>
                <bitWidth>16</bitWidth>
                <access>read-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>non-secure interrupt semaphore x status after masking not pending</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>non-secure interrupt semaphore x status after masking pending</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
            </fields>
          </register>
          <register>
            <name>HSEM_SIER</name>
            <displayName>HSEM_SIER</displayName>
            <description>HSEM secure interrupt enable register</description>
            <addressOffset>0x180</addressOffset>
            <size>0x20</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>SISE</name>
                <description>Secure interrupt semaphore x enable bit
This bit is read and written by software.
When semaphore x PRIVx is disabled, bit x can be accessed with secure privilege and secure unprivileged access.
When semaphore x PRIVx is enabled, bit x can be accessed only with secure privilege access. secure unprivileged write to this bit is discarded, secure unprivileged read return 0 value.</description>
                <bitOffset>0</bitOffset>
                <bitWidth>16</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Secure interrupt generation for semaphore x is disabled (masked).</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Secure interrupt generation for semaphore x is enabled (not masked).</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
            </fields>
          </register>
          <register>
            <name>HSEM_SICR</name>
            <displayName>HSEM_SICR</displayName>
            <description>HSEM secure interrupt clear register</description>
            <addressOffset>0x184</addressOffset>
            <size>0x20</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>SISC</name>
                <description>Secure interrupt semaphore x clear bit
This bit is written by software, and is always read 0.
When semaphore x PRIVx is disabled, bit x can be accessed with secure privilege and secure unprivileged access.
When semaphore x PRIVx is enabled, bit x can be accessed only with secure privilege access. Secure unprivileged write to this bit is discarded.</description>
                <bitOffset>0</bitOffset>
                <bitWidth>16</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Secure interrupt semaphore x status ISFx and masked status MISFx not affected.</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Secure interrupt semaphore x status ISFx and masked status MISFx cleared.</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
            </fields>
          </register>
          <register>
            <name>HSEM_SISR</name>
            <displayName>HSEM_SISR</displayName>
            <description>HSEM secure interrupt status register</description>
            <addressOffset>0x188</addressOffset>
            <size>0x20</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>SISF</name>
                <description>Secure interrupt semaphore x status bit before enable (mask)
This bit is set by hardware and read only by software.
Bit is cleared by software writing the corresponding HSEM_SCnICR bit x.
When semaphore x PRIVx is disabled, bit x can be accessed with secure privilege and secure unprivileged access.
When semaphore x PRIVx is enabled, bit x can be accessed only with secure privilege access. Secure unprivileged read return 0 value.</description>
                <bitOffset>0</bitOffset>
                <bitWidth>16</bitWidth>
                <access>read-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Secure interrupt semaphore x status, no interrupt pending.</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Secure interrupt semaphore x status, interrupt pending.</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
            </fields>
          </register>
          <register>
            <name>HSEM_MSISR</name>
            <displayName>HSEM_MSISR</displayName>
            <description>HSEM secure masked interrupt status register</description>
            <addressOffset>0x18C</addressOffset>
            <size>0x20</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>SMISF</name>
                <description>Secure masked interrupt semaphore x status bit after enable (mask)
This bit is set by hardware and read only by software.
Bit is cleared by software writing the corresponding HSEM_SCnICR bit x.
Bit is read as 0 when semaphore x status is masked in HSEM_SCnIER bit x.
When semaphore x PRIVx is disabled, bit x can be accessed with secure privilege and secure unprivileged access.
When semaphore x PRIVx is enabled, bit x can be accessed only with secure privilege access. Secure unprivileged read return 0 value.</description>
                <bitOffset>0</bitOffset>
                <bitWidth>16</bitWidth>
                <access>read-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Secure interrupt semaphore x status after masking not pending.</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Secure interrupt semaphore x status after masking pending.</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
            </fields>
          </register>
          <register>
            <name>HSEM_SECCFGR</name>
            <displayName>HSEM_SECCFGR</displayName>
            <description>HSEM security configuration register</description>
            <addressOffset>0x200</addressOffset>
            <size>0x20</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>SEC</name>
                <description>Semaphore x security attribute
This bit is set and cleared by software.</description>
                <bitOffset>0</bitOffset>
                <bitWidth>16</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Semaphore x non-security, can be accessed by both secure and non-secure processors. When unlocking semaphore x both a secure and non-secure interrupt can be generated.</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Semaphore x security, can be accessed only by secure processors. When unlocking semaphore x only a secure interrupt can be generated.</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
            </fields>
          </register>
          <register>
            <name>HSEM_PRIVCFGR</name>
            <displayName>HSEM_PRIVCFGR</displayName>
            <description>HSEM privilege configuration register</description>
            <addressOffset>0x210</addressOffset>
            <size>0x20</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>PRIV</name>
                <description>Semaphore x privilege attribute
This bit is set and cleared by software.
When semaphore x SECx is disabled, bit x can be write accessed with secure privileged and non-secure privileged access.
When semaphore x SECx is enabled, bit x can only be write accessed with secure privilege access. Non-secure privileged write access is discarded. Both secure and non-secure read return the register bit x value</description>
                <bitOffset>0</bitOffset>
                <bitWidth>16</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Semaphore x unprivileged, can be accessed by both privileged and unprivileged processors.</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Semaphore x privileged, can be accessed only by privileged processors.</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
            </fields>
          </register>
          <register>
            <name>HSEM_CR</name>
            <displayName>HSEM_CR</displayName>
            <description>HSEM clear register</description>
            <addressOffset>0x230</addressOffset>
            <size>0x20</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>LOCKID</name>
                <description>LOCKID of semaphores to be cleared
This field can be written by software and is always read 0.
This field indicates the LOCKID for which the semaphores are cleared when writing the HSEM_CR.</description>
                <bitOffset>8</bitOffset>
                <bitWidth>4</bitWidth>
                <access>write-only</access>
              </field>
              <field>
                <name>SEC</name>
                <description>SEC value of semaphores to be cleared.
This field can be written by software, is always read 0.
Indicates the SEC for which the CID semaphores are cleared when writing the HSEM_CR</description>
                <bitOffset>12</bitOffset>
                <bitWidth>1</bitWidth>
                <access>write-only</access>
              </field>
              <field>
                <name>PRIV</name>
                <description>PRIV value of semaphores to be cleared.
This field can be written by software, is always read 0.
Indicates the PRIV for which the CID semaphores are cleared when writing the HSEM_CR.</description>
                <bitOffset>13</bitOffset>
                <bitWidth>1</bitWidth>
                <access>write-only</access>
              </field>
              <field>
                <name>KEY</name>
                <description>Semaphore clear key
This field can be written by software and is always read 0.
If this key value does not match HSEM_KEYR.KEY, semaphores are not affected.
If this key value matches HSEM_KEYR.KEY, all semaphores matching the LOCKID are cleared to the free state.</description>
                <bitOffset>16</bitOffset>
                <bitWidth>16</bitWidth>
                <access>write-only</access>
              </field>
            </fields>
          </register>
          <register>
            <name>HSEM_KEYR</name>
            <displayName>HSEM_KEYR</displayName>
            <description>HSEM interrupt clear register</description>
            <addressOffset>0x234</addressOffset>
            <size>0x20</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>KEY</name>
                <description>Semaphore clear key
This field can be written and read by software.
Key value to match when clearing semaphores.</description>
                <bitOffset>16</bitOffset>
                <bitWidth>16</bitWidth>
                <access>read-write</access>
              </field>
            </fields>
          </register>
        </registers>
    </peripheral>
	<peripheral derivedFrom="HSEM">
        <name>SEC_HSEM</name>
        <baseAddress>0x520C1C00</baseAddress>
    </peripheral>
	<peripheral>
        <name>IWDG</name>
        <description>Independent watchdog</description>
        <groupName>IWDG</groupName>
        <baseAddress>0x40003000</baseAddress>
        <addressBlock>
          <offset>0x0</offset>
          <size>0x400</size>
          <usage>registers</usage>
        </addressBlock>
        <registers>
          <register>
            <name>IWDG_KR</name>
            <displayName>IWDG_KR</displayName>
            <description>IWDG key register</description>
            <addressOffset>0x00</addressOffset>
            <size>0x20</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>KEY</name>
                <description>Key value (write only, read 0x0000)
These bits must be written by software at regular intervals with the key value 0xAAAA, otherwise the watchdog generates a reset when the counter reaches 0.
Writing the key value 0x5555 to enable access to the IWDG_PR, IWDG_RLR and IWDG_WINR registers (see Section 29.4.6: Register access protection)
Writing the key value 0xCCCC starts the watchdog (except if the hardware watchdog option is selected)</description>
                <bitOffset>0</bitOffset>
                <bitWidth>16</bitWidth>
                <access>write-only</access>
              </field>
            </fields>
          </register>
          <register>
            <name>IWDG_PR</name>
            <displayName>IWDG_PR</displayName>
            <description>IWDG prescaler register</description>
            <addressOffset>0x04</addressOffset>
            <size>0x20</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>PR</name>
                <description>Prescaler divider 
These bits are write access protected see Section 29.4.6: Register access protection. They are written by software to select the prescaler divider feeding the counter clock. PVU bit of the IWDG status register (IWDG_SR) must be reset in order to be able to change the prescaler divider.
Others: divider / 1024
Note: Reading this register returns the prescaler value from the V&lt;sub&gt;DD&lt;/sub&gt; voltage domain. This value may not be up to date/valid if a write operation to this register is ongoing. For this reason the value read from this register is valid only when the PVU bit in the IWDG status register (IWDG_SR) is reset.</description>
                <bitOffset>0</bitOffset>
                <bitWidth>4</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>divider / 4</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>divider / 8</description>
                    <value>0x1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x2</name>
                    <description>divider / 16</description>
                    <value>0x2</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x3</name>
                    <description>divider / 32</description>
                    <value>0x3</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x4</name>
                    <description>divider / 64</description>
                    <value>0x4</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x5</name>
                    <description>divider / 128</description>
                    <value>0x5</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x6</name>
                    <description>divider / 256</description>
                    <value>0x6</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x7</name>
                    <description>divider / 512</description>
                    <value>0x7</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
            </fields>
          </register>
          <register>
            <name>IWDG_RLR</name>
            <displayName>IWDG_RLR</displayName>
            <description>IWDG reload register</description>
            <addressOffset>0x08</addressOffset>
            <size>0x20</size>
            <resetValue>0x00000FFF</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>RL</name>
                <description>Watchdog counter reload value 
These bits are write access protected see Register access protection. They are written by software to define the value to be loaded in the watchdog counter each time the value 0xAAAA is written in the IWDG key register (IWDG_KR). The watchdog counter counts down from this value. The timeout period is a function of this value and the prescaler.clock. It is not recommended to set RL[11:0] to a value lower than 2.
The RVU bit in the IWDG status register (IWDG_SR) must be reset to be able to change the reload value.
Note: Reading this register returns the reload value from the V&lt;sub&gt;DD&lt;/sub&gt; voltage domain. This value may not be up to date/valid if a write operation to this register is ongoing on it. For this reason the value read from this register is valid only when the RVU bit in the IWDG status register (IWDG_SR) is reset.</description>
                <bitOffset>0</bitOffset>
                <bitWidth>12</bitWidth>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>IWDG_SR</name>
            <displayName>IWDG_SR</displayName>
            <description>IWDG status register</description>
            <addressOffset>0x0C</addressOffset>
            <size>0x20</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>PVU</name>
                <description>Watchdog prescaler value update
This bit is set by hardware to indicate that an update of the prescaler value is ongoing. It is reset by hardware when the prescaler update operation is completed in the V&lt;sub&gt;DD&lt;/sub&gt; voltage domain (takes up to three periods of the IWDG kernel clock iwdg_ker_ck).
The prescaler value can be updated only when PVU bit is reset.</description>
                <bitOffset>0</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-only</access>
              </field>
              <field>
                <name>RVU</name>
                <description>Watchdog counter reload value update
This bit is set by hardware to indicate that an update of the reload value is ongoing. It is reset by hardware when the reload value update operation is completed in the V&lt;sub&gt;DD&lt;/sub&gt; voltage domain (takes up to three periods of the IWDG kernel clock iwdg_ker_ck).
The reload value can be updated only when RVU bit is reset.</description>
                <bitOffset>1</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-only</access>
              </field>
              <field>
                <name>WVU</name>
                <description>Watchdog counter window value update
This bit is set by hardware to indicate that an update of the window value is ongoing. It is reset by hardware when the reload value update operation is completed in the V&lt;sub&gt;DD&lt;/sub&gt; voltage domain (takes up to three periods of the IWDG kernel clock iwdg_ker_ck).
The window value can be updated only when WVU bit is reset.
This bit is generated only if generic window = 1</description>
                <bitOffset>2</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-only</access>
              </field>
              <field>
                <name>EWU</name>
                <description>Watchdog interrupt comparator value update 
This bit is set by hardware to indicate that an update of the interrupt comparator value (EWIT[11:0]) or an update of the EWIE is ongoing. It is reset by hardware when the update operation is completed in the V&lt;sub&gt;DD&lt;/sub&gt; voltage domain (takes up to three periods of the IWDG kernel clock iwdg_ker_ck).
The EWIT[11:0] and EWIE fields can be updated only when EWU bit is reset.</description>
                <bitOffset>3</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-only</access>
              </field>
              <field>
                <name>ONF</name>
                <description>Watchdog enable status bit
Set to 1 by hardware as soon as the IWDG is started, remains to 1 until the IWDG is reset.</description>
                <bitOffset>8</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>The IWDG is not activated</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>The IWDG is activated and needs to be refreshed regularly by the application</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>EWIF</name>
                <description>Watchdog early interrupt flag
This bit is set to 1 by hardware in order to indicate that an early interrupt is pending. This bit must be cleared by the software by writing the bit EWIC of IWDG_EWCR register to 1.</description>
                <bitOffset>14</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-only</access>
              </field>
            </fields>
          </register>
          <register>
            <name>IWDG_WINR</name>
            <displayName>IWDG_WINR</displayName>
            <description>IWDG window register</description>
            <addressOffset>0x10</addressOffset>
            <size>0x20</size>
            <resetValue>0x00000FFF</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>WIN</name>
                <description>Watchdog counter window value 
These bits are write access protected, see Section 29.4.6, they contain the high limit of the window value to be compared with the downcounter.
To prevent a reset, the IWDCNT downcounter must be reloaded when its value is lower than WIN[11:0]+1 and greater than 1.
The WVU bit in the IWDG status register (IWDG_SR) must be reset to be able to change the reload value.
Note: Reading this register returns the reload value from the V&lt;sub&gt;DD&lt;/sub&gt; voltage domain. This value may not be valid if a write operation to this register is ongoing. For this reason the value read from this register is valid only when the WVU bit in the IWDG status register (IWDG_SR) is reset.</description>
                <bitOffset>0</bitOffset>
                <bitWidth>12</bitWidth>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>IWDG_EWCR</name>
            <displayName>IWDG_EWCR</displayName>
            <description>IWDG early wakeup interrupt register</description>
            <addressOffset>0x14</addressOffset>
            <size>0x20</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>EWIT</name>
                <description>Watchdog counter window value 
These bits are write access protected (see Section 29.4.6). They are written by software to define at which position of the IWDCNT down-counter the early wakeup interrupt must be generated. The early interrupt is generated when the IWDCNT is lower or equal to EWIT[11:0] - 1.
EWIT[11:0] must be bigger than 1.
An interrupt is generated only if EWIE = 1.
The EWU bit in the IWDG status register (IWDG_SR) must be reset to be able to change the reload value.
Note: Reading this register returns the Early wakeup comparator value and the Interrupt enable bit from the V&lt;sub&gt;DD&lt;/sub&gt; voltage domain. This value may not be up to date/valid if a write operation to this register is ongoing, hence the value read from this register is valid only when the EWU bit in the IWDG status register (IWDG_SR) is reset.</description>
                <bitOffset>0</bitOffset>
                <bitWidth>12</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>EWIC</name>
                <description>Watchdog early interrupt acknowledge 
The software must write a 1 into this bit in order to acknowledge the early wakeup interrupt and to clear the EWIF flag. Writing 0 has not effect, reading this flag returns a 0.</description>
                <bitOffset>14</bitOffset>
                <bitWidth>1</bitWidth>
                <access>write-only</access>
              </field>
              <field>
                <name>EWIE</name>
                <description>Watchdog early interrupt enable
Set and reset by software.
The EWU bit in the IWDG status register (IWDG_SR) must be reset to be able to change the value of this bit.</description>
                <bitOffset>15</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>The early interrupt interface is disabled.</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>The early interrupt interface is enabled.</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
            </fields>
          </register>
        </registers>
    </peripheral>
	<peripheral derivedFrom="IWDG">
      <name>SEC_IWDG</name>
      <baseAddress>0x50003000</baseAddress>
    </peripheral>
	<peripheral>
        <name>I2C1</name>
        <description>Inter-integrated circuit</description>
        <groupName>I2C</groupName>
        <baseAddress>0x40005400</baseAddress>
        <addressBlock>
          <offset>0x0</offset>
          <size>0x400</size>
          <usage>registers</usage>
        </addressBlock>
        <interrupt>
          <name>I2C1_EV</name>
          <description>I2C1 event interrupt</description>
          <value>43</value>
        </interrupt>
        <interrupt>
          <name>I2C1_ER</name>
          <description>I2C1 error interrupt</description>
          <value>44</value>
        </interrupt>
        <registers>
          <register>
            <name>I2C_CR1</name>
            <displayName>I2C_CR1</displayName>
            <description>I2C control register 1</description>
            <addressOffset>0x00</addressOffset>
            <size>0x20</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>PE</name>
                <description>Peripheral enable
Note: When PE = 0, the I2C SCL and SDA lines are released. Internal state machines and status bits are put back to their reset value. When cleared, PE must be kept low for at least 3 APB clock cycles.</description>
                <bitOffset>0</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Peripheral disable</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Peripheral enable</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>TXIE</name>
                <description>TX Interrupt enable</description>
                <bitOffset>1</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Transmit (TXIS) interrupt disabled</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Transmit (TXIS) interrupt enabled</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>RXIE</name>
                <description>RX Interrupt enable</description>
                <bitOffset>2</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Receive (RXNE) interrupt disabled</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Receive (RXNE) interrupt enabled</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>ADDRIE</name>
                <description>Address match Interrupt enable (slave only)</description>
                <bitOffset>3</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Address match (ADDR) interrupts disabled</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Address match (ADDR) interrupts enabled</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>NACKIE</name>
                <description>Not acknowledge received Interrupt enable</description>
                <bitOffset>4</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Not acknowledge (NACKF) received interrupts disabled</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Not acknowledge (NACKF) received interrupts enabled</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>STOPIE</name>
                <description>Stop detection Interrupt enable</description>
                <bitOffset>5</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Stop detection (STOPF) interrupt disabled</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Stop detection (STOPF) interrupt enabled</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>TCIE</name>
                <description>Transfer Complete interrupt enable 
Note: Any of these events generate an interrupt:
Note: Transfer Complete (TC)
Note: Transfer Complete Reload (TCR)</description>
                <bitOffset>6</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Transfer Complete interrupt disabled</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Transfer Complete interrupt enabled</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>ERRIE</name>
                <description>Error interrupts enable
Note: Any of these errors generate an interrupt:
Note: Arbitration Loss (ARLO)
Note: Bus Error detection (BERR)
Note: Overrun/Underrun (OVR)
Note: Timeout detection (TIMEOUT)
Note: PEC error detection (PECERR)
Note: Alert pin event detection (ALERT)</description>
                <bitOffset>7</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Error detection interrupts disabled</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Error detection interrupts enabled</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>DNF</name>
                <description>Digital noise filter
These bits are used to configure the digital noise filter on SDA and SCL input. The digital filter, filters spikes with a length of up to DNF[3:0] * t&lt;sub&gt;I2CCLK&lt;/sub&gt;
&lt;sub&gt;...&lt;/sub&gt;
Note: If the analog filter is also enabled, the digital filter is added to the analog filter. 
Note: This filter can only be programmed when the I2C is disabled (PE = 0).</description>
                <bitOffset>8</bitOffset>
                <bitWidth>4</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Digital filter disabled</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Digital filter enabled and filtering capability up to 1 t&lt;sub&gt;I2CCLK&lt;/sub&gt;</description>
                    <value>0x1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0xF</name>
                    <description>digital filter enabled and filtering capability up to15 t&lt;sub&gt;I2CCLK&lt;/sub&gt;</description>
                    <value>0xF</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>ANFOFF</name>
                <description>Analog noise filter OFF
Note: This bit can only be programmed when the I2C is disabled (PE = 0).</description>
                <bitOffset>12</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Analog noise filter enabled</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Analog noise filter disabled</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>TXDMAEN</name>
                <description>DMA transmission requests enable</description>
                <bitOffset>14</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>DMA mode disabled for transmission</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>DMA mode enabled for transmission</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>RXDMAEN</name>
                <description>DMA reception requests enable</description>
                <bitOffset>15</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>DMA mode disabled for reception</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>DMA mode enabled for reception</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>SBC</name>
                <description>Slave byte control
This bit is used to enable hardware byte control in slave mode.</description>
                <bitOffset>16</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Slave byte control disabled</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Slave byte control enabled</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>NOSTRETCH</name>
                <description>Clock stretching disable 
This bit is used to disable clock stretching in slave mode. It must be kept cleared in master mode.
Note: This bit can only be programmed when the I2C is disabled (PE = 0).</description>
                <bitOffset>17</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Clock stretching enabled</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Clock stretching disabled</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>WUPEN</name>
                <description>Wakeup from Stop mode enable
Note: If the Wakeup from Stop mode feature is not supported, this bit is reserved and forced by hardware to 0. Refer to Section 52.3: FMPI2C implementation.
Note: WUPEN can be set only when DNF = 0000</description>
                <bitOffset>18</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Wakeup from Stop mode disable.</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Wakeup from Stop mode enable.</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>GCEN</name>
                <description>General call enable</description>
                <bitOffset>19</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>General call disabled. Address 0b00000000 is NACKed.</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>General call enabled. Address 0b00000000 is ACKed.</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>SMBHEN</name>
                <description>SMBus host address enable
Note: If the SMBus feature is not supported, this bit is reserved and forced by hardware to 0. Refer to Section 52.3: FMPI2C implementation.</description>
                <bitOffset>20</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Host address disabled. Address 0b0001000x is NACKed.</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Host address enabled. Address 0b0001000x is ACKed.</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>SMBDEN</name>
                <description>SMBus device default address enable
Note: If the SMBus feature is not supported, this bit is reserved and forced by hardware to 0. Refer to Section 52.3: FMPI2C implementation.</description>
                <bitOffset>21</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Device default address disabled. Address 0b1100001x is NACKed.</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Device default address enabled. Address 0b1100001x is ACKed.</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>ALERTEN</name>
                <description>SMBus alert enable
Note: When ALERTEN=0, the SMBA pin can be used as a standard GPIO.
Note: If the SMBus feature is not supported, this bit is reserved and forced by hardware to 0. Refer to Section 52.3: FMPI2C implementation.</description>
                <bitOffset>22</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>The SMBus alert pin (SMBA) is not supported in host mode (SMBHEN=1). In device mode (SMBHEN=0), the SMBA pin is released and the Alert Response Address header is disabled (0001100x followed by NACK).</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>The SMBus alert pin is supported in host mode (SMBHEN=1). In device mode (SMBHEN=0), the SMBA pin is driven low and the Alert Response Address header is enabled (0001100x followed by ACK).</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>PECEN</name>
                <description>PEC enable
Note: If the SMBus feature is not supported, this bit is reserved and forced by hardware to 0. Refer to Section 52.3: FMPI2C implementation.</description>
                <bitOffset>23</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>PEC calculation disabled</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>PEC calculation enabled</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>FMP</name>
                <description>Fast-mode Plus 20 mA drive enable</description>
                <bitOffset>24</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>20 mA I/O drive disabled</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>20 mA I/O drive enabled</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>ADDRACLR</name>
                <description>Address match flag (ADDR) automatic clear</description>
                <bitOffset>30</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>ADDR flag is set by hardware and cleared by software by setting ADDRCF bit.</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>ADDR flag remains cleared by hardware. This mode can be used in slave mode, to avoid the ADDR clock stretching if the I2C enables only one slave address. This allows a slave data management by DMA only, without any interrupt from peripheral.</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>STOPFACLR</name>
                <description>STOP detection flag (STOPF) automatic clear</description>
                <bitOffset>31</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>STOPF flag is set by hardware and cleared by software by setting STOPCF bit.</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>STOPF flag remains cleared by hardware. This mode can be used in NOSTRETCH slave mode, to avoid the overrun error if the STOPF flag is not cleared before next data transmission. This allows a slave data management by DMA only, without any interrupt from peripheral.</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
            </fields>
          </register>
          <register>
            <name>I2C_CR2</name>
            <displayName>I2C_CR2</displayName>
            <description>I2C control register 2</description>
            <addressOffset>0x04</addressOffset>
            <size>0x20</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>SADD</name>
                <description>Slave address (master mode)
In 7-bit addressing mode (ADD10 = 0):
SADD[7:1] should be written with the 7-bit slave address to be sent. The bits SADD[9], SADD[8] and SADD[0] are don't care.
In 10-bit addressing mode (ADD10 = 1):
SADD[9:0] should be written with the 10-bit slave address to be sent.
Note: Changing these bits when the START bit is set is not allowed.</description>
                <bitOffset>0</bitOffset>
                <bitWidth>10</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>RD_WRN</name>
                <description>Transfer direction (master mode)
Note: Changing this bit when the START bit is set is not allowed.</description>
                <bitOffset>10</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Master requests a write transfer.</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Master requests a read transfer.</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>ADD10</name>
                <description>10-bit addressing mode (master mode)
Note: Changing this bit when the START bit is set is not allowed.</description>
                <bitOffset>11</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>The master operates in 7-bit addressing mode,</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>The master operates in 10-bit addressing mode</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>HEAD10R</name>
                <description>10-bit address header only read direction (master receiver mode)
Note: Changing this bit when the START bit is set is not allowed.</description>
                <bitOffset>12</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>The master sends the complete 10 bit slave address read sequence: Start + 2 bytes 10bit address in write direction + Restart + 1st 7 bits of the 10 bit address in read direction.</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>The master only sends the 1st 7 bits of the 10 bit address, followed by Read direction.</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>START</name>
                <description>Start generation
This bit is set by software, and cleared by hardware after the Start followed by the address sequence is sent, by an arbitration loss, by an address matched in slave mode, by a timeout error detection, or when PE = 0.
If the I2C is already in master mode with AUTOEND = 0, setting this bit generates a Repeated Start condition when RELOAD=0, after the end of the NBYTES transfer. 
Otherwise setting this bit generates a START condition once the bus is free.
Note: Writing 0 to this bit has no effect.
Note: The START bit can be set even if the bus is BUSY or I2C is in slave mode.
Note: This bit has no effect when RELOAD is set.</description>
                <bitOffset>13</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>No Start generation.</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Restart/Start generation:</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>STOP</name>
                <description>Stop generation (master mode)
The bit is set by software, cleared by hardware when a STOP condition is detected, or when PE = 0.
In Master Mode:
Note: Writing 0 to this bit has no effect.</description>
                <bitOffset>14</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>No Stop generation.</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Stop generation after current byte transfer.</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>NACK</name>
                <description>NACK generation (slave mode)
The bit is set by software, cleared by hardware when the NACK is sent, or when a STOP condition or an Address matched is received, or when PE = 0.
Note: Writing 0 to this bit has no effect.
Note: This bit is used in slave mode only: in master receiver mode, NACK is automatically generated after last byte preceding STOP or RESTART condition, whatever the NACK bit value.
Note: When an overrun occurs in slave receiver NOSTRETCH mode, a NACK is automatically generated whatever the NACK bit value.
Note: When hardware PEC checking is enabled (PECBYTE=1), the PEC acknowledge value does not depend on the NACK value.</description>
                <bitOffset>15</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>an ACK is sent after current received byte.</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>a NACK is sent after current received byte.</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>NBYTES</name>
                <description>Number of bytes
The number of bytes to be transmitted/received is programmed there. This field is dont care in slave mode with SBC=0.
Note: Changing these bits when the START bit is set is not allowed.</description>
                <bitOffset>16</bitOffset>
                <bitWidth>8</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>RELOAD</name>
                <description>NBYTES reload mode
This bit is set and cleared by software.</description>
                <bitOffset>24</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>The transfer is completed after the NBYTES data transfer (STOP or RESTART follows).</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>The transfer is not completed after the NBYTES data transfer (NBYTES is reloaded). TCR flag is set when NBYTES data are transferred, stretching SCL low.</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>AUTOEND</name>
                <description>Automatic end mode (master mode)
This bit is set and cleared by software.
Note: This bit has no effect in slave mode or when the RELOAD bit is set.</description>
                <bitOffset>25</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>software end mode: TC flag is set when NBYTES data are transferred, stretching SCL low.</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Automatic end mode: a STOP condition is automatically sent when NBYTES data are transferred.</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>PECBYTE</name>
                <description>Packet error checking byte
This bit is set by software, and cleared by hardware when the PEC is transferred, or when a STOP condition or an Address matched is received, also when PE = 0.
Note: Writing 0 to this bit has no effect.
Note: This bit has no effect when RELOAD is set.
Note: This bit has no effect is slave mode when SBC=0.
Note: If the SMBus feature is not supported, this bit is reserved and forced by hardware to 0. Refer to Section 52.3: FMPI2C implementation.</description>
                <bitOffset>26</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>No PEC transfer.</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>PEC transmission/reception is requested</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
            </fields>
          </register>
          <register>
            <name>I2C_OAR1</name>
            <displayName>I2C_OAR1</displayName>
            <description>I2C own address 1 register</description>
            <addressOffset>0x08</addressOffset>
            <size>0x20</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>OA1</name>
                <description>Interface own slave address
7-bit addressing mode: OA1[7:1] contains the 7-bit own slave address. The bits OA1[9], OA1[8] and OA1[0] are don't care. 
10-bit addressing mode: OA1[9:0] contains the 10-bit own slave address.
Note: These bits can be written only when OA1EN=0.</description>
                <bitOffset>0</bitOffset>
                <bitWidth>10</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>OA1MODE</name>
                <description>Own Address 1 10-bit mode
Note: This bit can be written only when OA1EN=0.</description>
                <bitOffset>10</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Own address 1 is a 7-bit address.</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Own address 1 is a 10-bit address.</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>OA1EN</name>
                <description>Own Address 1 enable</description>
                <bitOffset>15</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Own address 1 disabled. The received slave address OA1 is NACKed.</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Own address 1 enabled. The received slave address OA1 is ACKed.</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
            </fields>
          </register>
          <register>
            <name>I2C_OAR2</name>
            <displayName>I2C_OAR2</displayName>
            <description>I2C own address 2 register</description>
            <addressOffset>0x0C</addressOffset>
            <size>0x20</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>OA2</name>
                <description>Interface address
7-bit addressing mode: 7-bit address
Note: These bits can be written only when OA2EN=0.</description>
                <bitOffset>1</bitOffset>
                <bitWidth>7</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>OA2MSK</name>
                <description>Own Address 2 masks
Note: These bits can be written only when OA2EN=0.
Note: As soon as OA2MSK is not equal to 0, the reserved I2C addresses (0b0000xxx and 0b1111xxx) are not acknowledged even if the comparison matches.</description>
                <bitOffset>8</bitOffset>
                <bitWidth>3</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>No mask</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>OA2[1] is masked and dont care. Only OA2[7:2] are compared.</description>
                    <value>0x1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x2</name>
                    <description>OA2[2:1] are masked and dont care. Only OA2[7:3] are compared.</description>
                    <value>0x2</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x3</name>
                    <description>OA2[3:1] are masked and dont care. Only OA2[7:4] are compared.</description>
                    <value>0x3</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x4</name>
                    <description>OA2[4:1] are masked and dont care. Only OA2[7:5] are compared.</description>
                    <value>0x4</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x5</name>
                    <description>OA2[5:1] are masked and dont care. Only OA2[7:6] are compared.</description>
                    <value>0x5</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x6</name>
                    <description>OA2[6:1] are masked and dont care. Only OA2[7] is compared.</description>
                    <value>0x6</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x7</name>
                    <description>OA2[7:1] are masked and dont care. No comparison is done, and all (except reserved) 7-bit received addresses are acknowledged.</description>
                    <value>0x7</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>OA2EN</name>
                <description>Own Address 2 enable</description>
                <bitOffset>15</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Own address 2 disabled. The received slave address OA2 is NACKed.</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Own address 2 enabled. The received slave address OA2 is ACKed.</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
            </fields>
          </register>
          <register>
            <name>I2C_TIMINGR</name>
            <displayName>I2C_TIMINGR</displayName>
            <description>I2C timing register</description>
            <addressOffset>0x10</addressOffset>
            <size>0x20</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>SCLL</name>
                <description>SCL low period (master mode)
This field is used to generate the SCL low period in master mode.
t&lt;sub&gt;SCLL &lt;/sub&gt;= (SCLL+1) x t&lt;sub&gt;PRESC&lt;/sub&gt;
Note: SCLL is also used to generate t&lt;sub&gt;BUF &lt;/sub&gt;and t&lt;sub&gt;SU:STA &lt;/sub&gt;timings.</description>
                <bitOffset>0</bitOffset>
                <bitWidth>8</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>SCLH</name>
                <description>SCL high period (master mode)
This field is used to generate the SCL high period in master mode.
t&lt;sub&gt;SCLH &lt;/sub&gt;= (SCLH+1) x t&lt;sub&gt;PRESC&lt;/sub&gt;
Note: SCLH is also used to generate t&lt;sub&gt;SU:STO &lt;/sub&gt;and t&lt;sub&gt;HD:STA &lt;/sub&gt;timing.</description>
                <bitOffset>8</bitOffset>
                <bitWidth>8</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>SDADEL</name>
                <description>Data hold time
This field is used to generate the delay t&lt;sub&gt;SDADEL &lt;/sub&gt;between SCL falling edge and SDA edge. In master mode and in slave mode with NOSTRETCH = 0, the SCL line is stretched low during t&lt;sub&gt;SDADEL&lt;/sub&gt;.
t&lt;sub&gt;SDADEL&lt;/sub&gt;= SDADEL x t&lt;sub&gt;PRESC&lt;/sub&gt;
Note: SDADEL is used to generate t&lt;sub&gt;HD:DAT &lt;/sub&gt;timing.</description>
                <bitOffset>16</bitOffset>
                <bitWidth>4</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>SCLDEL</name>
                <description>Data setup time
This field is used to generate a delay t&lt;sub&gt;SCLDEL &lt;/sub&gt;between SDA edge and SCL rising edge. In master mode and in slave mode with NOSTRETCH = 0, the SCL line is stretched low during t&lt;sub&gt;SCLDEL&lt;/sub&gt;.
t&lt;sub&gt;SCLDEL &lt;/sub&gt;= (SCLDEL+1) x t&lt;sub&gt;PRESC&lt;/sub&gt;
Note: t&lt;sub&gt;SCLDEL&lt;/sub&gt; is used to generate t&lt;sub&gt;SU:DAT &lt;/sub&gt;timing.</description>
                <bitOffset>20</bitOffset>
                <bitWidth>4</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>PRESC</name>
                <description>Timing prescaler
This field is used to prescale i2c_ker_ck in order to generate the clock period t&lt;sub&gt;PRESC &lt;/sub&gt;used for data setup and hold counters (refer to FMPI2C timings on page 1928) and for SCL high and low level counters (refer to FMPI2C master initialization on page 1951).
t&lt;sub&gt;PRESC &lt;/sub&gt;= (PRESC+1) x t&lt;sub&gt;I2CCLK&lt;/sub&gt;</description>
                <bitOffset>28</bitOffset>
                <bitWidth>4</bitWidth>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>I2C_TIMEOUTR</name>
            <displayName>I2C_TIMEOUTR</displayName>
            <description>I2C timeout register</description>
            <addressOffset>0x14</addressOffset>
            <size>0x20</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>TIMEOUTA</name>
                <description>Bus Timeout A
This field is used to configure:
The SCL low timeout condition t&lt;sub&gt;TIMEOUT&lt;/sub&gt; when TIDLE=0
t&lt;sub&gt;TIMEOUT&lt;/sub&gt;= (TIMEOUTA+1) x 2048 x t&lt;sub&gt;I2CCLK&lt;/sub&gt;
The bus idle condition (both SCL and SDA high) when TIDLE=1 
t&lt;sub&gt;IDLE&lt;/sub&gt;= (TIMEOUTA+1) x 4 x t&lt;sub&gt;I2CCLK&lt;/sub&gt;
Note: These bits can be written only when TIMOUTEN=0.</description>
                <bitOffset>0</bitOffset>
                <bitWidth>12</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>TIDLE</name>
                <description>Idle clock timeout detection 
Note: This bit can be written only when TIMOUTEN=0.</description>
                <bitOffset>12</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>TIMEOUTA is used to detect SCL low timeout</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>TIMEOUTA is used to detect both SCL and SDA high timeout (bus idle condition)</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>TIMOUTEN</name>
                <description>Clock timeout enable</description>
                <bitOffset>15</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>SCL timeout detection is disabled</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>SCL timeout detection is enabled: when SCL is low for more than t&lt;sub&gt;TIMEOUT&lt;/sub&gt; (TIDLE=0) or high for more than t&lt;sub&gt;IDLE &lt;/sub&gt;(TIDLE=1), a timeout error is detected (TIMEOUT=1).</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>TIMEOUTB</name>
                <description>Bus timeout B
This field is used to configure the cumulative clock extension timeout:
In master mode, the master cumulative clock low extend time (t&lt;sub&gt;LOW:MEXT&lt;/sub&gt;) is detected
In slave mode, the slave cumulative clock low extend time (t&lt;sub&gt;LOW:SEXT&lt;/sub&gt;) is detected
t&lt;sub&gt;LOW:EXT&lt;/sub&gt;= (TIMEOUTB+1) x 2048 x t&lt;sub&gt;I2CCLK&lt;/sub&gt;
Note: These bits can be written only when TEXTEN=0.</description>
                <bitOffset>16</bitOffset>
                <bitWidth>12</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>TEXTEN</name>
                <description>Extended clock timeout enable</description>
                <bitOffset>31</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Extended clock timeout detection is disabled</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Extended clock timeout detection is enabled. When a cumulative SCL stretch for more than t&lt;sub&gt;LOW:EXT &lt;/sub&gt;is done by the I2C interface, a timeout error is detected (TIMEOUT=1).</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
            </fields>
          </register>
          <register>
            <name>I2C_ISR</name>
            <displayName>I2C_ISR</displayName>
            <description>I2C interrupt and status register</description>
            <addressOffset>0x18</addressOffset>
            <size>0x20</size>
            <resetValue>0x00000001</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>TXE</name>
                <description>Transmit data register empty (transmitters) 
This bit is set by hardware when the I2C_TXDR register is empty. It is cleared when the next data to be sent is written in the I2C_TXDR register. 
This bit can be written to 1 by software in order to flush the transmit data register I2C_TXDR.
Note: This bit is set by hardware when PE = 0.</description>
                <bitOffset>0</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>TXIS</name>
                <description>Transmit interrupt status (transmitters) 
This bit is set by hardware when the I2C_TXDR register is empty and the data to be transmitted must be written in the I2C_TXDR register. It is cleared when the next data to be sent is written in the I2C_TXDR register. 
This bit can be written to 1 by software when NOSTRETCH = 1 only, in order to generate a TXIS event (interrupt if TXIE=1 or DMA request if TXDMAEN = 1).
Note: This bit is cleared by hardware when PE = 0.</description>
                <bitOffset>1</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>RXNE</name>
                <description>Receive data register not empty (receivers)
This bit is set by hardware when the received data is copied into the I2C_RXDR register, and is ready to be read. It is cleared when I2C_RXDR is read. 
Note: This bit is cleared by hardware when PE = 0.</description>
                <bitOffset>2</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-only</access>
              </field>
              <field>
                <name>ADDR</name>
                <description>Address matched (slave mode)
This bit is set by hardware as soon as the received slave address matched with one of the enabled slave addresses. It is cleared by software by setting ADDRCF bit.
Note: This bit is cleared by hardware when PE = 0.</description>
                <bitOffset>3</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-only</access>
              </field>
              <field>
                <name>NACKF</name>
                <description>Not Acknowledge received flag 
This flag is set by hardware when a NACK is received after a byte transmission. It is cleared by software by setting the NACKCF bit.
Note: This bit is cleared by hardware when PE = 0.</description>
                <bitOffset>4</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-only</access>
              </field>
              <field>
                <name>STOPF</name>
                <description>Stop detection flag
This flag is set by hardware when a STOP condition is detected on the bus and the peripheral is involved in this transfer:
either as a master, provided that the STOP condition is generated by the peripheral.
or as a slave, provided that the peripheral has been addressed previously during this transfer.
It is cleared by software by setting the STOPCF bit.
Note: This bit is cleared by hardware when PE = 0.</description>
                <bitOffset>5</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-only</access>
              </field>
              <field>
                <name>TC</name>
                <description>Transfer Complete (master mode)
This flag is set by hardware when RELOAD=0, AUTOEND=0 and NBYTES data have been transferred. It is cleared by software when START bit or STOP bit is set.
Note: This bit is cleared by hardware when PE = 0.</description>
                <bitOffset>6</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-only</access>
              </field>
              <field>
                <name>TCR</name>
                <description>Transfer Complete Reload
This flag is set by hardware when RELOAD=1 and NBYTES data have been transferred. It is cleared by software when NBYTES is written to a non-zero value.
Note: This bit is cleared by hardware when PE = 0.
Note: This flag is only for master mode, or for slave mode when the SBC bit is set.</description>
                <bitOffset>7</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-only</access>
              </field>
              <field>
                <name>BERR</name>
                <description>Bus error 
This flag is set by hardware when a misplaced Start or STOP condition is detected whereas the peripheral is involved in the transfer. The flag is not set during the address phase in slave mode. It is cleared by software by setting BERRCF bit.
Note: This bit is cleared by hardware when PE = 0.</description>
                <bitOffset>8</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-only</access>
              </field>
              <field>
                <name>ARLO</name>
                <description>Arbitration lost 
This flag is set by hardware in case of arbitration loss. It is cleared by software by setting the ARLOCF bit.
Note: This bit is cleared by hardware when PE = 0.</description>
                <bitOffset>9</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-only</access>
              </field>
              <field>
                <name>OVR</name>
                <description>Overrun/Underrun (slave mode)
This flag is set by hardware in slave mode with NOSTRETCH = 1, when an overrun/underrun error occurs. It is cleared by software by setting the OVRCF bit.
Note: This bit is cleared by hardware when PE = 0.</description>
                <bitOffset>10</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-only</access>
              </field>
              <field>
                <name>PECERR</name>
                <description>PEC Error in reception
This flag is set by hardware when the received PEC does not match with the PEC register content. A NACK is automatically sent after the wrong PEC reception. It is cleared by software by setting the PECCF bit.
Note: This bit is cleared by hardware when PE = 0.
Note: If the SMBus feature is not supported, this bit is reserved and forced by hardware to 0. Refer to Section 52.3: FMPI2C implementation.</description>
                <bitOffset>11</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-only</access>
              </field>
              <field>
                <name>TIMEOUT</name>
                <description>Timeout or t&lt;sub&gt;LOW&lt;/sub&gt; detection flag
This flag is set by hardware when a timeout or extended clock timeout occurred. It is cleared by software by setting the TIMEOUTCF bit.
Note: This bit is cleared by hardware when PE = 0.
Note: If the SMBus feature is not supported, this bit is reserved and forced by hardware to 0. Refer to Section 52.3: FMPI2C implementation.</description>
                <bitOffset>12</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-only</access>
              </field>
              <field>
                <name>ALERT</name>
                <description>SMBus alert 
This flag is set by hardware when SMBHEN=1 (SMBus host configuration), ALERTEN=1 and a SMBALERT event (falling edge) is detected on SMBA pin. It is cleared by software by setting the ALERTCF bit.
Note: This bit is cleared by hardware when PE = 0.
Note: If the SMBus feature is not supported, this bit is reserved and forced by hardware to 0. Refer to Section 52.3: FMPI2C implementation.</description>
                <bitOffset>13</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-only</access>
              </field>
              <field>
                <name>BUSY</name>
                <description>Bus busy
This flag indicates that a communication is in progress on the bus. It is set by hardware when a START condition is detected. It is cleared by hardware when a STOP condition is detected, or when PE = 0.</description>
                <bitOffset>15</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-only</access>
              </field>
              <field>
                <name>DIR</name>
                <description>Transfer direction (Slave mode)
This flag is updated when an address match event occurs (ADDR = 1).</description>
                <bitOffset>16</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Write transfer, slave enters receiver mode.</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Read transfer, slave enters transmitter mode.</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>ADDCODE</name>
                <description>Address match code (Slave mode) 
These bits are updated with the received address when an address match event occurs (ADDR = 1).
In the case of a 10-bit address, ADDCODE provides the 10-bit header followed by the 2 MSBs of the address.</description>
                <bitOffset>17</bitOffset>
                <bitWidth>7</bitWidth>
                <access>read-only</access>
              </field>
            </fields>
          </register>
          <register>
            <name>I2C_ICR</name>
            <displayName>I2C_ICR</displayName>
            <description>I2C interrupt clear register</description>
            <addressOffset>0x1C</addressOffset>
            <size>0x20</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>ADDRCF</name>
                <description>Address matched flag clear 
Writing 1 to this bit clears the ADDR flag in the I2C_ISR register. Writing 1 to this bit also clears the START bit in the I2C_CR2 register.</description>
                <bitOffset>3</bitOffset>
                <bitWidth>1</bitWidth>
                <access>write-only</access>
              </field>
              <field>
                <name>NACKCF</name>
                <description>Not Acknowledge flag clear
Writing 1 to this bit clears the NACKF flag in I2C_ISR register.</description>
                <bitOffset>4</bitOffset>
                <bitWidth>1</bitWidth>
                <access>write-only</access>
              </field>
              <field>
                <name>STOPCF</name>
                <description>STOP detection flag clear 
Writing 1 to this bit clears the STOPF flag in the I2C_ISR register.</description>
                <bitOffset>5</bitOffset>
                <bitWidth>1</bitWidth>
                <access>write-only</access>
              </field>
              <field>
                <name>BERRCF</name>
                <description>Bus error flag clear
Writing 1 to this bit clears the BERRF flag in the I2C_ISR register.</description>
                <bitOffset>8</bitOffset>
                <bitWidth>1</bitWidth>
                <access>write-only</access>
              </field>
              <field>
                <name>ARLOCF</name>
                <description>Arbitration lost flag clear
Writing 1 to this bit clears the ARLO flag in the I2C_ISR register.</description>
                <bitOffset>9</bitOffset>
                <bitWidth>1</bitWidth>
                <access>write-only</access>
              </field>
              <field>
                <name>OVRCF</name>
                <description>Overrun/Underrun flag clear
Writing 1 to this bit clears the OVR flag in the I2C_ISR register.</description>
                <bitOffset>10</bitOffset>
                <bitWidth>1</bitWidth>
                <access>write-only</access>
              </field>
              <field>
                <name>PECCF</name>
                <description>PEC Error flag clear
Writing 1 to this bit clears the PECERR flag in the I2C_ISR register.
Note: If the SMBus feature is not supported, this bit is reserved and forced by hardware to 0. Refer to Section 52.3: FMPI2C implementation.</description>
                <bitOffset>11</bitOffset>
                <bitWidth>1</bitWidth>
                <access>write-only</access>
              </field>
              <field>
                <name>TIMOUTCF</name>
                <description>Timeout detection flag clear
Writing 1 to this bit clears the TIMEOUT flag in the I2C_ISR register.
Note: If the SMBus feature is not supported, this bit is reserved and forced by hardware to 0. Refer to Section 52.3: FMPI2C implementation.</description>
                <bitOffset>12</bitOffset>
                <bitWidth>1</bitWidth>
                <access>write-only</access>
              </field>
              <field>
                <name>ALERTCF</name>
                <description>Alert flag clear
Writing 1 to this bit clears the ALERT flag in the I2C_ISR register.
Note: If the SMBus feature is not supported, this bit is reserved and forced by hardware to 0. Refer to Section 52.3: FMPI2C implementation.</description>
                <bitOffset>13</bitOffset>
                <bitWidth>1</bitWidth>
                <access>write-only</access>
              </field>
            </fields>
          </register>
          <register>
            <name>I2C_PECR</name>
            <displayName>I2C_PECR</displayName>
            <description>I2C PEC register</description>
            <addressOffset>0x20</addressOffset>
            <size>0x20</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>PEC</name>
                <description>Packet error checking register
This field contains the internal PEC when PECEN=1.
The PEC is cleared by hardware when PE = 0.</description>
                <bitOffset>0</bitOffset>
                <bitWidth>8</bitWidth>
                <access>read-only</access>
              </field>
            </fields>
          </register>
          <register>
            <name>I2C_RXDR</name>
            <displayName>I2C_RXDR</displayName>
            <description>I2C receive data register</description>
            <addressOffset>0x24</addressOffset>
            <size>0x20</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>RXDATA</name>
                <description>8-bit receive data
Data byte received from the I&lt;sup&gt;2&lt;/sup&gt;C bus</description>
                <bitOffset>0</bitOffset>
                <bitWidth>8</bitWidth>
                <access>read-only</access>
              </field>
            </fields>
          </register>
          <register>
            <name>I2C_TXDR</name>
            <displayName>I2C_TXDR</displayName>
            <description>I2C transmit data register</description>
            <addressOffset>0x28</addressOffset>
            <size>0x20</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>TXDATA</name>
                <description>8-bit transmit data
Data byte to be transmitted to the I&lt;sup&gt;2&lt;/sup&gt;C bus
Note: These bits can be written only when TXE = 1.</description>
                <bitOffset>0</bitOffset>
                <bitWidth>8</bitWidth>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>I2C_AUTOCR</name>
            <displayName>I2C_AUTOCR</displayName>
            <description>I2C Autonomous mode control register</description>
            <addressOffset>0x2C</addressOffset>
            <size>0x20</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>TCDMAEN</name>
                <description>DMA request enable on Transfer Complete event</description>
                <bitOffset>6</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>DMA request not generated on Transfer Complete event</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>DMA request generated on Transfer Complete event</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>TCRDMAEN</name>
                <description>DMA request enable on Transfer Complete Reload event</description>
                <bitOffset>7</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>DMA request not generated on Transfer Complete Reload event</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>DMA request generated on Transfer Complete Reload event</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>TRIGSEL</name>
                <description>Trigger selection (refer to Section 52.4.3: FMPI2C pins and internal signals I2C interconnections tables).
...
Note: This bit can be written only when PE = 0</description>
                <bitOffset>16</bitOffset>
                <bitWidth>4</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>i2c_trg0 selected</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>i2c_trg1 selected</description>
                    <value>0x1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0xF</name>
                    <description>i2c_trg15 selected</description>
                    <value>0xF</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>TRIGPOL</name>
                <description>Trigger polarity
Note: This bit can be written only when PE = 0</description>
                <bitOffset>20</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Trigger active on rising edge</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Trigger active on falling edge</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>TRIGEN</name>
                <description>Trigger enable
When a trigger is detected, a START condition is sent and the transfer is launched as defined in I2C_CR2.</description>
                <bitOffset>21</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Trigger disabled</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Trigger enabled</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
            </fields>
          </register>
        </registers>
    </peripheral>
	<peripheral derivedFrom="I2C1">
      <name>SEC_I2C1</name>
      <baseAddress>0x50005400</baseAddress>
    </peripheral>   
    <peripheral derivedFrom="I2C1">
      <name>I2C3</name>
      <baseAddress>0x46002800</baseAddress>
      <interrupt>
        <name>I2C3_EV</name>
        <description>I2C3 event interrupt</description>
        <value>54</value>
      </interrupt>
      <interrupt>
        <name>I2C3_ER</name>
        <description>I2C3 error interrupt</description>
        <value>55</value>
      </interrupt>
    </peripheral>
    <peripheral derivedFrom="I2C1">
      <name>SEC_I2C3</name>
      <baseAddress>0x56002800</baseAddress>
    </peripheral>
	<peripheral>
        <name>PKA</name>
        <description>Private key accelerator</description>
        <groupName>PKA</groupName>
        <baseAddress>0x420C2000</baseAddress>
        <addressBlock>
          <offset>0x0</offset>
          <size>0x2000</size>
          <usage>registers</usage>
        </addressBlock>
        <interrupt>
          <name>PKA</name>
          <description>PKA global interrupt</description>
          <value>62</value>
        </interrupt>
        <registers>
          <register>
            <name>PKA_CR</name>
            <displayName>PKA_CR</displayName>
            <description>PKA control register</description>
            <addressOffset>0x00</addressOffset>
            <size>0x20</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>EN</name>
                <description>PKA enable.
When an illegal operation is selected while EN=1 OPERRF bit is set in PKA_SR. See PKA_CR.MODE bitfield for details.
Note: When EN=0 PKA RAM can still be accessed by the application.</description>
                <bitOffset>0</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Disable PKA</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Enable PKA.PKA becomes functional when INITOK is set by hardware in PKA_SR.</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>START</name>
                <description>start the operation
Writing 1 to this bit starts the operation which is selected by MODE[5:0], using the operands and data already written to the PKA RAM. This bit is always read as 0.
When an illegal operation is selected while START bit is set no operation is started, and OPERRF bit is set in PKA_SR.
Note: START is ignored if PKA is busy.</description>
                <bitOffset>1</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>MODE</name>
                <description>PKA operation code
When an operation not listed here is written by the application with EN bit set, OPERRF bit is set in PKA_SR register, and the write to MODE bitfield is ignored. When PKA is configured in limited mode (LMF = 1 in PKA_SR), writing a MODE different from 0x26 with EN bit to 1 triggers OPERRF bit to be set and write to MODE bit is ignored.</description>
                <bitOffset>8</bitOffset>
                <bitWidth>6</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Montgomery parameter computation then modular exponentiation</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Montgomery parameter computation only</description>
                    <value>0x1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x2</name>
                    <description>Modular exponentiation only (Montgomery parameter must be loaded first)</description>
                    <value>0x2</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x3</name>
                    <description>Modular exponentiation (protected, used when manipulating secrets)</description>
                    <value>0x3</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x20</name>
                    <description>Montgomery parameter computation then ECC scalar multiplication</description>
                    <value>0x20</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x24</name>
                    <description>ECDSA sign</description>
                    <value>0x24</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x26</name>
                    <description>ECDSA verification</description>
                    <value>0x26</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x28</name>
                    <description>Point on elliptic curve Fp check</description>
                    <value>0x28</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x7</name>
                    <description>RSA CRT exponentiation</description>
                    <value>0x7</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x8</name>
                    <description>Modular inversion</description>
                    <value>0x8</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x9</name>
                    <description>Arithmetic addition</description>
                    <value>0x9</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0xA</name>
                    <description>Arithmetic subtraction</description>
                    <value>0xA</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0xB</name>
                    <description>Arithmetic multiplication</description>
                    <value>0xB</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0xC</name>
                    <description>Arithmetic comparison</description>
                    <value>0xC</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0xD</name>
                    <description>Modular reduction</description>
                    <value>0xD</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0xE</name>
                    <description>Modular addition</description>
                    <value>0xE</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0xF</name>
                    <description>Modular subtraction</description>
                    <value>0xF</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x10</name>
                    <description>Montgomery multiplication</description>
                    <value>0x10</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x23</name>
                    <description>ECC complete addition</description>
                    <value>0x23</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x27</name>
                    <description>ECC double base ladder</description>
                    <value>0x27</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x2F</name>
                    <description>ECC projective to affine</description>
                    <value>0x2F</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>PROCENDIE</name>
                <description>End of operation interrupt enable</description>
                <bitOffset>17</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>No interrupt is generated when PROCENDF flag is set in PKA_SR.</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>An interrupt is generated when PROCENDF flag is set in PKA_SR.</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>RAMERRIE</name>
                <description>RAM error interrupt enable</description>
                <bitOffset>19</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>No interrupt is generated when RAMERRF flag is set in PKA_SR.</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>An interrupt is generated when RAMERRF flag is set in PKA_SR.</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>ADDRERRIE</name>
                <description>Address error interrupt enable</description>
                <bitOffset>20</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>No interrupt is generated when ADDRERRF flag is set in PKA_SR.</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>An interrupt is generated when ADDRERRF flag is set in PKA_SR.</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>OPERRIE</name>
                <description>Operation error interrupt enable</description>
                <bitOffset>21</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>No interrupt is generated when OPERRF flag is set in PKA_SR.</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>An interrupt is generated when OPERRF flag is set in PKA_SR.</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
            </fields>
          </register>
          <register>
            <name>PKA_SR</name>
            <displayName>PKA_SR</displayName>
            <description>PKA status register</description>
            <addressOffset>0x04</addressOffset>
            <size>0x20</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>INITOK</name>
                <description>PKA initialization OK
This bit is asserted when PKA initialization is complete. When RNG is not able to output proper random numbers INITOK stays at 0.</description>
                <bitOffset>0</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>PKA is not initialized correctly. START bit cannot be set.</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>PKA is initialized correctly and can be used normally.</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>LMF</name>
                <description>Limited mode flag
This bit is updated when EN bit in PKA_CR is set</description>
                <bitOffset>1</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>All values documented in MODE bitfield can be used.</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Only ECDSA verification (MODE = 0x26) is supported by the PKA.</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>BUSY</name>
                <description>PKA operation is in progress
This bit is set to 1 whenever START bit in the PKA_CR is set. It is automatically cleared when the computation is complete, meaning that PKA RAM can be safely accessed and a new operation can be started.
If PKA is started with a wrong opcode, it is busy for a couple of cycles, then it aborts automatically the operation and go back to ready (BUSY bit is set to 0).</description>
                <bitOffset>16</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>No operation is in progress (default)</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>An operation is in progress</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>PROCENDF</name>
                <description>PKA End of Operation flag</description>
                <bitOffset>17</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Operation in progress</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>PKA operation is completed. This flag is set when the BUSY bit is deasserted.</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>RAMERRF</name>
                <description>PKA RAM error flag
This bit is cleared using RAMERRFC bit in PKA_CLRFR.</description>
                <bitOffset>19</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>No PKA RAM access error</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>An AHB access to the PKA RAM occurred while the PKA core was computing and using its internal RAM (AHB PKA_RAM access are not allowed while PKA operation is in progress).</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>ADDRERRF</name>
                <description>Address error flag
This bit is cleared using ADDRERRFC bit in PKA_CLRFR.</description>
                <bitOffset>20</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>No address error</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Address access is out of range (unmapped address)</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>OPERRF</name>
                <description>Operation error flag
This bit is cleared using OPERRFC bit in PKA_CLRFR.</description>
                <bitOffset>21</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>No event error</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>An illegal or unknown operation has been selected in PKA_CR register</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
            </fields>
          </register>
          <register>
            <name>PKA_CLRFR</name>
            <displayName>PKA_CLRFR</displayName>
            <description>PKA clear flag register</description>
            <addressOffset>0x08</addressOffset>
            <size>0x20</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>PROCENDFC</name>
                <description>Clear PKA End of Operation flag</description>
                <bitOffset>17</bitOffset>
                <bitWidth>1</bitWidth>
                <access>write-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>No action</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Clear the PROCENDF flag in PKA_SR</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>RAMERRFC</name>
                <description>Clear PKA RAM error flag</description>
                <bitOffset>19</bitOffset>
                <bitWidth>1</bitWidth>
                <access>write-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>No action</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Clear the RAMERRF flag in PKA_SR</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>ADDRERRFC</name>
                <description>Clear address error flag</description>
                <bitOffset>20</bitOffset>
                <bitWidth>1</bitWidth>
                <access>write-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>No action</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Clear the ADDRERRF flag in PKA_SR</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>OPERRFC</name>
                <description>Clear operation error flag</description>
                <bitOffset>21</bitOffset>
                <bitWidth>1</bitWidth>
                <access>write-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>No action</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Clear the OPERRF flag in PKA_SR</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
            </fields>
          </register>
        </registers>
    </peripheral>
	<peripheral derivedFrom="PKA">
      <name>SEC_PKA</name>
      <baseAddress>0x520C2000</baseAddress>
    </peripheral>
	<peripheral>
        <name>RNG</name>
        <description>Random number generator</description>
        <groupName>RNG</groupName>
        <baseAddress>0x420C0800</baseAddress>
        <addressBlock>
          <offset>0x0</offset>
          <size>0x400</size>
          <usage>registers</usage>
        </addressBlock>
        <interrupt>
          <name>RNG</name>
          <description>RNG global interrupt</description>
          <value>59</value>
        </interrupt>
        <registers>
          <register>
            <name>RNG_CR</name>
            <displayName>RNG_CR</displayName>
            <description>RNG control register</description>
            <addressOffset>0x000</addressOffset>
            <size>0x20</size>
            <resetValue>0x008000D0</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>RNGEN</name>
                <description>True random number generator enable</description>
                <bitOffset>2</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>True random number generator is disabled. Analog noise sources are powered off and logic clocked by the RNG clock is gated.</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>True random number generator is enabled.</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>IE</name>
                <description>Interrupt Enable</description>
                <bitOffset>3</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>RNG Interrupt is disabled</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>RNG Interrupt is enabled. An interrupt is pending as soon as DRDY = 1, SEIS = 1 or CEIS = 1 in the RNG_SR register.</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>CED</name>
                <description>Clock error detection 
The clock error detection cannot be enabled nor disabled on-the-fly when the RNG is enabled, i.e. to enable or disable CED the RNG must be disabled.
Writing this bit is taken into account only if CONDRST bit is set to 1 in the same access, while CONFIGLOCK remains at 0. Writing to this bit is ignored if CONFIGLOCK = 1.</description>
                <bitOffset>5</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Clock error detection is enable</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Clock error detection is disable</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>ARDIS</name>
                <description>Auto reset disable
When auto-reset is enabled application still need to clear SEIS bit after a noise source error.
Writing this bit is taken into account only if CONDRST bit is set to 1 in the same access, while CONFIGLOCK remains at 0. Writing to this bit is ignored if CONFIGLOCK = 1.</description>
                <bitOffset>7</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>When a noise source error occurs RNG performs an automatic reset to clear SECS bit.</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>When a noise source error occurs application must reset RNG by writing CONDRST to 1 then to 0, in order to restart random number generation.</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>RNG_CONFIG3</name>
                <description>RNG configuration 3
Reserved to the RNG configuration (bitfield 3). Refer to RNG_CONFIG1 bitfield for details.
If NISTC bit is cleared in this register RNG_CONFIG3 bitfield values are ignored by RNG.</description>
                <bitOffset>8</bitOffset>
                <bitWidth>4</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>NISTC</name>
                <description>Non NIST compliant
two conditioning loops are performed and 256 bits of noise source are used.
Writing this bit is taken into account only if CONDRST bit is set to 1 in the same access, while CONFIGLOCK remains at 0. Writing to this bit is ignored if CONFIGLOCK = 1.</description>
                <bitOffset>12</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Hardware default values for NIST compliant RNG. In this configuration per 128-bit output</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Custom values for NIST compliant RNG. See Section 38.6: RNG entropy source validation for proposed configuration.</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>RNG_CONFIG2</name>
                <description>RNG configuration 2
Reserved to the RNG configuration (bitfield 2). Refer to RNG_CONFIG1 bitfield for details.</description>
                <bitOffset>13</bitOffset>
                <bitWidth>3</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>CLKDIV</name>
                <description>Clock divider factor
This value used to configure an internal programmable divider (from 1 to 16) acting on the incoming RNG clock. These bits can be written only when the core is disabled (RNGEN = 0). 
...
Writing these bits is taken into account only if CONDRST bit is set to 1 in the same access, while CONFIGLOCK remains at 0. Writing to this bit is ignored if CONFIGLOCK = 1.</description>
                <bitOffset>16</bitOffset>
                <bitWidth>4</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>internal RNG clock after divider is similar to incoming RNG clock.</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>two RNG clock cycles per internal RNG clock.</description>
                    <value>0x1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x2</name>
                    <description>2&lt;sup&gt;2&lt;/sup&gt; (= 4) RNG clock cycles per internal RNG clock.</description>
                    <value>0x2</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0xF</name>
                    <description>2&lt;sup&gt;15&lt;/sup&gt; RNG clock cycles per internal clock (for example. an incoming 48 MHz RNG clock becomes a 1.5 kHz internal RNG clock)</description>
                    <value>0xF</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>RNG_CONFIG1</name>
                <description>RNG configuration 1
Reserved to the RNG configuration (bitfield 1). Must be initialized using the recommended value documented in Section 38.6: RNG entropy source validation.
Writing any bit of RNG_CONFIG1 is taken into account only if CONDRST bit is set to 1 in the same access, while CONFIGLOCK remains at 0. Writing to this bit is ignored if CONFIGLOCK = 1.</description>
                <bitOffset>20</bitOffset>
                <bitWidth>6</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>CONDRST</name>
                <description>Conditioning soft reset
	Write 1 and then write 0 to reset the conditioning logic, clear all the FIFOs and start a new RNG initialization process, with RNG_SR cleared. Registers RNG_CR and RNG_NSCR are not changed by CONDRST.
This bit must be set to 1 in the same access that set any configuration bits [29:4]. In other words, when CONDRST bit is set to 1 correct configuration in bits [29:4] must also be written.
When CONDRST is set to 0 by software its value goes to 0 when the reset process is done. It takes about 2 AHB clock cycles + 2 RNG clock cycles.</description>
                <bitOffset>30</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>CONFIGLOCK</name>
                <description>RNG Config lock
This bitfield is set once: if this bit is set it can only be reset to 0 if RNG is reset.</description>
                <bitOffset>31</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Writes to the RNG_CR configuration bits [29:4] are allowed.</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Writes to the RNG_CR configuration bits [29:4] are ignored until the next RNG reset.</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
            </fields>
          </register>
          <register>
            <name>RNG_SR</name>
            <displayName>RNG_SR</displayName>
            <description>RNG status register</description>
            <addressOffset>0x004</addressOffset>
            <size>0x20</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>DRDY</name>
                <description>Data Ready
Once the output buffer becomes empty (after reading the RNG_DR register), this bit returns to 0 until a new random value is generated.
Note: The DRDY bit can rise when the peripheral is disabled (RNGEN = 0 in the RNG_CR register).
If IE=1 in the RNG_CR register, an interrupt is generated when DRDY = 1.</description>
                <bitOffset>0</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>The RNG_DR register is not yet valid, no random data is available.</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>The RNG_DR register contains valid random data.</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>CECS</name>
                <description>Clock error current status
Note: CECS bit is valid only if the CED bit in the RNG_CR register is set to 0.</description>
                <bitOffset>1</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>The RNG clock is correct (fRNGCLK&gt; fHCLK/32). If the CEIS bit is set, this means that a slow clock was detected and the situation has been recovered.</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>The RNG clock is too slow (fRNGCLK&lt; fHCLK/32).</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>SECS</name>
                <description>Seed error current status
Run-time repetition count test failed (noise source has provided more than 24 consecutive bits at a constant value 0 or 1, or more than 32 consecutive occurrence of two bits patterns 01 or 10)
Start-up or continuous adaptive proportion test on noise source failed.
Start-up post-processing/conditioning sanity check failed.</description>
                <bitOffset>2</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>No faulty sequence has currently been detected. If the SEIS bit is set, this means that a faulty sequence was detected and the situation has been recovered.</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>At least one of the following faulty sequence has been detected:</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>CEIS</name>
                <description>Clock error interrupt status
This bit is set at the same time as CECS. It is cleared by writing 0. Writing 1 has no effect.
An interrupt is pending if IE = 1 in the RNG_CR register.</description>
                <bitOffset>5</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>The RNG clock is correct (fRNGCLK&gt; fHCLK/32)</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>The RNG clock before internal divider is detected too slow (fRNGCLK&lt; fHCLK/32)</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>SEIS</name>
                <description>Seed error interrupt status
This bit is set at the same time as SECS. It is cleared by writing 0 (unless CONDRST is used). Writing 1 has no effect.
An interrupt is pending if IE = 1 in the RNG_CR register.</description>
                <bitOffset>6</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>No faulty sequence detected</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>At least one faulty sequence is detected. See SECS bit description for details.</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
            </fields>
          </register>
          <register>
            <name>RNG_DR</name>
            <displayName>RNG_DR</displayName>
            <description>RNG data register</description>
            <addressOffset>0x008</addressOffset>
            <size>0x20</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>RNDATA</name>
                <description>Random data
32-bit random data which are valid when DRDY = 1. When DRDY = 0 RNDATA value is zero.
It is recommended to always verify that RNG_DR is different from zero. Because when it is the case a seed error occurred between RNG_SR polling and RND_DR output reading (rare event).</description>
                <bitOffset>0</bitOffset>
                <bitWidth>32</bitWidth>
                <access>read-only</access>
              </field>
            </fields>
          </register>
          <register>
            <name>RNG_HTCR</name>
            <displayName>RNG_HTCR</displayName>
            <description>RNG health test control register</description>
            <addressOffset>0x010</addressOffset>
            <size>0x20</size>
            <resetValue>0x000072AC</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>HTCFG</name>
                <description>health test configuration
This configuration is used by RNG to configure the health tests. See Section 38.6: RNG entropy source validation for the recommended value.
Note: The RNG behavior, including the read to this register, is not guaranteed if a different value from the recommended value is written.</description>
                <bitOffset>0</bitOffset>
                <bitWidth>32</bitWidth>
                <access>read-write</access>
              </field>
            </fields>
          </register>
        </registers>
    </peripheral>
	<peripheral derivedFrom="RNG">
        <name>SEC_RNG</name>
        <baseAddress>0x520C0800</baseAddress>
    </peripheral>
	<peripheral>
        <name>WWDG</name>
        <description>System window watchdog</description>
        <groupName>WWDG</groupName>
        <baseAddress>0x40002C00</baseAddress>
        <addressBlock>
          <offset>0x0</offset>
          <size>0x400</size>
          <usage>registers</usage>
        </addressBlock>
        <interrupt>
          <name>WWDG</name>
          <description>Window Watchdog interrupt</description>
          <value>0</value>
        </interrupt>
        <registers>
          <register>
            <name>WWDG_CR</name>
            <displayName>WWDG_CR</displayName>
            <description>WWDG control register</description>
            <addressOffset>0x000</addressOffset>
            <size>0x20</size>
            <resetValue>0x0000007F</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>T</name>
                <description>7-bit counter (MSB to LSB)
These bits contain the value of the watchdog counter, decremented every
(4096 x 2&lt;sup&gt;WDGTB[2:0]&lt;/sup&gt;) PCLK cycles. A reset is produced when it is decremented from 0x40 to 0x3F (T6 becomes cleared).</description>
                <bitOffset>0</bitOffset>
                <bitWidth>7</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>WDGA</name>
                <description>Activation bit 
This bit is set by software and only cleared by hardware after a reset. When WDGA = 1, the watchdog can generate a reset.</description>
                <bitOffset>7</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Watchdog disabled</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Watchdog enabled</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
            </fields>
          </register>
          <register>
            <name>WWDG_CFR</name>
            <displayName>WWDG_CFR</displayName>
            <description>WWDG configuration register</description>
            <addressOffset>0x004</addressOffset>
            <size>0x20</size>
            <resetValue>0x0000007F</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>W</name>
                <description>7-bit window value
These bits contain the window value to be compared with the down-counter.</description>
                <bitOffset>0</bitOffset>
                <bitWidth>7</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>EWI</name>
                <description>Early wakeup interrupt
When set, an interrupt occurs whenever the counter reaches the value 0x40. This interrupt is only cleared by hardware after a reset.</description>
                <bitOffset>9</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>WDGTB</name>
                <description>Timer base
The timebase of the prescaler can be modified as follows:</description>
                <bitOffset>11</bitOffset>
                <bitWidth>3</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>CK counter clock (PCLK div 4096) div 1</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>CK counter clock (PCLK div 4096) div 2</description>
                    <value>0x1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x2</name>
                    <description>CK counter clock (PCLK div 4096) div 4</description>
                    <value>0x2</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x3</name>
                    <description>CK counter clock (PCLK div 4096) div 8</description>
                    <value>0x3</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x4</name>
                    <description>CK counter clock (PCLK div 4096) div 16</description>
                    <value>0x4</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x5</name>
                    <description>CK counter clock (PCLK div 4096) div 32</description>
                    <value>0x5</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x6</name>
                    <description>CK counter clock (PCLK div 4096) div 64</description>
                    <value>0x6</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x7</name>
                    <description>CK counter clock (PCLK div 4096) div 128</description>
                    <value>0x7</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
            </fields>
          </register>
          <register>
            <name>WWDG_SR</name>
            <displayName>WWDG_SR</displayName>
            <description>WWDG status register</description>
            <addressOffset>0x008</addressOffset>
            <size>0x20</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>EWIF</name>
                <description>Early wakeup interrupt flag
This bit is set by hardware when the counter has reached the value 0x40. It must be cleared by software by writing 0. Writing 1 has no effect. This bit is also set if the interrupt is not enabled.</description>
                <bitOffset>0</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
            </fields>
          </register>
        </registers>
    </peripheral>
	<peripheral derivedFrom="WWDG">
        <name>SEC_WWDG</name>
        <baseAddress>0x50002C00</baseAddress>
    </peripheral>
    
    
  </peripherals>
</device>
